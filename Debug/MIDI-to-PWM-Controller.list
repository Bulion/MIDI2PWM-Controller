
MIDI-to-PWM-Controller.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00009068  080001c8  080001c8  000101c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000078  08009230  08009230  00019230  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  080092a8  080092a8  000192a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  080092b0  080092b0  000192b0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  080092b4  080092b4  000192b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         0000025c  20000000  080092b8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00002944  2000025c  08009514  0002025c  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  20002ba0  08009514  00022ba0  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  0002025c  2**0
                  CONTENTS, READONLY
 10 .debug_info   00030449  00000000  00000000  0002028c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00005ab5  00000000  00000000  000506d5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0001cbfa  00000000  00000000  0005618a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00001578  00000000  00000000  00072d88  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00006258  00000000  00000000  00074300  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_macro  0002bb01  00000000  00000000  0007a558  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_line   0001eff0  00000000  00000000  000a6059  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    000f827f  00000000  00000000  000c5049  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000007b  00000000  00000000  001bd2c8  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00004a54  00000000  00000000  001bd344  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001c8 <__do_global_dtors_aux>:
 80001c8:	b510      	push	{r4, lr}
 80001ca:	4c05      	ldr	r4, [pc, #20]	; (80001e0 <__do_global_dtors_aux+0x18>)
 80001cc:	7823      	ldrb	r3, [r4, #0]
 80001ce:	b933      	cbnz	r3, 80001de <__do_global_dtors_aux+0x16>
 80001d0:	4b04      	ldr	r3, [pc, #16]	; (80001e4 <__do_global_dtors_aux+0x1c>)
 80001d2:	b113      	cbz	r3, 80001da <__do_global_dtors_aux+0x12>
 80001d4:	4804      	ldr	r0, [pc, #16]	; (80001e8 <__do_global_dtors_aux+0x20>)
 80001d6:	f3af 8000 	nop.w
 80001da:	2301      	movs	r3, #1
 80001dc:	7023      	strb	r3, [r4, #0]
 80001de:	bd10      	pop	{r4, pc}
 80001e0:	2000025c 	.word	0x2000025c
 80001e4:	00000000 	.word	0x00000000
 80001e8:	08009218 	.word	0x08009218

080001ec <frame_dummy>:
 80001ec:	b508      	push	{r3, lr}
 80001ee:	4b03      	ldr	r3, [pc, #12]	; (80001fc <frame_dummy+0x10>)
 80001f0:	b11b      	cbz	r3, 80001fa <frame_dummy+0xe>
 80001f2:	4903      	ldr	r1, [pc, #12]	; (8000200 <frame_dummy+0x14>)
 80001f4:	4803      	ldr	r0, [pc, #12]	; (8000204 <frame_dummy+0x18>)
 80001f6:	f3af 8000 	nop.w
 80001fa:	bd08      	pop	{r3, pc}
 80001fc:	00000000 	.word	0x00000000
 8000200:	20000260 	.word	0x20000260
 8000204:	08009218 	.word	0x08009218

08000208 <__aeabi_uldivmod>:
 8000208:	b953      	cbnz	r3, 8000220 <__aeabi_uldivmod+0x18>
 800020a:	b94a      	cbnz	r2, 8000220 <__aeabi_uldivmod+0x18>
 800020c:	2900      	cmp	r1, #0
 800020e:	bf08      	it	eq
 8000210:	2800      	cmpeq	r0, #0
 8000212:	bf1c      	itt	ne
 8000214:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000218:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 800021c:	f000 b972 	b.w	8000504 <__aeabi_idiv0>
 8000220:	f1ad 0c08 	sub.w	ip, sp, #8
 8000224:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000228:	f000 f806 	bl	8000238 <__udivmoddi4>
 800022c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000230:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000234:	b004      	add	sp, #16
 8000236:	4770      	bx	lr

08000238 <__udivmoddi4>:
 8000238:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800023c:	9e08      	ldr	r6, [sp, #32]
 800023e:	4604      	mov	r4, r0
 8000240:	4688      	mov	r8, r1
 8000242:	2b00      	cmp	r3, #0
 8000244:	d14b      	bne.n	80002de <__udivmoddi4+0xa6>
 8000246:	428a      	cmp	r2, r1
 8000248:	4615      	mov	r5, r2
 800024a:	d967      	bls.n	800031c <__udivmoddi4+0xe4>
 800024c:	fab2 f282 	clz	r2, r2
 8000250:	b14a      	cbz	r2, 8000266 <__udivmoddi4+0x2e>
 8000252:	f1c2 0720 	rsb	r7, r2, #32
 8000256:	fa01 f302 	lsl.w	r3, r1, r2
 800025a:	fa20 f707 	lsr.w	r7, r0, r7
 800025e:	4095      	lsls	r5, r2
 8000260:	ea47 0803 	orr.w	r8, r7, r3
 8000264:	4094      	lsls	r4, r2
 8000266:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800026a:	0c23      	lsrs	r3, r4, #16
 800026c:	fbb8 f7fe 	udiv	r7, r8, lr
 8000270:	fa1f fc85 	uxth.w	ip, r5
 8000274:	fb0e 8817 	mls	r8, lr, r7, r8
 8000278:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800027c:	fb07 f10c 	mul.w	r1, r7, ip
 8000280:	4299      	cmp	r1, r3
 8000282:	d909      	bls.n	8000298 <__udivmoddi4+0x60>
 8000284:	18eb      	adds	r3, r5, r3
 8000286:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 800028a:	f080 811b 	bcs.w	80004c4 <__udivmoddi4+0x28c>
 800028e:	4299      	cmp	r1, r3
 8000290:	f240 8118 	bls.w	80004c4 <__udivmoddi4+0x28c>
 8000294:	3f02      	subs	r7, #2
 8000296:	442b      	add	r3, r5
 8000298:	1a5b      	subs	r3, r3, r1
 800029a:	b2a4      	uxth	r4, r4
 800029c:	fbb3 f0fe 	udiv	r0, r3, lr
 80002a0:	fb0e 3310 	mls	r3, lr, r0, r3
 80002a4:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 80002a8:	fb00 fc0c 	mul.w	ip, r0, ip
 80002ac:	45a4      	cmp	ip, r4
 80002ae:	d909      	bls.n	80002c4 <__udivmoddi4+0x8c>
 80002b0:	192c      	adds	r4, r5, r4
 80002b2:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80002b6:	f080 8107 	bcs.w	80004c8 <__udivmoddi4+0x290>
 80002ba:	45a4      	cmp	ip, r4
 80002bc:	f240 8104 	bls.w	80004c8 <__udivmoddi4+0x290>
 80002c0:	3802      	subs	r0, #2
 80002c2:	442c      	add	r4, r5
 80002c4:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 80002c8:	eba4 040c 	sub.w	r4, r4, ip
 80002cc:	2700      	movs	r7, #0
 80002ce:	b11e      	cbz	r6, 80002d8 <__udivmoddi4+0xa0>
 80002d0:	40d4      	lsrs	r4, r2
 80002d2:	2300      	movs	r3, #0
 80002d4:	e9c6 4300 	strd	r4, r3, [r6]
 80002d8:	4639      	mov	r1, r7
 80002da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002de:	428b      	cmp	r3, r1
 80002e0:	d909      	bls.n	80002f6 <__udivmoddi4+0xbe>
 80002e2:	2e00      	cmp	r6, #0
 80002e4:	f000 80eb 	beq.w	80004be <__udivmoddi4+0x286>
 80002e8:	2700      	movs	r7, #0
 80002ea:	e9c6 0100 	strd	r0, r1, [r6]
 80002ee:	4638      	mov	r0, r7
 80002f0:	4639      	mov	r1, r7
 80002f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002f6:	fab3 f783 	clz	r7, r3
 80002fa:	2f00      	cmp	r7, #0
 80002fc:	d147      	bne.n	800038e <__udivmoddi4+0x156>
 80002fe:	428b      	cmp	r3, r1
 8000300:	d302      	bcc.n	8000308 <__udivmoddi4+0xd0>
 8000302:	4282      	cmp	r2, r0
 8000304:	f200 80fa 	bhi.w	80004fc <__udivmoddi4+0x2c4>
 8000308:	1a84      	subs	r4, r0, r2
 800030a:	eb61 0303 	sbc.w	r3, r1, r3
 800030e:	2001      	movs	r0, #1
 8000310:	4698      	mov	r8, r3
 8000312:	2e00      	cmp	r6, #0
 8000314:	d0e0      	beq.n	80002d8 <__udivmoddi4+0xa0>
 8000316:	e9c6 4800 	strd	r4, r8, [r6]
 800031a:	e7dd      	b.n	80002d8 <__udivmoddi4+0xa0>
 800031c:	b902      	cbnz	r2, 8000320 <__udivmoddi4+0xe8>
 800031e:	deff      	udf	#255	; 0xff
 8000320:	fab2 f282 	clz	r2, r2
 8000324:	2a00      	cmp	r2, #0
 8000326:	f040 808f 	bne.w	8000448 <__udivmoddi4+0x210>
 800032a:	1b49      	subs	r1, r1, r5
 800032c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000330:	fa1f f885 	uxth.w	r8, r5
 8000334:	2701      	movs	r7, #1
 8000336:	fbb1 fcfe 	udiv	ip, r1, lr
 800033a:	0c23      	lsrs	r3, r4, #16
 800033c:	fb0e 111c 	mls	r1, lr, ip, r1
 8000340:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000344:	fb08 f10c 	mul.w	r1, r8, ip
 8000348:	4299      	cmp	r1, r3
 800034a:	d907      	bls.n	800035c <__udivmoddi4+0x124>
 800034c:	18eb      	adds	r3, r5, r3
 800034e:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 8000352:	d202      	bcs.n	800035a <__udivmoddi4+0x122>
 8000354:	4299      	cmp	r1, r3
 8000356:	f200 80cd 	bhi.w	80004f4 <__udivmoddi4+0x2bc>
 800035a:	4684      	mov	ip, r0
 800035c:	1a59      	subs	r1, r3, r1
 800035e:	b2a3      	uxth	r3, r4
 8000360:	fbb1 f0fe 	udiv	r0, r1, lr
 8000364:	fb0e 1410 	mls	r4, lr, r0, r1
 8000368:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 800036c:	fb08 f800 	mul.w	r8, r8, r0
 8000370:	45a0      	cmp	r8, r4
 8000372:	d907      	bls.n	8000384 <__udivmoddi4+0x14c>
 8000374:	192c      	adds	r4, r5, r4
 8000376:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800037a:	d202      	bcs.n	8000382 <__udivmoddi4+0x14a>
 800037c:	45a0      	cmp	r8, r4
 800037e:	f200 80b6 	bhi.w	80004ee <__udivmoddi4+0x2b6>
 8000382:	4618      	mov	r0, r3
 8000384:	eba4 0408 	sub.w	r4, r4, r8
 8000388:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 800038c:	e79f      	b.n	80002ce <__udivmoddi4+0x96>
 800038e:	f1c7 0c20 	rsb	ip, r7, #32
 8000392:	40bb      	lsls	r3, r7
 8000394:	fa22 fe0c 	lsr.w	lr, r2, ip
 8000398:	ea4e 0e03 	orr.w	lr, lr, r3
 800039c:	fa01 f407 	lsl.w	r4, r1, r7
 80003a0:	fa20 f50c 	lsr.w	r5, r0, ip
 80003a4:	fa21 f30c 	lsr.w	r3, r1, ip
 80003a8:	ea4f 481e 	mov.w	r8, lr, lsr #16
 80003ac:	4325      	orrs	r5, r4
 80003ae:	fbb3 f9f8 	udiv	r9, r3, r8
 80003b2:	0c2c      	lsrs	r4, r5, #16
 80003b4:	fb08 3319 	mls	r3, r8, r9, r3
 80003b8:	fa1f fa8e 	uxth.w	sl, lr
 80003bc:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 80003c0:	fb09 f40a 	mul.w	r4, r9, sl
 80003c4:	429c      	cmp	r4, r3
 80003c6:	fa02 f207 	lsl.w	r2, r2, r7
 80003ca:	fa00 f107 	lsl.w	r1, r0, r7
 80003ce:	d90b      	bls.n	80003e8 <__udivmoddi4+0x1b0>
 80003d0:	eb1e 0303 	adds.w	r3, lr, r3
 80003d4:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 80003d8:	f080 8087 	bcs.w	80004ea <__udivmoddi4+0x2b2>
 80003dc:	429c      	cmp	r4, r3
 80003de:	f240 8084 	bls.w	80004ea <__udivmoddi4+0x2b2>
 80003e2:	f1a9 0902 	sub.w	r9, r9, #2
 80003e6:	4473      	add	r3, lr
 80003e8:	1b1b      	subs	r3, r3, r4
 80003ea:	b2ad      	uxth	r5, r5
 80003ec:	fbb3 f0f8 	udiv	r0, r3, r8
 80003f0:	fb08 3310 	mls	r3, r8, r0, r3
 80003f4:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 80003f8:	fb00 fa0a 	mul.w	sl, r0, sl
 80003fc:	45a2      	cmp	sl, r4
 80003fe:	d908      	bls.n	8000412 <__udivmoddi4+0x1da>
 8000400:	eb1e 0404 	adds.w	r4, lr, r4
 8000404:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8000408:	d26b      	bcs.n	80004e2 <__udivmoddi4+0x2aa>
 800040a:	45a2      	cmp	sl, r4
 800040c:	d969      	bls.n	80004e2 <__udivmoddi4+0x2aa>
 800040e:	3802      	subs	r0, #2
 8000410:	4474      	add	r4, lr
 8000412:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000416:	fba0 8902 	umull	r8, r9, r0, r2
 800041a:	eba4 040a 	sub.w	r4, r4, sl
 800041e:	454c      	cmp	r4, r9
 8000420:	46c2      	mov	sl, r8
 8000422:	464b      	mov	r3, r9
 8000424:	d354      	bcc.n	80004d0 <__udivmoddi4+0x298>
 8000426:	d051      	beq.n	80004cc <__udivmoddi4+0x294>
 8000428:	2e00      	cmp	r6, #0
 800042a:	d069      	beq.n	8000500 <__udivmoddi4+0x2c8>
 800042c:	ebb1 050a 	subs.w	r5, r1, sl
 8000430:	eb64 0403 	sbc.w	r4, r4, r3
 8000434:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000438:	40fd      	lsrs	r5, r7
 800043a:	40fc      	lsrs	r4, r7
 800043c:	ea4c 0505 	orr.w	r5, ip, r5
 8000440:	e9c6 5400 	strd	r5, r4, [r6]
 8000444:	2700      	movs	r7, #0
 8000446:	e747      	b.n	80002d8 <__udivmoddi4+0xa0>
 8000448:	f1c2 0320 	rsb	r3, r2, #32
 800044c:	fa20 f703 	lsr.w	r7, r0, r3
 8000450:	4095      	lsls	r5, r2
 8000452:	fa01 f002 	lsl.w	r0, r1, r2
 8000456:	fa21 f303 	lsr.w	r3, r1, r3
 800045a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 800045e:	4338      	orrs	r0, r7
 8000460:	0c01      	lsrs	r1, r0, #16
 8000462:	fbb3 f7fe 	udiv	r7, r3, lr
 8000466:	fa1f f885 	uxth.w	r8, r5
 800046a:	fb0e 3317 	mls	r3, lr, r7, r3
 800046e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000472:	fb07 f308 	mul.w	r3, r7, r8
 8000476:	428b      	cmp	r3, r1
 8000478:	fa04 f402 	lsl.w	r4, r4, r2
 800047c:	d907      	bls.n	800048e <__udivmoddi4+0x256>
 800047e:	1869      	adds	r1, r5, r1
 8000480:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 8000484:	d22f      	bcs.n	80004e6 <__udivmoddi4+0x2ae>
 8000486:	428b      	cmp	r3, r1
 8000488:	d92d      	bls.n	80004e6 <__udivmoddi4+0x2ae>
 800048a:	3f02      	subs	r7, #2
 800048c:	4429      	add	r1, r5
 800048e:	1acb      	subs	r3, r1, r3
 8000490:	b281      	uxth	r1, r0
 8000492:	fbb3 f0fe 	udiv	r0, r3, lr
 8000496:	fb0e 3310 	mls	r3, lr, r0, r3
 800049a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800049e:	fb00 f308 	mul.w	r3, r0, r8
 80004a2:	428b      	cmp	r3, r1
 80004a4:	d907      	bls.n	80004b6 <__udivmoddi4+0x27e>
 80004a6:	1869      	adds	r1, r5, r1
 80004a8:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 80004ac:	d217      	bcs.n	80004de <__udivmoddi4+0x2a6>
 80004ae:	428b      	cmp	r3, r1
 80004b0:	d915      	bls.n	80004de <__udivmoddi4+0x2a6>
 80004b2:	3802      	subs	r0, #2
 80004b4:	4429      	add	r1, r5
 80004b6:	1ac9      	subs	r1, r1, r3
 80004b8:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 80004bc:	e73b      	b.n	8000336 <__udivmoddi4+0xfe>
 80004be:	4637      	mov	r7, r6
 80004c0:	4630      	mov	r0, r6
 80004c2:	e709      	b.n	80002d8 <__udivmoddi4+0xa0>
 80004c4:	4607      	mov	r7, r0
 80004c6:	e6e7      	b.n	8000298 <__udivmoddi4+0x60>
 80004c8:	4618      	mov	r0, r3
 80004ca:	e6fb      	b.n	80002c4 <__udivmoddi4+0x8c>
 80004cc:	4541      	cmp	r1, r8
 80004ce:	d2ab      	bcs.n	8000428 <__udivmoddi4+0x1f0>
 80004d0:	ebb8 0a02 	subs.w	sl, r8, r2
 80004d4:	eb69 020e 	sbc.w	r2, r9, lr
 80004d8:	3801      	subs	r0, #1
 80004da:	4613      	mov	r3, r2
 80004dc:	e7a4      	b.n	8000428 <__udivmoddi4+0x1f0>
 80004de:	4660      	mov	r0, ip
 80004e0:	e7e9      	b.n	80004b6 <__udivmoddi4+0x27e>
 80004e2:	4618      	mov	r0, r3
 80004e4:	e795      	b.n	8000412 <__udivmoddi4+0x1da>
 80004e6:	4667      	mov	r7, ip
 80004e8:	e7d1      	b.n	800048e <__udivmoddi4+0x256>
 80004ea:	4681      	mov	r9, r0
 80004ec:	e77c      	b.n	80003e8 <__udivmoddi4+0x1b0>
 80004ee:	3802      	subs	r0, #2
 80004f0:	442c      	add	r4, r5
 80004f2:	e747      	b.n	8000384 <__udivmoddi4+0x14c>
 80004f4:	f1ac 0c02 	sub.w	ip, ip, #2
 80004f8:	442b      	add	r3, r5
 80004fa:	e72f      	b.n	800035c <__udivmoddi4+0x124>
 80004fc:	4638      	mov	r0, r7
 80004fe:	e708      	b.n	8000312 <__udivmoddi4+0xda>
 8000500:	4637      	mov	r7, r6
 8000502:	e6e9      	b.n	80002d8 <__udivmoddi4+0xa0>

08000504 <__aeabi_idiv0>:
 8000504:	4770      	bx	lr
 8000506:	bf00      	nop

08000508 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000508:	b538      	push	{r3, r4, r5, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 800050a:	4c0d      	ldr	r4, [pc, #52]	; (8000540 <HAL_InitTick+0x38>)
 800050c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000510:	490c      	ldr	r1, [pc, #48]	; (8000544 <HAL_InitTick+0x3c>)
{
 8000512:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000514:	7822      	ldrb	r2, [r4, #0]
 8000516:	6808      	ldr	r0, [r1, #0]
 8000518:	fbb3 f3f2 	udiv	r3, r3, r2
 800051c:	fbb0 f0f3 	udiv	r0, r0, r3
 8000520:	f000 faea 	bl	8000af8 <HAL_SYSTICK_Config>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000524:	b908      	cbnz	r0, 800052a <HAL_InitTick+0x22>
 8000526:	2d0f      	cmp	r5, #15
 8000528:	d901      	bls.n	800052e <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 800052a:	2001      	movs	r0, #1
  }

  /* Return function status */
  return HAL_OK;
}
 800052c:	bd38      	pop	{r3, r4, r5, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 800052e:	2200      	movs	r2, #0
 8000530:	4629      	mov	r1, r5
 8000532:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000536:	f000 fa9b 	bl	8000a70 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800053a:	6065      	str	r5, [r4, #4]
 800053c:	2000      	movs	r0, #0
}
 800053e:	bd38      	pop	{r3, r4, r5, pc}
 8000540:	20000000 	.word	0x20000000
 8000544:	20000184 	.word	0x20000184

08000548 <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000548:	4a07      	ldr	r2, [pc, #28]	; (8000568 <HAL_Init+0x20>)
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800054a:	2003      	movs	r0, #3
{
 800054c:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 800054e:	6813      	ldr	r3, [r2, #0]
 8000550:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000554:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000556:	f000 fa77 	bl	8000a48 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 800055a:	2000      	movs	r0, #0
 800055c:	f7ff ffd4 	bl	8000508 <HAL_InitTick>
  HAL_MspInit();
 8000560:	f006 faf0 	bl	8006b44 <HAL_MspInit>
}
 8000564:	2000      	movs	r0, #0
 8000566:	bd08      	pop	{r3, pc}
 8000568:	40023c00 	.word	0x40023c00

0800056c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800056c:	4a03      	ldr	r2, [pc, #12]	; (800057c <HAL_IncTick+0x10>)
 800056e:	4b04      	ldr	r3, [pc, #16]	; (8000580 <HAL_IncTick+0x14>)
 8000570:	6811      	ldr	r1, [r2, #0]
 8000572:	781b      	ldrb	r3, [r3, #0]
 8000574:	440b      	add	r3, r1
 8000576:	6013      	str	r3, [r2, #0]
}
 8000578:	4770      	bx	lr
 800057a:	bf00      	nop
 800057c:	20000298 	.word	0x20000298
 8000580:	20000000 	.word	0x20000000

08000584 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000584:	4b01      	ldr	r3, [pc, #4]	; (800058c <HAL_GetTick+0x8>)
 8000586:	6818      	ldr	r0, [r3, #0]
}
 8000588:	4770      	bx	lr
 800058a:	bf00      	nop
 800058c:	20000298 	.word	0x20000298

08000590 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000590:	b538      	push	{r3, r4, r5, lr}
 8000592:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000594:	f7ff fff6 	bl	8000584 <HAL_GetTick>
 8000598:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800059a:	1c63      	adds	r3, r4, #1
 800059c:	d002      	beq.n	80005a4 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 800059e:	4b04      	ldr	r3, [pc, #16]	; (80005b0 <HAL_Delay+0x20>)
 80005a0:	781b      	ldrb	r3, [r3, #0]
 80005a2:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 80005a4:	f7ff ffee 	bl	8000584 <HAL_GetTick>
 80005a8:	1b40      	subs	r0, r0, r5
 80005aa:	42a0      	cmp	r0, r4
 80005ac:	d3fa      	bcc.n	80005a4 <HAL_Delay+0x14>
  {
  }
}
 80005ae:	bd38      	pop	{r3, r4, r5, pc}
 80005b0:	20000000 	.word	0x20000000

080005b4 <HAL_ADC_Init>:
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  
  /* Check ADC handle */
  if(hadc == NULL)
 80005b4:	2800      	cmp	r0, #0
 80005b6:	f000 8092 	beq.w	80006de <HAL_ADC_Init+0x12a>
{
 80005ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }

  if(hadc->State == HAL_ADC_STATE_RESET)
 80005bc:	6c05      	ldr	r5, [r0, #64]	; 0x40
 80005be:	4604      	mov	r4, r0
 80005c0:	2d00      	cmp	r5, #0
 80005c2:	f000 8082 	beq.w	80006ca <HAL_ADC_Init+0x116>
    hadc->Lock = HAL_UNLOCKED;
  }
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80005c6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80005c8:	06db      	lsls	r3, r3, #27
 80005ca:	d504      	bpl.n	80005d6 <HAL_ADC_Init+0x22>
  {
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Release Lock */
  __HAL_UNLOCK(hadc);
 80005cc:	2300      	movs	r3, #0
    tmp_hal_status = HAL_ERROR;
 80005ce:	2001      	movs	r0, #1
  __HAL_UNLOCK(hadc);
 80005d0:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c

  /* Return function status */
  return tmp_hal_status;
}
 80005d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ADC_STATE_CLR_SET(hadc->State,
 80005d6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80005d8:	4a4e      	ldr	r2, [pc, #312]	; (8000714 <HAL_ADC_Init+0x160>)
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 80005da:	494f      	ldr	r1, [pc, #316]	; (8000718 <HAL_ADC_Init+0x164>)
    ADC_STATE_CLR_SET(hadc->State,
 80005dc:	401a      	ands	r2, r3
  ADC->CCR |=  hadc->Init.ClockPrescaler;
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 80005de:	6823      	ldr	r3, [r4, #0]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80005e0:	4d4e      	ldr	r5, [pc, #312]	; (800071c <HAL_ADC_Init+0x168>)
    ADC_STATE_CLR_SET(hadc->State,
 80005e2:	f042 0202 	orr.w	r2, r2, #2
 80005e6:	6422      	str	r2, [r4, #64]	; 0x40
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 80005e8:	684a      	ldr	r2, [r1, #4]
 80005ea:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 80005ee:	604a      	str	r2, [r1, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 80005f0:	684a      	ldr	r2, [r1, #4]
 80005f2:	6860      	ldr	r0, [r4, #4]
 80005f4:	4302      	orrs	r2, r0
 80005f6:	604a      	str	r2, [r1, #4]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 80005f8:	685a      	ldr	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 80005fa:	6921      	ldr	r1, [r4, #16]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 80005fc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 8000600:	f8d4 c008 	ldr.w	ip, [r4, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 8000604:	68e7      	ldr	r7, [r4, #12]
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8000606:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8000608:	6858      	ldr	r0, [r3, #4]
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800060a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 800060c:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8000610:	42ae      	cmp	r6, r5
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 8000612:	6058      	str	r0, [r3, #4]
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 8000614:	6858      	ldr	r0, [r3, #4]
 8000616:	f020 7040 	bic.w	r0, r0, #50331648	; 0x3000000
 800061a:	6058      	str	r0, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 800061c:	6859      	ldr	r1, [r3, #4]
 800061e:	ea41 010c 	orr.w	r1, r1, ip
 8000622:	6059      	str	r1, [r3, #4]
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 8000624:	6899      	ldr	r1, [r3, #8]
 8000626:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
 800062a:	6099      	str	r1, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 800062c:	689a      	ldr	r2, [r3, #8]
 800062e:	ea42 0207 	orr.w	r2, r2, r7
 8000632:	609a      	str	r2, [r3, #8]
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8000634:	d055      	beq.n	80006e2 <HAL_ADC_Init+0x12e>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8000636:	6899      	ldr	r1, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 8000638:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 800063a:	f021 6170 	bic.w	r1, r1, #251658240	; 0xf000000
 800063e:	6099      	str	r1, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 8000640:	689a      	ldr	r2, [r3, #8]
 8000642:	4316      	orrs	r6, r2
 8000644:	609e      	str	r6, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8000646:	6899      	ldr	r1, [r3, #8]
 8000648:	f021 5140 	bic.w	r1, r1, #805306368	; 0x30000000
 800064c:	6099      	str	r1, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 800064e:	689a      	ldr	r2, [r3, #8]
 8000650:	4302      	orrs	r2, r0
 8000652:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8000654:	6899      	ldr	r1, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 8000656:	69a5      	ldr	r5, [r4, #24]
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8000658:	f021 0102 	bic.w	r1, r1, #2
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 800065c:	f894 0020 	ldrb.w	r0, [r4, #32]
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8000660:	6099      	str	r1, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 8000662:	689a      	ldr	r2, [r3, #8]
 8000664:	ea42 0245 	orr.w	r2, r2, r5, lsl #1
 8000668:	609a      	str	r2, [r3, #8]
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 800066a:	2800      	cmp	r0, #0
 800066c:	d142      	bne.n	80006f4 <HAL_ADC_Init+0x140>
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 800066e:	685a      	ldr	r2, [r3, #4]
 8000670:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8000674:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8000676:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    ADC_CLEAR_ERRORCODE(hadc);
 8000678:	2600      	movs	r6, #0
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 800067a:	69e5      	ldr	r5, [r4, #28]
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 800067c:	f420 0070 	bic.w	r0, r0, #15728640	; 0xf00000
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 8000680:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8000684:	1e6a      	subs	r2, r5, #1
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8000686:	6967      	ldr	r7, [r4, #20]
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8000688:	62d8      	str	r0, [r3, #44]	; 0x2c
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800068a:	4630      	mov	r0, r6
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 800068c:	6add      	ldr	r5, [r3, #44]	; 0x2c
 800068e:	ea45 5502 	orr.w	r5, r5, r2, lsl #20
 8000692:	62dd      	str	r5, [r3, #44]	; 0x2c
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 8000694:	689d      	ldr	r5, [r3, #8]
 8000696:	f425 7500 	bic.w	r5, r5, #512	; 0x200
 800069a:	609d      	str	r5, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 800069c:	6899      	ldr	r1, [r3, #8]
 800069e:	ea41 214c 	orr.w	r1, r1, ip, lsl #9
 80006a2:	6099      	str	r1, [r3, #8]
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 80006a4:	6899      	ldr	r1, [r3, #8]
 80006a6:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 80006aa:	6099      	str	r1, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 80006ac:	689a      	ldr	r2, [r3, #8]
 80006ae:	ea42 2287 	orr.w	r2, r2, r7, lsl #10
 80006b2:	609a      	str	r2, [r3, #8]
    ADC_CLEAR_ERRORCODE(hadc);
 80006b4:	6466      	str	r6, [r4, #68]	; 0x44
    ADC_STATE_CLR_SET(hadc->State,
 80006b6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80006b8:	f023 0303 	bic.w	r3, r3, #3
 80006bc:	f043 0301 	orr.w	r3, r3, #1
 80006c0:	6423      	str	r3, [r4, #64]	; 0x40
  __HAL_UNLOCK(hadc);
 80006c2:	2300      	movs	r3, #0
 80006c4:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 80006c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    HAL_ADC_MspInit(hadc);
 80006ca:	f004 fc43 	bl	8004f54 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 80006ce:	6465      	str	r5, [r4, #68]	; 0x44
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80006d0:	6c23      	ldr	r3, [r4, #64]	; 0x40
    hadc->Lock = HAL_UNLOCKED;
 80006d2:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80006d6:	06db      	lsls	r3, r3, #27
 80006d8:	f53f af78 	bmi.w	80005cc <HAL_ADC_Init+0x18>
 80006dc:	e77b      	b.n	80005d6 <HAL_ADC_Init+0x22>
    return HAL_ERROR;
 80006de:	2001      	movs	r0, #1
}
 80006e0:	4770      	bx	lr
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 80006e2:	689a      	ldr	r2, [r3, #8]
 80006e4:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 80006e8:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 80006ea:	689a      	ldr	r2, [r3, #8]
 80006ec:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 80006f0:	609a      	str	r2, [r3, #8]
 80006f2:	e7af      	b.n	8000654 <HAL_ADC_Init+0xa0>
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80006f4:	6858      	ldr	r0, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 80006f6:	6a62      	ldr	r2, [r4, #36]	; 0x24
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80006f8:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 80006fc:	1e51      	subs	r1, r2, #1
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80006fe:	6058      	str	r0, [r3, #4]
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 8000700:	685a      	ldr	r2, [r3, #4]
 8000702:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8000706:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8000708:	685a      	ldr	r2, [r3, #4]
 800070a:	ea42 3241 	orr.w	r2, r2, r1, lsl #13
 800070e:	605a      	str	r2, [r3, #4]
 8000710:	e7b1      	b.n	8000676 <HAL_ADC_Init+0xc2>
 8000712:	bf00      	nop
 8000714:	ffffeefd 	.word	0xffffeefd
 8000718:	40012300 	.word	0x40012300
 800071c:	0f000001 	.word	0x0f000001

08000720 <HAL_ADC_Start>:
  __HAL_LOCK(hadc);
 8000720:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
  __IO uint32_t counter = 0;
 8000724:	2200      	movs	r2, #0
{
 8000726:	b410      	push	{r4}
  __HAL_LOCK(hadc);
 8000728:	2b01      	cmp	r3, #1
{
 800072a:	b083      	sub	sp, #12
  __IO uint32_t counter = 0;
 800072c:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 800072e:	d070      	beq.n	8000812 <HAL_ADC_Start+0xf2>
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8000730:	6802      	ldr	r2, [r0, #0]
  __HAL_LOCK(hadc);
 8000732:	2101      	movs	r1, #1
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 8000734:	6893      	ldr	r3, [r2, #8]
  __HAL_LOCK(hadc);
 8000736:	f880 103c 	strb.w	r1, [r0, #60]	; 0x3c
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
 800073a:	07d9      	lsls	r1, r3, #31
 800073c:	d414      	bmi.n	8000768 <HAL_ADC_Start+0x48>
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 800073e:	4b37      	ldr	r3, [pc, #220]	; (800081c <HAL_ADC_Start+0xfc>)
 8000740:	4c37      	ldr	r4, [pc, #220]	; (8000820 <HAL_ADC_Start+0x100>)
 8000742:	681b      	ldr	r3, [r3, #0]
    __HAL_ADC_ENABLE(hadc);
 8000744:	6891      	ldr	r1, [r2, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8000746:	fba4 4303 	umull	r4, r3, r4, r3
    __HAL_ADC_ENABLE(hadc);
 800074a:	f041 0101 	orr.w	r1, r1, #1
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 800074e:	0c9b      	lsrs	r3, r3, #18
    __HAL_ADC_ENABLE(hadc);
 8000750:	6091      	str	r1, [r2, #8]
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
 8000752:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8000756:	9301      	str	r3, [sp, #4]
    while(counter != 0)
 8000758:	9b01      	ldr	r3, [sp, #4]
 800075a:	b12b      	cbz	r3, 8000768 <HAL_ADC_Start+0x48>
      counter--;
 800075c:	9b01      	ldr	r3, [sp, #4]
 800075e:	3b01      	subs	r3, #1
 8000760:	9301      	str	r3, [sp, #4]
    while(counter != 0)
 8000762:	9b01      	ldr	r3, [sp, #4]
 8000764:	2b00      	cmp	r3, #0
 8000766:	d1f9      	bne.n	800075c <HAL_ADC_Start+0x3c>
  if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
 8000768:	6893      	ldr	r3, [r2, #8]
 800076a:	07db      	lsls	r3, r3, #31
 800076c:	d524      	bpl.n	80007b8 <HAL_ADC_Start+0x98>
    ADC_STATE_CLR_SET(hadc->State,
 800076e:	6c01      	ldr	r1, [r0, #64]	; 0x40
 8000770:	4b2c      	ldr	r3, [pc, #176]	; (8000824 <HAL_ADC_Start+0x104>)
 8000772:	400b      	ands	r3, r1
 8000774:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000778:	6403      	str	r3, [r0, #64]	; 0x40
    if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 800077a:	6853      	ldr	r3, [r2, #4]
 800077c:	055c      	lsls	r4, r3, #21
 800077e:	d505      	bpl.n	800078c <HAL_ADC_Start+0x6c>
      ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 8000780:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8000782:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8000786:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800078a:	6403      	str	r3, [r0, #64]	; 0x40
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 800078c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800078e:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
 8000792:	d028      	beq.n	80007e6 <HAL_ADC_Start+0xc6>
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 8000794:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8000796:	f023 0306 	bic.w	r3, r3, #6
 800079a:	6443      	str	r3, [r0, #68]	; 0x44
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 800079c:	f06f 0122 	mvn.w	r1, #34	; 0x22
    __HAL_UNLOCK(hadc);
 80007a0:	2400      	movs	r4, #0
    if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 80007a2:	4b21      	ldr	r3, [pc, #132]	; (8000828 <HAL_ADC_Start+0x108>)
    __HAL_UNLOCK(hadc);
 80007a4:	f880 403c 	strb.w	r4, [r0, #60]	; 0x3c
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
 80007a8:	6011      	str	r1, [r2, #0]
    if(HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
 80007aa:	6859      	ldr	r1, [r3, #4]
 80007ac:	06c9      	lsls	r1, r1, #27
 80007ae:	d108      	bne.n	80007c2 <HAL_ADC_Start+0xa2>
      if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
 80007b0:	6890      	ldr	r0, [r2, #8]
 80007b2:	f010 5040 	ands.w	r0, r0, #805306368	; 0x30000000
 80007b6:	d018      	beq.n	80007ea <HAL_ADC_Start+0xca>
  return HAL_OK;
 80007b8:	2000      	movs	r0, #0
}
 80007ba:	b003      	add	sp, #12
 80007bc:	f85d 4b04 	ldr.w	r4, [sp], #4
 80007c0:	4770      	bx	lr
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80007c2:	491a      	ldr	r1, [pc, #104]	; (800082c <HAL_ADC_Start+0x10c>)
 80007c4:	428a      	cmp	r2, r1
 80007c6:	d018      	beq.n	80007fa <HAL_ADC_Start+0xda>
      if( HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI_4) )
 80007c8:	685b      	ldr	r3, [r3, #4]
        if((hadc->Instance == ADC3) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80007ca:	06db      	lsls	r3, r3, #27
 80007cc:	d4f4      	bmi.n	80007b8 <HAL_ADC_Start+0x98>
 80007ce:	4918      	ldr	r1, [pc, #96]	; (8000830 <HAL_ADC_Start+0x110>)
 80007d0:	428a      	cmp	r2, r1
 80007d2:	d1f1      	bne.n	80007b8 <HAL_ADC_Start+0x98>
 80007d4:	6888      	ldr	r0, [r1, #8]
 80007d6:	f010 5040 	ands.w	r0, r0, #805306368	; 0x30000000
 80007da:	d1ed      	bne.n	80007b8 <HAL_ADC_Start+0x98>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80007dc:	688b      	ldr	r3, [r1, #8]
 80007de:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80007e2:	608b      	str	r3, [r1, #8]
 80007e4:	e7e9      	b.n	80007ba <HAL_ADC_Start+0x9a>
      ADC_CLEAR_ERRORCODE(hadc);
 80007e6:	6443      	str	r3, [r0, #68]	; 0x44
 80007e8:	e7d8      	b.n	800079c <HAL_ADC_Start+0x7c>
        hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 80007ea:	6893      	ldr	r3, [r2, #8]
 80007ec:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80007f0:	6093      	str	r3, [r2, #8]
}
 80007f2:	b003      	add	sp, #12
 80007f4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80007f8:	4770      	bx	lr
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
 80007fa:	6893      	ldr	r3, [r2, #8]
 80007fc:	f013 5f40 	tst.w	r3, #805306368	; 0x30000000
 8000800:	d103      	bne.n	800080a <HAL_ADC_Start+0xea>
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8000802:	6893      	ldr	r3, [r2, #8]
 8000804:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8000808:	6093      	str	r3, [r2, #8]
      if( HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI_4) )
 800080a:	4b07      	ldr	r3, [pc, #28]	; (8000828 <HAL_ADC_Start+0x108>)
  return HAL_OK;
 800080c:	2000      	movs	r0, #0
      if( HAL_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI_4) )
 800080e:	685b      	ldr	r3, [r3, #4]
 8000810:	e7d3      	b.n	80007ba <HAL_ADC_Start+0x9a>
  __HAL_LOCK(hadc);
 8000812:	2002      	movs	r0, #2
}
 8000814:	b003      	add	sp, #12
 8000816:	f85d 4b04 	ldr.w	r4, [sp], #4
 800081a:	4770      	bx	lr
 800081c:	20000184 	.word	0x20000184
 8000820:	431bde83 	.word	0x431bde83
 8000824:	fffff8fe 	.word	0xfffff8fe
 8000828:	40012300 	.word	0x40012300
 800082c:	40012000 	.word	0x40012000
 8000830:	40012200 	.word	0x40012200

08000834 <HAL_ADC_PollForConversion>:
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
 8000834:	6803      	ldr	r3, [r0, #0]
 8000836:	689a      	ldr	r2, [r3, #8]
{
 8000838:	b570      	push	{r4, r5, r6, lr}
 800083a:	4604      	mov	r4, r0
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
 800083c:	0550      	lsls	r0, r2, #21
 800083e:	d502      	bpl.n	8000846 <HAL_ADC_PollForConversion+0x12>
      HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
 8000840:	689b      	ldr	r3, [r3, #8]
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
 8000842:	05da      	lsls	r2, r3, #23
 8000844:	d43e      	bmi.n	80008c4 <HAL_ADC_PollForConversion+0x90>
 8000846:	460d      	mov	r5, r1
  tickstart = HAL_GetTick();
 8000848:	f7ff fe9c 	bl	8000584 <HAL_GetTick>
 800084c:	4606      	mov	r6, r0
 800084e:	1c6b      	adds	r3, r5, #1
  while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
 8000850:	6822      	ldr	r2, [r4, #0]
 8000852:	d125      	bne.n	80008a0 <HAL_ADC_PollForConversion+0x6c>
 8000854:	6813      	ldr	r3, [r2, #0]
 8000856:	0798      	lsls	r0, r3, #30
 8000858:	d5fc      	bpl.n	8000854 <HAL_ADC_PollForConversion+0x20>
  __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
 800085a:	f06f 0312 	mvn.w	r3, #18
 800085e:	6013      	str	r3, [r2, #0]
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8000860:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000862:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000866:	6423      	str	r3, [r4, #64]	; 0x40
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
 8000868:	6893      	ldr	r3, [r2, #8]
 800086a:	f013 5f40 	tst.w	r3, #805306368	; 0x30000000
 800086e:	d115      	bne.n	800089c <HAL_ADC_PollForConversion+0x68>
 8000870:	69a3      	ldr	r3, [r4, #24]
 8000872:	b99b      	cbnz	r3, 800089c <HAL_ADC_PollForConversion+0x68>
     (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) ||
 8000874:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
     (hadc->Init.ContinuousConvMode == DISABLE)            &&
 8000876:	f413 0f70 	tst.w	r3, #15728640	; 0xf00000
 800087a:	d002      	beq.n	8000882 <HAL_ADC_PollForConversion+0x4e>
      HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
 800087c:	6893      	ldr	r3, [r2, #8]
     (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) ||
 800087e:	055b      	lsls	r3, r3, #21
 8000880:	d40c      	bmi.n	800089c <HAL_ADC_PollForConversion+0x68>
    CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 8000882:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000884:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000888:	6423      	str	r3, [r4, #64]	; 0x40
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 800088a:	6c20      	ldr	r0, [r4, #64]	; 0x40
 800088c:	f410 5080 	ands.w	r0, r0, #4096	; 0x1000
 8000890:	d104      	bne.n	800089c <HAL_ADC_PollForConversion+0x68>
      SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8000892:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000894:	f043 0301 	orr.w	r3, r3, #1
 8000898:	6423      	str	r3, [r4, #64]	; 0x40
}
 800089a:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 800089c:	2000      	movs	r0, #0
}
 800089e:	bd70      	pop	{r4, r5, r6, pc}
  while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
 80008a0:	6813      	ldr	r3, [r2, #0]
 80008a2:	0799      	lsls	r1, r3, #30
 80008a4:	d4d9      	bmi.n	800085a <HAL_ADC_PollForConversion+0x26>
      if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
 80008a6:	b125      	cbz	r5, 80008b2 <HAL_ADC_PollForConversion+0x7e>
 80008a8:	f7ff fe6c 	bl	8000584 <HAL_GetTick>
 80008ac:	1b80      	subs	r0, r0, r6
 80008ae:	42a8      	cmp	r0, r5
 80008b0:	d9cd      	bls.n	800084e <HAL_ADC_PollForConversion+0x1a>
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80008b2:	6c23      	ldr	r3, [r4, #64]	; 0x40
        __HAL_UNLOCK(hadc);
 80008b4:	2200      	movs	r2, #0
        return HAL_TIMEOUT;
 80008b6:	2003      	movs	r0, #3
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80008b8:	f043 0304 	orr.w	r3, r3, #4
        __HAL_UNLOCK(hadc);
 80008bc:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80008c0:	6423      	str	r3, [r4, #64]	; 0x40
}
 80008c2:	bd70      	pop	{r4, r5, r6, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80008c4:	6c23      	ldr	r3, [r4, #64]	; 0x40
    __HAL_UNLOCK(hadc);
 80008c6:	2200      	movs	r2, #0
    return HAL_ERROR;
 80008c8:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80008ca:	f043 0320 	orr.w	r3, r3, #32
    __HAL_UNLOCK(hadc);
 80008ce:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80008d2:	6423      	str	r3, [r4, #64]	; 0x40
}
 80008d4:	bd70      	pop	{r4, r5, r6, pc}
 80008d6:	bf00      	nop

080008d8 <HAL_ADC_GetValue>:
  return hadc->Instance->DR;
 80008d8:	6803      	ldr	r3, [r0, #0]
 80008da:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
}
 80008dc:	4770      	bx	lr
 80008de:	bf00      	nop

080008e0 <HAL_ADC_ConfigChannel>:
  __HAL_LOCK(hadc);
 80008e0:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
  __IO uint32_t counter = 0;
 80008e4:	2200      	movs	r2, #0
{
 80008e6:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hadc);
 80008e8:	2b01      	cmp	r3, #1
{
 80008ea:	b083      	sub	sp, #12
  __IO uint32_t counter = 0;
 80008ec:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 80008ee:	f000 809a 	beq.w	8000a26 <HAL_ADC_ConfigChannel+0x146>
	if (sConfig->Channel > ADC_CHANNEL_9)
 80008f2:	680d      	ldr	r5, [r1, #0]
  __HAL_LOCK(hadc);
 80008f4:	2201      	movs	r2, #1
 80008f6:	6803      	ldr	r3, [r0, #0]
	if (sConfig->Channel > ADC_CHANNEL_9)
 80008f8:	2d09      	cmp	r5, #9
  __HAL_LOCK(hadc);
 80008fa:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
 80008fe:	b2af      	uxth	r7, r5
 8000900:	688a      	ldr	r2, [r1, #8]
	if (sConfig->Channel > ADC_CHANNEL_9)
 8000902:	d828      	bhi.n	8000956 <HAL_ADC_ConfigChannel+0x76>
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8000904:	eb05 0645 	add.w	r6, r5, r5, lsl #1
 8000908:	f04f 0c07 	mov.w	ip, #7
 800090c:	691c      	ldr	r4, [r3, #16]
 800090e:	fa0c fc06 	lsl.w	ip, ip, r6
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 8000912:	fa02 f606 	lsl.w	r6, r2, r6
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 8000916:	ea24 040c 	bic.w	r4, r4, ip
 800091a:	611c      	str	r4, [r3, #16]
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 800091c:	691a      	ldr	r2, [r3, #16]
 800091e:	4316      	orrs	r6, r2
 8000920:	611e      	str	r6, [r3, #16]
  if (sConfig->Rank < 7)
 8000922:	684e      	ldr	r6, [r1, #4]
 8000924:	2e06      	cmp	r6, #6
 8000926:	eb06 0286 	add.w	r2, r6, r6, lsl #2
 800092a:	d82d      	bhi.n	8000988 <HAL_ADC_ConfigChannel+0xa8>
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 800092c:	3a05      	subs	r2, #5
 800092e:	241f      	movs	r4, #31
 8000930:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8000932:	4094      	lsls	r4, r2
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8000934:	fa07 f202 	lsl.w	r2, r7, r2
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 8000938:	ea21 0104 	bic.w	r1, r1, r4
 800093c:	6359      	str	r1, [r3, #52]	; 0x34
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 800093e:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8000940:	430a      	orrs	r2, r1
 8000942:	635a      	str	r2, [r3, #52]	; 0x34
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 8000944:	4a3c      	ldr	r2, [pc, #240]	; (8000a38 <HAL_ADC_ConfigChannel+0x158>)
 8000946:	4293      	cmp	r3, r2
 8000948:	d030      	beq.n	80009ac <HAL_ADC_ConfigChannel+0xcc>
  __HAL_UNLOCK(hadc);
 800094a:	2300      	movs	r3, #0
 800094c:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  return HAL_OK;
 8000950:	4618      	mov	r0, r3
}
 8000952:	b003      	add	sp, #12
 8000954:	bdf0      	pop	{r4, r5, r6, r7, pc}
		hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8000956:	eb07 0647 	add.w	r6, r7, r7, lsl #1
 800095a:	f04f 0c07 	mov.w	ip, #7
 800095e:	68dc      	ldr	r4, [r3, #12]
 8000960:	3e1e      	subs	r6, #30
		if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8000962:	f8df e0d8 	ldr.w	lr, [pc, #216]	; 8000a3c <HAL_ADC_ConfigChannel+0x15c>
		hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8000966:	fa0c fc06 	lsl.w	ip, ip, r6
		if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 800096a:	4575      	cmp	r5, lr
		hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 800096c:	ea24 040c 	bic.w	r4, r4, ip
 8000970:	60dc      	str	r4, [r3, #12]
		if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8000972:	d05b      	beq.n	8000a2c <HAL_ADC_ConfigChannel+0x14c>
		  hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 8000974:	fa02 f606 	lsl.w	r6, r2, r6
 8000978:	68da      	ldr	r2, [r3, #12]
 800097a:	4316      	orrs	r6, r2
 800097c:	60de      	str	r6, [r3, #12]
  if (sConfig->Rank < 7)
 800097e:	684e      	ldr	r6, [r1, #4]
 8000980:	2e06      	cmp	r6, #6
 8000982:	eb06 0286 	add.w	r2, r6, r6, lsl #2
 8000986:	d9d1      	bls.n	800092c <HAL_ADC_ConfigChannel+0x4c>
  else if (sConfig->Rank < 13)
 8000988:	2e0c      	cmp	r6, #12
 800098a:	d837      	bhi.n	80009fc <HAL_ADC_ConfigChannel+0x11c>
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 800098c:	f1a2 0423 	sub.w	r4, r2, #35	; 0x23
 8000990:	261f      	movs	r6, #31
 8000992:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8000994:	40a6      	lsls	r6, r4
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8000996:	fa07 f204 	lsl.w	r2, r7, r4
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 800099a:	ea21 0106 	bic.w	r1, r1, r6
 800099e:	6319      	str	r1, [r3, #48]	; 0x30
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 80009a0:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 80009a2:	4314      	orrs	r4, r2
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 80009a4:	4a24      	ldr	r2, [pc, #144]	; (8000a38 <HAL_ADC_ConfigChannel+0x158>)
 80009a6:	4293      	cmp	r3, r2
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 80009a8:	631c      	str	r4, [r3, #48]	; 0x30
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 80009aa:	d1ce      	bne.n	800094a <HAL_ADC_ConfigChannel+0x6a>
 80009ac:	2d12      	cmp	r5, #18
 80009ae:	d033      	beq.n	8000a18 <HAL_ADC_ConfigChannel+0x138>
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 80009b0:	4b22      	ldr	r3, [pc, #136]	; (8000a3c <HAL_ADC_ConfigChannel+0x15c>)
 80009b2:	429d      	cmp	r5, r3
 80009b4:	d001      	beq.n	80009ba <HAL_ADC_ConfigChannel+0xda>
 80009b6:	2d11      	cmp	r5, #17
 80009b8:	d1c7      	bne.n	800094a <HAL_ADC_ConfigChannel+0x6a>
    ADC->CCR |= ADC_CCR_TSVREFE;
 80009ba:	4a21      	ldr	r2, [pc, #132]	; (8000a40 <HAL_ADC_ConfigChannel+0x160>)
    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80009bc:	491f      	ldr	r1, [pc, #124]	; (8000a3c <HAL_ADC_ConfigChannel+0x15c>)
    ADC->CCR |= ADC_CCR_TSVREFE;
 80009be:	6853      	ldr	r3, [r2, #4]
    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80009c0:	428d      	cmp	r5, r1
    ADC->CCR |= ADC_CCR_TSVREFE;
 80009c2:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80009c6:	6053      	str	r3, [r2, #4]
    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80009c8:	d1bf      	bne.n	800094a <HAL_ADC_ConfigChannel+0x6a>
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 80009ca:	f102 7246 	add.w	r2, r2, #51904512	; 0x3180000
 80009ce:	4b1d      	ldr	r3, [pc, #116]	; (8000a44 <HAL_ADC_ConfigChannel+0x164>)
 80009d0:	f502 322e 	add.w	r2, r2, #178176	; 0x2b800
 80009d4:	681b      	ldr	r3, [r3, #0]
 80009d6:	f202 3283 	addw	r2, r2, #899	; 0x383
 80009da:	fba2 2303 	umull	r2, r3, r2, r3
 80009de:	0c9b      	lsrs	r3, r3, #18
 80009e0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80009e4:	005b      	lsls	r3, r3, #1
 80009e6:	9301      	str	r3, [sp, #4]
      while(counter != 0)
 80009e8:	9b01      	ldr	r3, [sp, #4]
 80009ea:	2b00      	cmp	r3, #0
 80009ec:	d0ad      	beq.n	800094a <HAL_ADC_ConfigChannel+0x6a>
        counter--;
 80009ee:	9b01      	ldr	r3, [sp, #4]
 80009f0:	3b01      	subs	r3, #1
 80009f2:	9301      	str	r3, [sp, #4]
      while(counter != 0)
 80009f4:	9b01      	ldr	r3, [sp, #4]
 80009f6:	2b00      	cmp	r3, #0
 80009f8:	d1f9      	bne.n	80009ee <HAL_ADC_ConfigChannel+0x10e>
 80009fa:	e7a6      	b.n	800094a <HAL_ADC_ConfigChannel+0x6a>
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 80009fc:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
 8000a00:	261f      	movs	r6, #31
 8000a02:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 8000a04:	408e      	lsls	r6, r1
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8000a06:	fa07 f201 	lsl.w	r2, r7, r1
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 8000a0a:	ea24 0406 	bic.w	r4, r4, r6
 8000a0e:	62dc      	str	r4, [r3, #44]	; 0x2c
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 8000a10:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8000a12:	430a      	orrs	r2, r1
 8000a14:	62da      	str	r2, [r3, #44]	; 0x2c
 8000a16:	e795      	b.n	8000944 <HAL_ADC_ConfigChannel+0x64>
    ADC->CCR |= ADC_CCR_VBATE;
 8000a18:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
 8000a1c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8000a20:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
 8000a24:	e791      	b.n	800094a <HAL_ADC_ConfigChannel+0x6a>
  __HAL_LOCK(hadc);
 8000a26:	2002      	movs	r0, #2
}
 8000a28:	b003      	add	sp, #12
 8000a2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, ADC_CHANNEL_18);
 8000a2c:	68de      	ldr	r6, [r3, #12]
 8000a2e:	ea46 6602 	orr.w	r6, r6, r2, lsl #24
 8000a32:	60de      	str	r6, [r3, #12]
 8000a34:	e775      	b.n	8000922 <HAL_ADC_ConfigChannel+0x42>
 8000a36:	bf00      	nop
 8000a38:	40012000 	.word	0x40012000
 8000a3c:	10000012 	.word	0x10000012
 8000a40:	40012300 	.word	0x40012300
 8000a44:	20000184 	.word	0x20000184

08000a48 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000a48:	4907      	ldr	r1, [pc, #28]	; (8000a68 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000a4a:	0200      	lsls	r0, r0, #8
 8000a4c:	4b07      	ldr	r3, [pc, #28]	; (8000a6c <HAL_NVIC_SetPriorityGrouping+0x24>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000a4e:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000a50:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000a54:	b410      	push	{r4}
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000a56:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
 8000a5a:	4022      	ands	r2, r4
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8000a5c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000a60:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8000a62:	4318      	orrs	r0, r3
  SCB->AIRCR =  reg_value;
 8000a64:	60c8      	str	r0, [r1, #12]
 8000a66:	4770      	bx	lr
 8000a68:	e000ed00 	.word	0xe000ed00
 8000a6c:	05fa0000 	.word	0x05fa0000

08000a70 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000a70:	4b17      	ldr	r3, [pc, #92]	; (8000ad0 <HAL_NVIC_SetPriority+0x60>)
 8000a72:	68db      	ldr	r3, [r3, #12]
 8000a74:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000a78:	b430      	push	{r4, r5}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000a7a:	f1c3 0507 	rsb	r5, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000a7e:	1d1c      	adds	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000a80:	2d04      	cmp	r5, #4
 8000a82:	bf28      	it	cs
 8000a84:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000a86:	2c06      	cmp	r4, #6
 8000a88:	d918      	bls.n	8000abc <HAL_NVIC_SetPriority+0x4c>
 8000a8a:	3b03      	subs	r3, #3
 8000a8c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8000a90:	409c      	lsls	r4, r3
 8000a92:	ea22 0404 	bic.w	r4, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000a96:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  if ((int32_t)(IRQn) >= 0)
 8000a9a:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000a9c:	fa02 f205 	lsl.w	r2, r2, r5
 8000aa0:	ea21 0102 	bic.w	r1, r1, r2
 8000aa4:	fa01 f203 	lsl.w	r2, r1, r3
 8000aa8:	ea42 0204 	orr.w	r2, r2, r4
 8000aac:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8000ab0:	b2d2      	uxtb	r2, r2
  if ((int32_t)(IRQn) >= 0)
 8000ab2:	db06      	blt.n	8000ac2 <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ab4:	4b07      	ldr	r3, [pc, #28]	; (8000ad4 <HAL_NVIC_SetPriority+0x64>)
 8000ab6:	541a      	strb	r2, [r3, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000ab8:	bc30      	pop	{r4, r5}
 8000aba:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000abc:	2400      	movs	r4, #0
 8000abe:	4623      	mov	r3, r4
 8000ac0:	e7e9      	b.n	8000a96 <HAL_NVIC_SetPriority+0x26>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000ac2:	f000 000f 	and.w	r0, r0, #15
 8000ac6:	4b04      	ldr	r3, [pc, #16]	; (8000ad8 <HAL_NVIC_SetPriority+0x68>)
 8000ac8:	541a      	strb	r2, [r3, r0]
 8000aca:	bc30      	pop	{r4, r5}
 8000acc:	4770      	bx	lr
 8000ace:	bf00      	nop
 8000ad0:	e000ed00 	.word	0xe000ed00
 8000ad4:	e000e400 	.word	0xe000e400
 8000ad8:	e000ed14 	.word	0xe000ed14

08000adc <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000adc:	2800      	cmp	r0, #0
 8000ade:	db07      	blt.n	8000af0 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000ae0:	f000 011f 	and.w	r1, r0, #31
 8000ae4:	2301      	movs	r3, #1
 8000ae6:	0940      	lsrs	r0, r0, #5
 8000ae8:	4a02      	ldr	r2, [pc, #8]	; (8000af4 <HAL_NVIC_EnableIRQ+0x18>)
 8000aea:	408b      	lsls	r3, r1
 8000aec:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000af0:	4770      	bx	lr
 8000af2:	bf00      	nop
 8000af4:	e000e100 	.word	0xe000e100

08000af8 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000af8:	3801      	subs	r0, #1
 8000afa:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000afe:	d20d      	bcs.n	8000b1c <HAL_SYSTICK_Config+0x24>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000b00:	4b07      	ldr	r3, [pc, #28]	; (8000b20 <HAL_SYSTICK_Config+0x28>)
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000b02:	2200      	movs	r2, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000b04:	2107      	movs	r1, #7
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8000b06:	b430      	push	{r4, r5}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000b08:	25f0      	movs	r5, #240	; 0xf0
 8000b0a:	4c06      	ldr	r4, [pc, #24]	; (8000b24 <HAL_SYSTICK_Config+0x2c>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000b0c:	6058      	str	r0, [r3, #4]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000b0e:	4610      	mov	r0, r2
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000b10:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000b14:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000b16:	6019      	str	r1, [r3, #0]
   return SysTick_Config(TicksNumb);
}
 8000b18:	bc30      	pop	{r4, r5}
 8000b1a:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000b1c:	2001      	movs	r0, #1
 8000b1e:	4770      	bx	lr
 8000b20:	e000e010 	.word	0xe000e010
 8000b24:	e000ed00 	.word	0xe000ed00

08000b28 <HAL_DMA_Abort_IT>:
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8000b28:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
{
 8000b2c:	4603      	mov	r3, r0
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8000b2e:	2a02      	cmp	r2, #2
 8000b30:	d003      	beq.n	8000b3a <HAL_DMA_Abort_IT+0x12>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000b32:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
 8000b34:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8000b36:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 8000b38:	4770      	bx	lr
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8000b3a:	6802      	ldr	r2, [r0, #0]
    hdma->State = HAL_DMA_STATE_ABORT;
 8000b3c:	2105      	movs	r1, #5
  }

  return HAL_OK;
 8000b3e:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_ABORT;
 8000b40:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8000b44:	6813      	ldr	r3, [r2, #0]
 8000b46:	f023 0301 	bic.w	r3, r3, #1
 8000b4a:	6013      	str	r3, [r2, #0]
}
 8000b4c:	4770      	bx	lr
 8000b4e:	bf00      	nop

08000b50 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000b50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000b54:	f8df c22c 	ldr.w	ip, [pc, #556]	; 8000d84 <HAL_GPIO_Init+0x234>
{
 8000b58:	b083      	sub	sp, #12
 8000b5a:	468e      	mov	lr, r1
  for(position = 0; position < GPIO_NUMBER; position++)
 8000b5c:	2500      	movs	r5, #0
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000b5e:	f8df 9228 	ldr.w	r9, [pc, #552]	; 8000d88 <HAL_GPIO_Init+0x238>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000b62:	f8d1 8000 	ldr.w	r8, [r1]
 8000b66:	e003      	b.n	8000b70 <HAL_GPIO_Init+0x20>
  for(position = 0; position < GPIO_NUMBER; position++)
 8000b68:	3501      	adds	r5, #1
 8000b6a:	2d10      	cmp	r5, #16
 8000b6c:	f000 80b6 	beq.w	8000cdc <HAL_GPIO_Init+0x18c>
    ioposition = ((uint32_t)0x01) << position;
 8000b70:	2301      	movs	r3, #1
 8000b72:	40ab      	lsls	r3, r5
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000b74:	ea08 0103 	and.w	r1, r8, r3
    if(iocurrent == ioposition)
 8000b78:	428b      	cmp	r3, r1
 8000b7a:	d1f5      	bne.n	8000b68 <HAL_GPIO_Init+0x18>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000b7c:	f8de 4004 	ldr.w	r4, [lr, #4]
 8000b80:	f024 0710 	bic.w	r7, r4, #16
 8000b84:	2f02      	cmp	r7, #2
 8000b86:	f040 80ac 	bne.w	8000ce2 <HAL_GPIO_Init+0x192>
        temp = GPIOx->AFR[position >> 3];
 8000b8a:	08ef      	lsrs	r7, r5, #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000b8c:	f005 0a07 	and.w	sl, r5, #7
 8000b90:	f04f 0b0f 	mov.w	fp, #15
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000b94:	f8de 2010 	ldr.w	r2, [lr, #16]
 8000b98:	eb00 0787 	add.w	r7, r0, r7, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000b9c:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
        temp = GPIOx->AFR[position >> 3];
 8000ba0:	6a3e      	ldr	r6, [r7, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000ba2:	fa0b fb0a 	lsl.w	fp, fp, sl
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000ba6:	fa02 f20a 	lsl.w	r2, r2, sl
 8000baa:	ea4f 0a45 	mov.w	sl, r5, lsl #1
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000bae:	ea26 060b 	bic.w	r6, r6, fp
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bb2:	f04f 0b03 	mov.w	fp, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000bb6:	4332      	orrs	r2, r6
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bb8:	fa0b fb0a 	lsl.w	fp, fp, sl
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000bbc:	f004 0603 	and.w	r6, r4, #3
        GPIOx->AFR[position >> 3] = temp;
 8000bc0:	623a      	str	r2, [r7, #32]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bc2:	ea6f 020b 	mvn.w	r2, fp
      temp = GPIOx->MODER;
 8000bc6:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000bc8:	fa06 f60a 	lsl.w	r6, r6, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000bcc:	4017      	ands	r7, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000bce:	433e      	orrs	r6, r7
      GPIOx->MODER = temp;
 8000bd0:	6006      	str	r6, [r0, #0]
        temp = GPIOx->OSPEEDR; 
 8000bd2:	6886      	ldr	r6, [r0, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000bd4:	f3c4 1700 	ubfx	r7, r4, #4, #1
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000bd8:	ea06 0b02 	and.w	fp, r6, r2
        temp |= (GPIO_Init->Speed << (position * 2));
 8000bdc:	f8de 600c 	ldr.w	r6, [lr, #12]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000be0:	40af      	lsls	r7, r5
        temp |= (GPIO_Init->Speed << (position * 2));
 8000be2:	fa06 f60a 	lsl.w	r6, r6, sl
 8000be6:	ea46 060b 	orr.w	r6, r6, fp
        GPIOx->OSPEEDR = temp;
 8000bea:	6086      	str	r6, [r0, #8]
        temp = GPIOx->OTYPER;
 8000bec:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000bee:	ea26 0303 	bic.w	r3, r6, r3
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000bf2:	431f      	orrs	r7, r3
        GPIOx->OTYPER = temp;
 8000bf4:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8000bf6:	68c6      	ldr	r6, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000bf8:	00e7      	lsls	r7, r4, #3
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000bfa:	f8de 3008 	ldr.w	r3, [lr, #8]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8000bfe:	ea02 0206 	and.w	r2, r2, r6
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000c02:	fa03 f30a 	lsl.w	r3, r3, sl
 8000c06:	ea43 0302 	orr.w	r3, r3, r2
      GPIOx->PUPDR = temp;
 8000c0a:	60c3      	str	r3, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000c0c:	d5ac      	bpl.n	8000b68 <HAL_GPIO_Init+0x18>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c0e:	f8d9 6044 	ldr.w	r6, [r9, #68]	; 0x44
 8000c12:	f025 0703 	bic.w	r7, r5, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c16:	f005 0303 	and.w	r3, r5, #3
 8000c1a:	220f      	movs	r2, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c1c:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
 8000c20:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c24:	009b      	lsls	r3, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c26:	f8c9 6044 	str.w	r6, [r9, #68]	; 0x44
 8000c2a:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
 8000c2e:	f8d9 6044 	ldr.w	r6, [r9, #68]	; 0x44
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c32:	fa02 fa03 	lsl.w	sl, r2, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c36:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8000c3a:	9601      	str	r6, [sp, #4]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000c3c:	4e48      	ldr	r6, [pc, #288]	; (8000d60 <HAL_GPIO_Init+0x210>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c3e:	9a01      	ldr	r2, [sp, #4]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000c40:	42b0      	cmp	r0, r6
        temp = SYSCFG->EXTICR[position >> 2];
 8000c42:	68ba      	ldr	r2, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c44:	ea22 020a 	bic.w	r2, r2, sl
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000c48:	d020      	beq.n	8000c8c <HAL_GPIO_Init+0x13c>
 8000c4a:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8000c4e:	42b0      	cmp	r0, r6
 8000c50:	d05e      	beq.n	8000d10 <HAL_GPIO_Init+0x1c0>
 8000c52:	4e44      	ldr	r6, [pc, #272]	; (8000d64 <HAL_GPIO_Init+0x214>)
 8000c54:	42b0      	cmp	r0, r6
 8000c56:	d060      	beq.n	8000d1a <HAL_GPIO_Init+0x1ca>
 8000c58:	4e43      	ldr	r6, [pc, #268]	; (8000d68 <HAL_GPIO_Init+0x218>)
 8000c5a:	42b0      	cmp	r0, r6
 8000c5c:	d062      	beq.n	8000d24 <HAL_GPIO_Init+0x1d4>
 8000c5e:	4e43      	ldr	r6, [pc, #268]	; (8000d6c <HAL_GPIO_Init+0x21c>)
 8000c60:	42b0      	cmp	r0, r6
 8000c62:	d064      	beq.n	8000d2e <HAL_GPIO_Init+0x1de>
 8000c64:	4e42      	ldr	r6, [pc, #264]	; (8000d70 <HAL_GPIO_Init+0x220>)
 8000c66:	42b0      	cmp	r0, r6
 8000c68:	d06b      	beq.n	8000d42 <HAL_GPIO_Init+0x1f2>
 8000c6a:	4e42      	ldr	r6, [pc, #264]	; (8000d74 <HAL_GPIO_Init+0x224>)
 8000c6c:	42b0      	cmp	r0, r6
 8000c6e:	d06d      	beq.n	8000d4c <HAL_GPIO_Init+0x1fc>
 8000c70:	4e41      	ldr	r6, [pc, #260]	; (8000d78 <HAL_GPIO_Init+0x228>)
 8000c72:	42b0      	cmp	r0, r6
 8000c74:	d060      	beq.n	8000d38 <HAL_GPIO_Init+0x1e8>
 8000c76:	4e41      	ldr	r6, [pc, #260]	; (8000d7c <HAL_GPIO_Init+0x22c>)
 8000c78:	42b0      	cmp	r0, r6
 8000c7a:	d06c      	beq.n	8000d56 <HAL_GPIO_Init+0x206>
 8000c7c:	4e40      	ldr	r6, [pc, #256]	; (8000d80 <HAL_GPIO_Init+0x230>)
 8000c7e:	42b0      	cmp	r0, r6
 8000c80:	bf0c      	ite	eq
 8000c82:	2609      	moveq	r6, #9
 8000c84:	260a      	movne	r6, #10
 8000c86:	fa06 f303 	lsl.w	r3, r6, r3
 8000c8a:	431a      	orrs	r2, r3
        SYSCFG->EXTICR[position >> 2] = temp;
 8000c8c:	60ba      	str	r2, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000c8e:	03e6      	lsls	r6, r4, #15
        temp = EXTI->IMR;
 8000c90:	f8dc 3000 	ldr.w	r3, [ip]
        temp &= ~((uint32_t)iocurrent);
 8000c94:	ea6f 0201 	mvn.w	r2, r1
  for(position = 0; position < GPIO_NUMBER; position++)
 8000c98:	f105 0501 	add.w	r5, r5, #1
        temp &= ~((uint32_t)iocurrent);
 8000c9c:	bf54      	ite	pl
 8000c9e:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8000ca0:	430b      	orrmi	r3, r1
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000ca2:	03a7      	lsls	r7, r4, #14
        EXTI->IMR = temp;
 8000ca4:	f8cc 3000 	str.w	r3, [ip]
        temp = EXTI->EMR;
 8000ca8:	f8dc 3004 	ldr.w	r3, [ip, #4]
        temp &= ~((uint32_t)iocurrent);
 8000cac:	bf54      	ite	pl
 8000cae:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8000cb0:	430b      	orrmi	r3, r1
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000cb2:	02e6      	lsls	r6, r4, #11
        EXTI->EMR = temp;
 8000cb4:	f8cc 3004 	str.w	r3, [ip, #4]
        temp = EXTI->RTSR;
 8000cb8:	f8dc 3008 	ldr.w	r3, [ip, #8]
        temp &= ~((uint32_t)iocurrent);
 8000cbc:	bf54      	ite	pl
 8000cbe:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8000cc0:	430b      	orrmi	r3, r1
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000cc2:	02a4      	lsls	r4, r4, #10
        EXTI->RTSR = temp;
 8000cc4:	f8cc 3008 	str.w	r3, [ip, #8]
        temp = EXTI->FTSR;
 8000cc8:	f8dc 300c 	ldr.w	r3, [ip, #12]
        temp &= ~((uint32_t)iocurrent);
 8000ccc:	bf54      	ite	pl
 8000cce:	4013      	andpl	r3, r2
        {
          temp |= iocurrent;
 8000cd0:	430b      	orrmi	r3, r1
  for(position = 0; position < GPIO_NUMBER; position++)
 8000cd2:	2d10      	cmp	r5, #16
        }
        EXTI->FTSR = temp;
 8000cd4:	f8cc 300c 	str.w	r3, [ip, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 8000cd8:	f47f af4a 	bne.w	8000b70 <HAL_GPIO_Init+0x20>
      }
    }
  }
}
 8000cdc:	b003      	add	sp, #12
 8000cde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000ce2:	ea4f 0a45 	mov.w	sl, r5, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000ce6:	2203      	movs	r2, #3
      temp = GPIOx->MODER;
 8000ce8:	f8d0 b000 	ldr.w	fp, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000cec:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000cee:	ea04 0602 	and.w	r6, r4, r2
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000cf2:	fa02 f20a 	lsl.w	r2, r2, sl
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000cf6:	2f01      	cmp	r7, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000cf8:	ea6f 0202 	mvn.w	r2, r2
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000cfc:	fa06 f60a 	lsl.w	r6, r6, sl
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000d00:	ea02 0b0b 	and.w	fp, r2, fp
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000d04:	ea46 060b 	orr.w	r6, r6, fp
      GPIOx->MODER = temp;
 8000d08:	6006      	str	r6, [r0, #0]
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000d0a:	f63f af74 	bhi.w	8000bf6 <HAL_GPIO_Init+0xa6>
 8000d0e:	e760      	b.n	8000bd2 <HAL_GPIO_Init+0x82>
 8000d10:	2601      	movs	r6, #1
 8000d12:	fa06 f303 	lsl.w	r3, r6, r3
 8000d16:	431a      	orrs	r2, r3
 8000d18:	e7b8      	b.n	8000c8c <HAL_GPIO_Init+0x13c>
 8000d1a:	2602      	movs	r6, #2
 8000d1c:	fa06 f303 	lsl.w	r3, r6, r3
 8000d20:	431a      	orrs	r2, r3
 8000d22:	e7b3      	b.n	8000c8c <HAL_GPIO_Init+0x13c>
 8000d24:	2603      	movs	r6, #3
 8000d26:	fa06 f303 	lsl.w	r3, r6, r3
 8000d2a:	431a      	orrs	r2, r3
 8000d2c:	e7ae      	b.n	8000c8c <HAL_GPIO_Init+0x13c>
 8000d2e:	2604      	movs	r6, #4
 8000d30:	fa06 f303 	lsl.w	r3, r6, r3
 8000d34:	431a      	orrs	r2, r3
 8000d36:	e7a9      	b.n	8000c8c <HAL_GPIO_Init+0x13c>
 8000d38:	2607      	movs	r6, #7
 8000d3a:	fa06 f303 	lsl.w	r3, r6, r3
 8000d3e:	431a      	orrs	r2, r3
 8000d40:	e7a4      	b.n	8000c8c <HAL_GPIO_Init+0x13c>
 8000d42:	2605      	movs	r6, #5
 8000d44:	fa06 f303 	lsl.w	r3, r6, r3
 8000d48:	431a      	orrs	r2, r3
 8000d4a:	e79f      	b.n	8000c8c <HAL_GPIO_Init+0x13c>
 8000d4c:	2606      	movs	r6, #6
 8000d4e:	fa06 f303 	lsl.w	r3, r6, r3
 8000d52:	431a      	orrs	r2, r3
 8000d54:	e79a      	b.n	8000c8c <HAL_GPIO_Init+0x13c>
 8000d56:	2608      	movs	r6, #8
 8000d58:	fa06 f303 	lsl.w	r3, r6, r3
 8000d5c:	431a      	orrs	r2, r3
 8000d5e:	e795      	b.n	8000c8c <HAL_GPIO_Init+0x13c>
 8000d60:	40020000 	.word	0x40020000
 8000d64:	40020800 	.word	0x40020800
 8000d68:	40020c00 	.word	0x40020c00
 8000d6c:	40021000 	.word	0x40021000
 8000d70:	40021400 	.word	0x40021400
 8000d74:	40021800 	.word	0x40021800
 8000d78:	40021c00 	.word	0x40021c00
 8000d7c:	40022000 	.word	0x40022000
 8000d80:	40022400 	.word	0x40022400
 8000d84:	40013c00 	.word	0x40013c00
 8000d88:	40023800 	.word	0x40023800

08000d8c <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8000d8c:	6903      	ldr	r3, [r0, #16]
 8000d8e:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8000d90:	bf14      	ite	ne
 8000d92:	2001      	movne	r0, #1
 8000d94:	2000      	moveq	r0, #0
 8000d96:	4770      	bx	lr

08000d98 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000d98:	b902      	cbnz	r2, 8000d9c <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 8000d9a:	0409      	lsls	r1, r1, #16
 8000d9c:	6181      	str	r1, [r0, #24]
  }
}
 8000d9e:	4770      	bx	lr

08000da0 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8000da0:	b570      	push	{r4, r5, r6, lr}
 8000da2:	4604      	mov	r4, r0
 8000da4:	460d      	mov	r5, r1
 8000da6:	4616      	mov	r6, r2
 8000da8:	1c6a      	adds	r2, r5, #1
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8000daa:	6823      	ldr	r3, [r4, #0]
 8000dac:	d12c      	bne.n	8000e08 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
 8000dae:	699a      	ldr	r2, [r3, #24]
 8000db0:	0790      	lsls	r0, r2, #30
 8000db2:	d427      	bmi.n	8000e04 <I2C_WaitOnTXISFlagUntilTimeout+0x64>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8000db4:	699a      	ldr	r2, [r3, #24]
 8000db6:	06d1      	lsls	r1, r2, #27
 8000db8:	d5f9      	bpl.n	8000dae <I2C_WaitOnTXISFlagUntilTimeout+0xe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8000dba:	699a      	ldr	r2, [r3, #24]
 8000dbc:	0691      	lsls	r1, r2, #26
 8000dbe:	d5fc      	bpl.n	8000dba <I2C_WaitOnTXISFlagUntilTimeout+0x1a>

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8000dc0:	2220      	movs	r2, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8000dc2:	2110      	movs	r1, #16
 8000dc4:	61d9      	str	r1, [r3, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8000dc6:	61da      	str	r2, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8000dc8:	699a      	ldr	r2, [r3, #24]
 8000dca:	0790      	lsls	r0, r2, #30
 8000dcc:	d501      	bpl.n	8000dd2 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
    hi2c->Instance->TXDR = 0x00U;
 8000dce:	2200      	movs	r2, #0
 8000dd0:	629a      	str	r2, [r3, #40]	; 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8000dd2:	699a      	ldr	r2, [r3, #24]
 8000dd4:	07d1      	lsls	r1, r2, #31
 8000dd6:	d403      	bmi.n	8000de0 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8000dd8:	699a      	ldr	r2, [r3, #24]
 8000dda:	f042 0201 	orr.w	r2, r2, #1
 8000dde:	619a      	str	r2, [r3, #24]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8000de0:	685a      	ldr	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8000de2:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
 8000de4:	4e1b      	ldr	r6, [pc, #108]	; (8000e54 <I2C_WaitOnTXISFlagUntilTimeout+0xb4>)
    hi2c->State = HAL_I2C_STATE_READY;
 8000de6:	2520      	movs	r5, #32
      return HAL_ERROR;
 8000de8:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 8000dea:	4032      	ands	r2, r6
 8000dec:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8000dee:	6c63      	ldr	r3, [r4, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8000df0:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8000df4:	f043 0304 	orr.w	r3, r3, #4
 8000df8:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8000dfa:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8000dfe:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
 8000e02:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 8000e04:	2000      	movs	r0, #0
}
 8000e06:	bd70      	pop	{r4, r5, r6, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8000e08:	699a      	ldr	r2, [r3, #24]
 8000e0a:	0792      	lsls	r2, r2, #30
 8000e0c:	d4fa      	bmi.n	8000e04 <I2C_WaitOnTXISFlagUntilTimeout+0x64>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8000e0e:	699a      	ldr	r2, [r3, #24]
 8000e10:	06d0      	lsls	r0, r2, #27
 8000e12:	d41b      	bmi.n	8000e4c <I2C_WaitOnTXISFlagUntilTimeout+0xac>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8000e14:	f7ff fbb6 	bl	8000584 <HAL_GetTick>
 8000e18:	1b80      	subs	r0, r0, r6
 8000e1a:	42a8      	cmp	r0, r5
 8000e1c:	d801      	bhi.n	8000e22 <I2C_WaitOnTXISFlagUntilTimeout+0x82>
 8000e1e:	2d00      	cmp	r5, #0
 8000e20:	d1c2      	bne.n	8000da8 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8000e22:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8000e24:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8000e26:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 8000e28:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8000e2a:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 8000e2c:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8000e30:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8000e32:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8000e36:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 8000e3a:	bd70      	pop	{r4, r5, r6, pc}
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8000e3c:	f7ff fba2 	bl	8000584 <HAL_GetTick>
 8000e40:	1b80      	subs	r0, r0, r6
 8000e42:	4285      	cmp	r5, r0
 8000e44:	d3ed      	bcc.n	8000e22 <I2C_WaitOnTXISFlagUntilTimeout+0x82>
 8000e46:	2d00      	cmp	r5, #0
 8000e48:	d0eb      	beq.n	8000e22 <I2C_WaitOnTXISFlagUntilTimeout+0x82>
 8000e4a:	6823      	ldr	r3, [r4, #0]
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8000e4c:	699a      	ldr	r2, [r3, #24]
 8000e4e:	0692      	lsls	r2, r2, #26
 8000e50:	d5f4      	bpl.n	8000e3c <I2C_WaitOnTXISFlagUntilTimeout+0x9c>
 8000e52:	e7b5      	b.n	8000dc0 <I2C_WaitOnTXISFlagUntilTimeout+0x20>
 8000e54:	fe00e800 	.word	0xfe00e800

08000e58 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8000e58:	b570      	push	{r4, r5, r6, lr}
 8000e5a:	4604      	mov	r4, r0
 8000e5c:	460d      	mov	r5, r1
 8000e5e:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8000e60:	6823      	ldr	r3, [r4, #0]
 8000e62:	699a      	ldr	r2, [r3, #24]
 8000e64:	0692      	lsls	r2, r2, #26
 8000e66:	d449      	bmi.n	8000efc <I2C_WaitOnSTOPFlagUntilTimeout+0xa4>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8000e68:	699a      	ldr	r2, [r3, #24]
 8000e6a:	06d2      	lsls	r2, r2, #27
 8000e6c:	d526      	bpl.n	8000ebc <I2C_WaitOnSTOPFlagUntilTimeout+0x64>
 8000e6e:	1c68      	adds	r0, r5, #1
 8000e70:	d138      	bne.n	8000ee4 <I2C_WaitOnSTOPFlagUntilTimeout+0x8c>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8000e72:	699a      	ldr	r2, [r3, #24]
 8000e74:	0691      	lsls	r1, r2, #26
 8000e76:	d5fc      	bpl.n	8000e72 <I2C_WaitOnSTOPFlagUntilTimeout+0x1a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8000e78:	2220      	movs	r2, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8000e7a:	2110      	movs	r1, #16
 8000e7c:	61d9      	str	r1, [r3, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8000e7e:	61da      	str	r2, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8000e80:	699a      	ldr	r2, [r3, #24]
 8000e82:	0790      	lsls	r0, r2, #30
 8000e84:	d501      	bpl.n	8000e8a <I2C_WaitOnSTOPFlagUntilTimeout+0x32>
    hi2c->Instance->TXDR = 0x00U;
 8000e86:	2200      	movs	r2, #0
 8000e88:	629a      	str	r2, [r3, #40]	; 0x28
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8000e8a:	699a      	ldr	r2, [r3, #24]
 8000e8c:	07d1      	lsls	r1, r2, #31
 8000e8e:	d403      	bmi.n	8000e98 <I2C_WaitOnSTOPFlagUntilTimeout+0x40>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8000e90:	699a      	ldr	r2, [r3, #24]
 8000e92:	f042 0201 	orr.w	r2, r2, #1
 8000e96:	619a      	str	r2, [r3, #24]
    I2C_RESET_CR2(hi2c);
 8000e98:	685a      	ldr	r2, [r3, #4]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8000e9a:	2100      	movs	r1, #0
    I2C_RESET_CR2(hi2c);
 8000e9c:	4e18      	ldr	r6, [pc, #96]	; (8000f00 <I2C_WaitOnSTOPFlagUntilTimeout+0xa8>)
    hi2c->State = HAL_I2C_STATE_READY;
 8000e9e:	2520      	movs	r5, #32
      return HAL_ERROR;
 8000ea0:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 8000ea2:	4032      	ands	r2, r6
 8000ea4:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8000ea6:	6c63      	ldr	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(hi2c);
 8000ea8:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8000eac:	f043 0304 	orr.w	r3, r3, #4
 8000eb0:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8000eb2:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8000eb6:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
 8000eba:	bd70      	pop	{r4, r5, r6, pc}
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8000ebc:	f7ff fb62 	bl	8000584 <HAL_GetTick>
 8000ec0:	1b80      	subs	r0, r0, r6
 8000ec2:	42a8      	cmp	r0, r5
 8000ec4:	d801      	bhi.n	8000eca <I2C_WaitOnSTOPFlagUntilTimeout+0x72>
 8000ec6:	2d00      	cmp	r5, #0
 8000ec8:	d1ca      	bne.n	8000e60 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8000eca:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8000ecc:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8000ece:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 8000ed0:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8000ed2:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 8000ed4:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8000ed8:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8000eda:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8000ede:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 8000ee2:	bd70      	pop	{r4, r5, r6, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8000ee4:	699a      	ldr	r2, [r3, #24]
 8000ee6:	0692      	lsls	r2, r2, #26
 8000ee8:	d4c6      	bmi.n	8000e78 <I2C_WaitOnSTOPFlagUntilTimeout+0x20>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8000eea:	f7ff fb4b 	bl	8000584 <HAL_GetTick>
 8000eee:	1b80      	subs	r0, r0, r6
 8000ef0:	4285      	cmp	r5, r0
 8000ef2:	d3ea      	bcc.n	8000eca <I2C_WaitOnSTOPFlagUntilTimeout+0x72>
 8000ef4:	2d00      	cmp	r5, #0
 8000ef6:	d0e8      	beq.n	8000eca <I2C_WaitOnSTOPFlagUntilTimeout+0x72>
 8000ef8:	6823      	ldr	r3, [r4, #0]
 8000efa:	e7b8      	b.n	8000e6e <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
 8000efc:	2000      	movs	r0, #0
}
 8000efe:	bd70      	pop	{r4, r5, r6, pc}
 8000f00:	fe00e800 	.word	0xfe00e800

08000f04 <HAL_I2C_Init>:
  if (hi2c == NULL)
 8000f04:	2800      	cmp	r0, #0
 8000f06:	d04d      	beq.n	8000fa4 <HAL_I2C_Init+0xa0>
{
 8000f08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8000f0a:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8000f0e:	4604      	mov	r4, r0
 8000f10:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8000f14:	2b00      	cmp	r3, #0
 8000f16:	d040      	beq.n	8000f9a <HAL_I2C_Init+0x96>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8000f18:	2124      	movs	r1, #36	; 0x24
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8000f1a:	68e5      	ldr	r5, [r4, #12]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8000f1c:	e9d4 3200 	ldrd	r3, r2, [r4]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8000f20:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8000f24:	2d01      	cmp	r5, #1
  __HAL_I2C_DISABLE(hi2c);
 8000f26:	6818      	ldr	r0, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8000f28:	f022 6170 	bic.w	r1, r2, #251658240	; 0xf000000
 8000f2c:	68a2      	ldr	r2, [r4, #8]
  __HAL_I2C_DISABLE(hi2c);
 8000f2e:	f020 0001 	bic.w	r0, r0, #1
 8000f32:	6018      	str	r0, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8000f34:	6119      	str	r1, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8000f36:	6899      	ldr	r1, [r3, #8]
 8000f38:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 8000f3c:	6099      	str	r1, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8000f3e:	d028      	beq.n	8000f92 <HAL_I2C_Init+0x8e>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8000f40:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8000f44:	2d02      	cmp	r5, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8000f46:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8000f48:	d102      	bne.n	8000f50 <HAL_I2C_Init+0x4c>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8000f4a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8000f4e:	605a      	str	r2, [r3, #4]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8000f50:	685a      	ldr	r2, [r3, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8000f52:	2100      	movs	r1, #0
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8000f54:	4814      	ldr	r0, [pc, #80]	; (8000fa8 <HAL_I2C_Init+0xa4>)
  hi2c->State = HAL_I2C_STATE_READY;
 8000f56:	2720      	movs	r7, #32
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8000f58:	69a6      	ldr	r6, [r4, #24]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8000f5a:	4310      	orrs	r0, r2
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8000f5c:	e9d4 2504 	ldrd	r2, r5, [r4, #16]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8000f60:	6058      	str	r0, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8000f62:	432a      	orrs	r2, r5
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8000f64:	68d8      	ldr	r0, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8000f66:	69e5      	ldr	r5, [r4, #28]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8000f68:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8000f6c:	6a26      	ldr	r6, [r4, #32]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8000f6e:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8000f72:	4335      	orrs	r5, r6
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8000f74:	60d8      	str	r0, [r3, #12]
  return HAL_OK;
 8000f76:	4608      	mov	r0, r1
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8000f78:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8000f7a:	601d      	str	r5, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8000f7c:	681a      	ldr	r2, [r3, #0]
 8000f7e:	f042 0201 	orr.w	r2, r2, #1
 8000f82:	601a      	str	r2, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8000f84:	6461      	str	r1, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8000f86:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8000f8a:	6321      	str	r1, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8000f8c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
 8000f90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8000f92:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000f96:	609a      	str	r2, [r3, #8]
 8000f98:	e7da      	b.n	8000f50 <HAL_I2C_Init+0x4c>
    hi2c->Lock = HAL_UNLOCKED;
 8000f9a:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8000f9e:	f004 f9f1 	bl	8005384 <HAL_I2C_MspInit>
 8000fa2:	e7b9      	b.n	8000f18 <HAL_I2C_Init+0x14>
    return HAL_ERROR;
 8000fa4:	2001      	movs	r0, #1
}
 8000fa6:	4770      	bx	lr
 8000fa8:	02008000 	.word	0x02008000

08000fac <HAL_I2C_Master_Transmit>:
{
 8000fac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8000fb0:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
 8000fb4:	9e08      	ldr	r6, [sp, #32]
  if (hi2c->State == HAL_I2C_STATE_READY)
 8000fb6:	2c20      	cmp	r4, #32
 8000fb8:	d16f      	bne.n	800109a <HAL_I2C_Master_Transmit+0xee>
    __HAL_LOCK(hi2c);
 8000fba:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
 8000fbe:	2c01      	cmp	r4, #1
 8000fc0:	d06b      	beq.n	800109a <HAL_I2C_Master_Transmit+0xee>
 8000fc2:	4698      	mov	r8, r3
 8000fc4:	2301      	movs	r3, #1
 8000fc6:	4691      	mov	r9, r2
 8000fc8:	460f      	mov	r7, r1
 8000fca:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 8000fce:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
 8000fd0:	f7ff fad8 	bl	8000584 <HAL_GetTick>
 8000fd4:	4605      	mov	r5, r0
 8000fd6:	e004      	b.n	8000fe2 <HAL_I2C_Master_Transmit+0x36>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8000fd8:	f7ff fad4 	bl	8000584 <HAL_GetTick>
 8000fdc:	1b40      	subs	r0, r0, r5
 8000fde:	2819      	cmp	r0, #25
 8000fe0:	d875      	bhi.n	80010ce <HAL_I2C_Master_Transmit+0x122>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8000fe2:	6823      	ldr	r3, [r4, #0]
 8000fe4:	6998      	ldr	r0, [r3, #24]
 8000fe6:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
 8000fea:	d1f5      	bne.n	8000fd8 <HAL_I2C_Master_Transmit+0x2c>
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8000fec:	2210      	movs	r2, #16
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8000fee:	2121      	movs	r1, #33	; 0x21
    hi2c->pBuffPtr  = pData;
 8000ff0:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
 8000ff4:	f3c7 0709 	ubfx	r7, r7, #0, #10
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8000ff8:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8000ffc:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001000:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 8001002:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001006:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 8001008:	6360      	str	r0, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800100a:	2aff      	cmp	r2, #255	; 0xff
 800100c:	d848      	bhi.n	80010a0 <HAL_I2C_Master_Transmit+0xf4>
      hi2c->XferSize = hi2c->XferCount;
 800100e:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8001010:	4a48      	ldr	r2, [pc, #288]	; (8001134 <HAL_I2C_Master_Transmit+0x188>)
      hi2c->XferSize = hi2c->XferCount;
 8001012:	b289      	uxth	r1, r1
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8001014:	6858      	ldr	r0, [r3, #4]
 8001016:	433a      	orrs	r2, r7
 8001018:	f8df e124 	ldr.w	lr, [pc, #292]	; 8001140 <HAL_I2C_Master_Transmit+0x194>
 800101c:	fa5f fc81 	uxtb.w	ip, r1
      hi2c->XferSize = hi2c->XferCount;
 8001020:	8521      	strh	r1, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8001022:	ea00 010e 	and.w	r1, r0, lr
 8001026:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
 800102a:	430a      	orrs	r2, r1
 800102c:	605a      	str	r2, [r3, #4]
 800102e:	f8df 8114 	ldr.w	r8, [pc, #276]	; 8001144 <HAL_I2C_Master_Transmit+0x198>
 8001032:	f8df 9114 	ldr.w	r9, [pc, #276]	; 8001148 <HAL_I2C_Master_Transmit+0x19c>
 8001036:	ea47 0808 	orr.w	r8, r7, r8
    while (hi2c->XferCount > 0U)
 800103a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800103c:	462a      	mov	r2, r5
 800103e:	4631      	mov	r1, r6
 8001040:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 8001042:	b29b      	uxth	r3, r3
 8001044:	2b00      	cmp	r3, #0
 8001046:	d062      	beq.n	800110e <HAL_I2C_Master_Transmit+0x162>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001048:	f7ff feaa 	bl	8000da0 <I2C_WaitOnTXISFlagUntilTimeout>
 800104c:	2800      	cmp	r0, #0
 800104e:	d15b      	bne.n	8001108 <HAL_I2C_Master_Transmit+0x15c>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8001050:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8001052:	6821      	ldr	r1, [r4, #0]
 8001054:	f810 2b01 	ldrb.w	r2, [r0], #1
      hi2c->XferSize--;
 8001058:	8d23      	ldrh	r3, [r4, #40]	; 0x28
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800105a:	628a      	str	r2, [r1, #40]	; 0x28
      hi2c->XferCount--;
 800105c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 800105e:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
 8001060:	6260      	str	r0, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8001062:	3a01      	subs	r2, #1
      hi2c->XferSize--;
 8001064:	b29b      	uxth	r3, r3
      hi2c->XferCount--;
 8001066:	b292      	uxth	r2, r2
      hi2c->XferSize--;
 8001068:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 800106a:	8562      	strh	r2, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800106c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 800106e:	b292      	uxth	r2, r2
 8001070:	2a00      	cmp	r2, #0
 8001072:	d0e2      	beq.n	800103a <HAL_I2C_Master_Transmit+0x8e>
 8001074:	2b00      	cmp	r3, #0
 8001076:	d1e0      	bne.n	800103a <HAL_I2C_Master_Transmit+0x8e>
 8001078:	1c70      	adds	r0, r6, #1
 800107a:	d11d      	bne.n	80010b8 <HAL_I2C_Master_Transmit+0x10c>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800107c:	698b      	ldr	r3, [r1, #24]
 800107e:	061a      	lsls	r2, r3, #24
 8001080:	d5fc      	bpl.n	800107c <HAL_I2C_Master_Transmit+0xd0>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001082:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001084:	2bff      	cmp	r3, #255	; 0xff
 8001086:	d930      	bls.n	80010ea <HAL_I2C_Master_Transmit+0x13e>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8001088:	684b      	ldr	r3, [r1, #4]
          hi2c->XferSize = MAX_NBYTE_SIZE;
 800108a:	22ff      	movs	r2, #255	; 0xff
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800108c:	ea03 0309 	and.w	r3, r3, r9
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8001090:	8522      	strh	r2, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8001092:	ea43 0308 	orr.w	r3, r3, r8
 8001096:	604b      	str	r3, [r1, #4]
 8001098:	e7cf      	b.n	800103a <HAL_I2C_Master_Transmit+0x8e>
    return HAL_BUSY;
 800109a:	2002      	movs	r0, #2
}
 800109c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80010a0:	685a      	ldr	r2, [r3, #4]
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80010a2:	20ff      	movs	r0, #255	; 0xff
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80010a4:	f8df c098 	ldr.w	ip, [pc, #152]	; 8001140 <HAL_I2C_Master_Transmit+0x194>
 80010a8:	4923      	ldr	r1, [pc, #140]	; (8001138 <HAL_I2C_Master_Transmit+0x18c>)
 80010aa:	ea02 020c 	and.w	r2, r2, ip
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80010ae:	8520      	strh	r0, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80010b0:	4339      	orrs	r1, r7
 80010b2:	430a      	orrs	r2, r1
 80010b4:	605a      	str	r2, [r3, #4]
 80010b6:	e7ba      	b.n	800102e <HAL_I2C_Master_Transmit+0x82>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80010b8:	698b      	ldr	r3, [r1, #24]
 80010ba:	061b      	lsls	r3, r3, #24
 80010bc:	d4e1      	bmi.n	8001082 <HAL_I2C_Master_Transmit+0xd6>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80010be:	f7ff fa61 	bl	8000584 <HAL_GetTick>
 80010c2:	1b40      	subs	r0, r0, r5
 80010c4:	4286      	cmp	r6, r0
 80010c6:	d302      	bcc.n	80010ce <HAL_I2C_Master_Transmit+0x122>
 80010c8:	b10e      	cbz	r6, 80010ce <HAL_I2C_Master_Transmit+0x122>
 80010ca:	6821      	ldr	r1, [r4, #0]
 80010cc:	e7d4      	b.n	8001078 <HAL_I2C_Master_Transmit+0xcc>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80010ce:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80010d0:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80010d2:	2200      	movs	r2, #0
          return HAL_ERROR;
 80010d4:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80010d6:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 80010d8:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80010dc:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80010de:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80010e2:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 80010e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          hi2c->XferSize = hi2c->XferCount;
 80010ea:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80010ec:	f047 7300 	orr.w	r3, r7, #33554432	; 0x2000000
 80010f0:	6848      	ldr	r0, [r1, #4]
          hi2c->XferSize = hi2c->XferCount;
 80010f2:	b292      	uxth	r2, r2
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80010f4:	ea00 0009 	and.w	r0, r0, r9
 80010f8:	fa5f fc82 	uxtb.w	ip, r2
          hi2c->XferSize = hi2c->XferCount;
 80010fc:	8522      	strh	r2, [r4, #40]	; 0x28
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80010fe:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
 8001102:	4303      	orrs	r3, r0
 8001104:	604b      	str	r3, [r1, #4]
 8001106:	e798      	b.n	800103a <HAL_I2C_Master_Transmit+0x8e>
        return HAL_ERROR;
 8001108:	2001      	movs	r0, #1
}
 800110a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800110e:	f7ff fea3 	bl	8000e58 <I2C_WaitOnSTOPFlagUntilTimeout>
 8001112:	2800      	cmp	r0, #0
 8001114:	d1f8      	bne.n	8001108 <HAL_I2C_Master_Transmit+0x15c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8001116:	6823      	ldr	r3, [r4, #0]
 8001118:	2120      	movs	r1, #32
    I2C_RESET_CR2(hi2c);
 800111a:	4d08      	ldr	r5, [pc, #32]	; (800113c <HAL_I2C_Master_Transmit+0x190>)
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800111c:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 800111e:	685a      	ldr	r2, [r3, #4]
 8001120:	402a      	ands	r2, r5
 8001122:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8001124:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001128:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800112c:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8001130:	e7b4      	b.n	800109c <HAL_I2C_Master_Transmit+0xf0>
 8001132:	bf00      	nop
 8001134:	82002000 	.word	0x82002000
 8001138:	81ff2000 	.word	0x81ff2000
 800113c:	fe00e800 	.word	0xfe00e800
 8001140:	fc009800 	.word	0xfc009800
 8001144:	01ff0000 	.word	0x01ff0000
 8001148:	fc009c00 	.word	0xfc009c00

0800114c <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800114c:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8001150:	b2db      	uxtb	r3, r3
 8001152:	2b20      	cmp	r3, #32
{
 8001154:	b470      	push	{r4, r5, r6}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8001156:	d11f      	bne.n	8001198 <HAL_I2CEx_ConfigAnalogFilter+0x4c>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8001158:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 800115c:	2a01      	cmp	r2, #1
 800115e:	d01b      	beq.n	8001198 <HAL_I2CEx_ConfigAnalogFilter+0x4c>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8001160:	6802      	ldr	r2, [r0, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 8001162:	2424      	movs	r4, #36	; 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8001164:	2600      	movs	r6, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
 8001166:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
 800116a:	6815      	ldr	r5, [r2, #0]

    return HAL_OK;
 800116c:	4634      	mov	r4, r6
    __HAL_I2C_DISABLE(hi2c);
 800116e:	f025 0501 	bic.w	r5, r5, #1
 8001172:	6015      	str	r5, [r2, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8001174:	6815      	ldr	r5, [r2, #0]
 8001176:	f425 5580 	bic.w	r5, r5, #4096	; 0x1000
 800117a:	6015      	str	r5, [r2, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 800117c:	6815      	ldr	r5, [r2, #0]
 800117e:	4329      	orrs	r1, r5
 8001180:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
 8001182:	6811      	ldr	r1, [r2, #0]
 8001184:	f041 0101 	orr.w	r1, r1, #1
 8001188:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
 800118a:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 800118e:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  }
  else
  {
    return HAL_BUSY;
  }
}
 8001192:	4620      	mov	r0, r4
 8001194:	bc70      	pop	{r4, r5, r6}
 8001196:	4770      	bx	lr
    return HAL_BUSY;
 8001198:	2402      	movs	r4, #2
}
 800119a:	4620      	mov	r0, r4
 800119c:	bc70      	pop	{r4, r5, r6}
 800119e:	4770      	bx	lr

080011a0 <HAL_I2CEx_ConfigDigitalFilter>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80011a0:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80011a4:	b2db      	uxtb	r3, r3
 80011a6:	2b20      	cmp	r3, #32
{
 80011a8:	b470      	push	{r4, r5, r6}
  if (hi2c->State == HAL_I2C_STATE_READY)
 80011aa:	d11e      	bne.n	80011ea <HAL_I2CEx_ConfigDigitalFilter+0x4a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80011ac:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 80011b0:	2a01      	cmp	r2, #1
 80011b2:	d01a      	beq.n	80011ea <HAL_I2CEx_ConfigDigitalFilter+0x4a>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80011b4:	6802      	ldr	r2, [r0, #0]
    hi2c->State = HAL_I2C_STATE_BUSY;
 80011b6:	2424      	movs	r4, #36	; 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80011b8:	2600      	movs	r6, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
 80011ba:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
 80011be:	6814      	ldr	r4, [r2, #0]

    return HAL_OK;
 80011c0:	4635      	mov	r5, r6
    __HAL_I2C_DISABLE(hi2c);
 80011c2:	f024 0401 	bic.w	r4, r4, #1
 80011c6:	6014      	str	r4, [r2, #0]
    tmpreg = hi2c->Instance->CR1;
 80011c8:	6814      	ldr	r4, [r2, #0]
    tmpreg &= ~(I2C_CR1_DNF);
 80011ca:	f424 6470 	bic.w	r4, r4, #3840	; 0xf00
    tmpreg |= DigitalFilter << 8U;
 80011ce:	ea44 2101 	orr.w	r1, r4, r1, lsl #8
    hi2c->Instance->CR1 = tmpreg;
 80011d2:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
 80011d4:	6811      	ldr	r1, [r2, #0]
 80011d6:	f041 0101 	orr.w	r1, r1, #1
 80011da:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
 80011dc:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 80011e0:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  }
  else
  {
    return HAL_BUSY;
  }
}
 80011e4:	4628      	mov	r0, r5
 80011e6:	bc70      	pop	{r4, r5, r6}
 80011e8:	4770      	bx	lr
    return HAL_BUSY;
 80011ea:	2502      	movs	r5, #2
}
 80011ec:	4628      	mov	r0, r5
 80011ee:	bc70      	pop	{r4, r5, r6}
 80011f0:	4770      	bx	lr
 80011f2:	bf00      	nop

080011f4 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 80011f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80011f6:	b08b      	sub	sp, #44	; 0x2c
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 80011f8:	2800      	cmp	r0, #0
 80011fa:	f000 8084 	beq.w	8001306 <HAL_PCD_Init+0x112>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if (hpcd->State == HAL_PCD_STATE_RESET)
 80011fe:	f890 33bd 	ldrb.w	r3, [r0, #957]	; 0x3bd
 8001202:	4604      	mov	r4, r0
 8001204:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001208:	2b00      	cmp	r3, #0
 800120a:	d077      	beq.n	80012fc <HAL_PCD_Init+0x108>
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 800120c:	2303      	movs	r3, #3

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800120e:	4625      	mov	r5, r4
  __HAL_PCD_DISABLE(hpcd);
 8001210:	6820      	ldr	r0, [r4, #0]
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8001212:	466f      	mov	r7, sp
  hpcd->State = HAL_PCD_STATE_BUSY;
 8001214:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8001218:	1d26      	adds	r6, r4, #4
  __HAL_PCD_DISABLE(hpcd);
 800121a:	f002 fc69 	bl	8003af0 <USB_DisableGlobalInt>
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800121e:	f855 eb10 	ldr.w	lr, [r5], #16
 8001222:	46ac      	mov	ip, r5
 8001224:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8001228:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 800122a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800122e:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 8001230:	e89c 0003 	ldmia.w	ip, {r0, r1}
 8001234:	e887 0003 	stmia.w	r7, {r0, r1}
 8001238:	4670      	mov	r0, lr
 800123a:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
 800123e:	f002 fb67 	bl	8003910 <USB_CoreInit>
 8001242:	4607      	mov	r7, r0
 8001244:	b130      	cbz	r0, 8001254 <HAL_PCD_Init+0x60>

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
    return HAL_ERROR;
 8001246:	2501      	movs	r5, #1
    hpcd->State = HAL_PCD_STATE_ERROR;
 8001248:	2302      	movs	r3, #2
  }
  
  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 800124a:	4628      	mov	r0, r5
    hpcd->State = HAL_PCD_STATE_ERROR;
 800124c:	f884 33bd 	strb.w	r3, [r4, #957]	; 0x3bd
}
 8001250:	b00b      	add	sp, #44	; 0x2c
 8001252:	bdf0      	pop	{r4, r5, r6, r7, pc}
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 8001254:	4601      	mov	r1, r0
 8001256:	6820      	ldr	r0, [r4, #0]
 8001258:	f002 fc52 	bl	8003b00 <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800125c:	6860      	ldr	r0, [r4, #4]
 800125e:	b360      	cbz	r0, 80012ba <HAL_PCD_Init+0xc6>
 8001260:	4639      	mov	r1, r7
    hpcd->IN_ep[i].is_in = 1U;
 8001262:	f04f 0c01 	mov.w	ip, #1
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8001266:	463a      	mov	r2, r7
    hpcd->IN_ep[i].is_in = 1U;
 8001268:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800126c:	1c4f      	adds	r7, r1, #1
    hpcd->IN_ep[i].is_in = 1U;
 800126e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    hpcd->IN_ep[i].num = i;
 8001272:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
    hpcd->IN_ep[i].tx_fifo_num = i;
 8001276:	f8a3 1042 	strh.w	r1, [r3, #66]	; 0x42
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800127a:	b2f9      	uxtb	r1, r7
    hpcd->IN_ep[i].is_in = 1U;
 800127c:	f883 c03d 	strb.w	ip, [r3, #61]	; 0x3d
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001280:	4281      	cmp	r1, r0
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8001282:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
    hpcd->IN_ep[i].xfer_len = 0U;
 8001286:	651a      	str	r2, [r3, #80]	; 0x50
    hpcd->IN_ep[i].xfer_buff = 0U;
 8001288:	e9c3 2211 	strd	r2, r2, [r3, #68]	; 0x44
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800128c:	d3ec      	bcc.n	8001268 <HAL_PCD_Init+0x74>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800128e:	2200      	movs	r2, #0
    hpcd->OUT_ep[i].is_in = 0U;
 8001290:	4611      	mov	r1, r2
 8001292:	ebc2 03c2 	rsb	r3, r2, r2, lsl #3
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001296:	1c57      	adds	r7, r2, #1
    hpcd->OUT_ep[i].is_in = 0U;
 8001298:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    hpcd->OUT_ep[i].num = i;
 800129c:	f883 21fc 	strb.w	r2, [r3, #508]	; 0x1fc
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80012a0:	b2fa      	uxtb	r2, r7
    hpcd->OUT_ep[i].is_in = 0U;
 80012a2:	f883 11fd 	strb.w	r1, [r3, #509]	; 0x1fd
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80012a6:	4282      	cmp	r2, r0
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80012a8:	f883 11ff 	strb.w	r1, [r3, #511]	; 0x1ff
    hpcd->OUT_ep[i].maxpacket = 0U;
 80012ac:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80012b0:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
    hpcd->OUT_ep[i].xfer_len = 0U;
 80012b4:	f8c3 1210 	str.w	r1, [r3, #528]	; 0x210
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80012b8:	d3eb      	bcc.n	8001292 <HAL_PCD_Init+0x9e>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80012ba:	466f      	mov	r7, sp
 80012bc:	f8d4 c000 	ldr.w	ip, [r4]
 80012c0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80012c2:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80012c4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80012c6:	c70f      	stmia	r7!, {r0, r1, r2, r3}
 80012c8:	e895 0003 	ldmia.w	r5, {r0, r1}
 80012cc:	e887 0003 	stmia.w	r7, {r0, r1}
 80012d0:	4660      	mov	r0, ip
 80012d2:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
 80012d6:	f002 fc2b 	bl	8003b30 <USB_DevInit>
 80012da:	4605      	mov	r5, r0
 80012dc:	2800      	cmp	r0, #0
 80012de:	d1b2      	bne.n	8001246 <HAL_PCD_Init+0x52>
  hpcd->State = HAL_PCD_STATE_READY;
 80012e0:	2201      	movs	r2, #1
  if (hpcd->Init.lpm_enable == 1U)
 80012e2:	6a63      	ldr	r3, [r4, #36]	; 0x24
  hpcd->USB_Address = 0U;
 80012e4:	f884 0038 	strb.w	r0, [r4, #56]	; 0x38
  if (hpcd->Init.lpm_enable == 1U)
 80012e8:	4293      	cmp	r3, r2
  hpcd->State = HAL_PCD_STATE_READY;
 80012ea:	f884 23bd 	strb.w	r2, [r4, #957]	; 0x3bd
  if (hpcd->Init.lpm_enable == 1U)
 80012ee:	d00e      	beq.n	800130e <HAL_PCD_Init+0x11a>
  (void)USB_DevDisconnect(hpcd->Instance);
 80012f0:	6820      	ldr	r0, [r4, #0]
 80012f2:	f002 ffe1 	bl	80042b8 <USB_DevDisconnect>
}
 80012f6:	4628      	mov	r0, r5
 80012f8:	b00b      	add	sp, #44	; 0x2c
 80012fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hpcd->Lock = HAL_UNLOCKED;
 80012fc:	f880 23bc 	strb.w	r2, [r0, #956]	; 0x3bc
    HAL_PCD_MspInit(hpcd);
 8001300:	f007 fb88 	bl	8008a14 <HAL_PCD_MspInit>
 8001304:	e782      	b.n	800120c <HAL_PCD_Init+0x18>
    return HAL_ERROR;
 8001306:	2501      	movs	r5, #1
}
 8001308:	4628      	mov	r0, r5
 800130a:	b00b      	add	sp, #44	; 0x2c
 800130c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 800130e:	4620      	mov	r0, r4
 8001310:	f000 fd20 	bl	8001d54 <HAL_PCDEx_ActivateLPM>
 8001314:	e7ec      	b.n	80012f0 <HAL_PCD_Init+0xfc>
 8001316:	bf00      	nop

08001318 <HAL_PCD_Start>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
  __HAL_LOCK(hpcd);
 8001318:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 800131c:	2b01      	cmp	r3, #1
 800131e:	d00e      	beq.n	800133e <HAL_PCD_Start+0x26>
 8001320:	2301      	movs	r3, #1
{
 8001322:	b510      	push	{r4, lr}
 8001324:	4604      	mov	r4, r0
  (void)USB_DevConnect(hpcd->Instance);
 8001326:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8001328:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_DevConnect(hpcd->Instance);
 800132c:	f002 ffb8 	bl	80042a0 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 8001330:	6820      	ldr	r0, [r4, #0]
 8001332:	f002 fbd5 	bl	8003ae0 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd);
 8001336:	2000      	movs	r0, #0
 8001338:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
  return HAL_OK;
}
 800133c:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 800133e:	2002      	movs	r0, #2
}
 8001340:	4770      	bx	lr
 8001342:	bf00      	nop

08001344 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8001344:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8001348:	6805      	ldr	r5, [r0, #0]
{
 800134a:	b089      	sub	sp, #36	; 0x24
 800134c:	4604      	mov	r4, r0
  uint32_t i, ep_intr, epint, epnum = 0U;
  uint32_t fifoemptymsk, temp;
  USB_OTG_EPTypeDef *ep;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 800134e:	4628      	mov	r0, r5
 8001350:	f002 fff0 	bl	8004334 <USB_GetMode>
 8001354:	b110      	cbz	r0, 800135c <HAL_PCD_IRQHandler+0x18>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= temp;
    }
  }
}
 8001356:	b009      	add	sp, #36	; 0x24
 8001358:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800135c:	4606      	mov	r6, r0
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 800135e:	6820      	ldr	r0, [r4, #0]
 8001360:	f002 ffb6 	bl	80042d0 <USB_ReadInterrupts>
 8001364:	2800      	cmp	r0, #0
 8001366:	d0f6      	beq.n	8001356 <HAL_PCD_IRQHandler+0x12>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8001368:	6820      	ldr	r0, [r4, #0]
 800136a:	f002 ffb1 	bl	80042d0 <USB_ReadInterrupts>
 800136e:	f010 0f02 	tst.w	r0, #2
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8001372:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8001374:	d003      	beq.n	800137e <HAL_PCD_IRQHandler+0x3a>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8001376:	6943      	ldr	r3, [r0, #20]
 8001378:	f003 0302 	and.w	r3, r3, #2
 800137c:	6143      	str	r3, [r0, #20]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 800137e:	f002 ffa7 	bl	80042d0 <USB_ReadInterrupts>
 8001382:	f410 2b00 	ands.w	fp, r0, #524288	; 0x80000
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 8001386:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8001388:	f040 81cf 	bne.w	800172a <HAL_PCD_IRQHandler+0x3e6>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 800138c:	f002 ffa0 	bl	80042d0 <USB_ReadInterrupts>
 8001390:	0343      	lsls	r3, r0, #13
 8001392:	f100 811c 	bmi.w	80015ce <HAL_PCD_IRQHandler+0x28a>
 8001396:	f8d4 a000 	ldr.w	sl, [r4]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800139a:	4650      	mov	r0, sl
 800139c:	f002 ff98 	bl	80042d0 <USB_ReadInterrupts>
 80013a0:	2800      	cmp	r0, #0
 80013a2:	f2c0 809c 	blt.w	80014de <HAL_PCD_IRQHandler+0x19a>
 80013a6:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80013a8:	f002 ff92 	bl	80042d0 <USB_ReadInterrupts>
 80013ac:	0500      	lsls	r0, r0, #20
 80013ae:	d463      	bmi.n	8001478 <HAL_PCD_IRQHandler+0x134>
 80013b0:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
 80013b2:	f002 ff8d 	bl	80042d0 <USB_ReadInterrupts>
 80013b6:	0102      	lsls	r2, r0, #4
 80013b8:	d513      	bpl.n	80013e2 <HAL_PCD_IRQHandler+0x9e>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 80013ba:	6822      	ldr	r2, [r4, #0]
      if (hpcd->LPM_State == LPM_L0)
 80013bc:	f894 13f4 	ldrb.w	r1, [r4, #1012]	; 0x3f4
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
 80013c0:	6953      	ldr	r3, [r2, #20]
 80013c2:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80013c6:	6153      	str	r3, [r2, #20]
      if (hpcd->LPM_State == LPM_L0)
 80013c8:	2900      	cmp	r1, #0
 80013ca:	d15f      	bne.n	800148c <HAL_PCD_IRQHandler+0x148>
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 80013cc:	6d53      	ldr	r3, [r2, #84]	; 0x54
        hpcd->LPM_State = LPM_L1;
 80013ce:	2101      	movs	r1, #1
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 80013d0:	4620      	mov	r0, r4
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 80013d2:	f3c3 0383 	ubfx	r3, r3, #2, #4
        hpcd->LPM_State = LPM_L1;
 80013d6:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4
        hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
 80013da:	f8c4 33f8 	str.w	r3, [r4, #1016]	; 0x3f8
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
 80013de:	f007 fc77 	bl	8008cd0 <HAL_PCDEx_LPM_Callback>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 80013e2:	6820      	ldr	r0, [r4, #0]
 80013e4:	f002 ff74 	bl	80042d0 <USB_ReadInterrupts>
 80013e8:	04c3      	lsls	r3, r0, #19
 80013ea:	f100 80a6 	bmi.w	800153a <HAL_PCD_IRQHandler+0x1f6>
 80013ee:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80013f0:	f002 ff6e 	bl	80042d0 <USB_ReadInterrupts>
 80013f4:	f410 5f00 	tst.w	r0, #8192	; 0x2000
      (void)USB_ActivateSetup(hpcd->Instance);
 80013f8:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 80013fa:	f040 8084 	bne.w	8001506 <HAL_PCD_IRQHandler+0x1c2>
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 80013fe:	f002 ff67 	bl	80042d0 <USB_ReadInterrupts>
 8001402:	f010 0f10 	tst.w	r0, #16
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8001406:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8001408:	d011      	beq.n	800142e <HAL_PCD_IRQHandler+0xea>
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800140a:	6983      	ldr	r3, [r0, #24]
 800140c:	f023 0310 	bic.w	r3, r3, #16
 8001410:	6183      	str	r3, [r0, #24]
      temp = USBx->GRXSTSP;
 8001412:	6a2e      	ldr	r6, [r5, #32]
      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 8001414:	f3c6 4343 	ubfx	r3, r6, #17, #4
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8001418:	f006 070f 	and.w	r7, r6, #15
      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800141c:	2b02      	cmp	r3, #2
 800141e:	d03e      	beq.n	800149e <HAL_PCD_IRQHandler+0x15a>
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
 8001420:	2b06      	cmp	r3, #6
 8001422:	f000 82a9 	beq.w	8001978 <HAL_PCD_IRQHandler+0x634>
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8001426:	6983      	ldr	r3, [r0, #24]
 8001428:	f043 0310 	orr.w	r3, r3, #16
 800142c:	6183      	str	r3, [r0, #24]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 800142e:	f002 ff4f 	bl	80042d0 <USB_ReadInterrupts>
 8001432:	0707      	lsls	r7, r0, #28
 8001434:	f100 81c3 	bmi.w	80017be <HAL_PCD_IRQHandler+0x47a>
 8001438:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 800143a:	f002 ff49 	bl	80042d0 <USB_ReadInterrupts>
 800143e:	02c6      	lsls	r6, r0, #11
 8001440:	f100 81b2 	bmi.w	80017a8 <HAL_PCD_IRQHandler+0x464>
 8001444:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8001446:	f002 ff43 	bl	80042d0 <USB_ReadInterrupts>
 800144a:	0285      	lsls	r5, r0, #10
 800144c:	f100 81c0 	bmi.w	80017d0 <HAL_PCD_IRQHandler+0x48c>
 8001450:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8001452:	f002 ff3d 	bl	80042d0 <USB_ReadInterrupts>
 8001456:	0040      	lsls	r0, r0, #1
 8001458:	f100 815e 	bmi.w	8001718 <HAL_PCD_IRQHandler+0x3d4>
 800145c:	6820      	ldr	r0, [r4, #0]
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 800145e:	f002 ff37 	bl	80042d0 <USB_ReadInterrupts>
 8001462:	0741      	lsls	r1, r0, #29
 8001464:	f57f af77 	bpl.w	8001356 <HAL_PCD_IRQHandler+0x12>
      temp = hpcd->Instance->GOTGINT;
 8001468:	6823      	ldr	r3, [r4, #0]
 800146a:	685d      	ldr	r5, [r3, #4]
      if ((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 800146c:	076a      	lsls	r2, r5, #29
 800146e:	d411      	bmi.n	8001494 <HAL_PCD_IRQHandler+0x150>
      hpcd->Instance->GOTGINT |= temp;
 8001470:	685a      	ldr	r2, [r3, #4]
 8001472:	432a      	orrs	r2, r5
 8001474:	605a      	str	r2, [r3, #4]
 8001476:	e76e      	b.n	8001356 <HAL_PCD_IRQHandler+0x12>
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8001478:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
 800147c:	07d9      	lsls	r1, r3, #31
 800147e:	d42a      	bmi.n	80014d6 <HAL_PCD_IRQHandler+0x192>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8001480:	6820      	ldr	r0, [r4, #0]
 8001482:	6943      	ldr	r3, [r0, #20]
 8001484:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001488:	6143      	str	r3, [r0, #20]
 800148a:	e792      	b.n	80013b2 <HAL_PCD_IRQHandler+0x6e>
        HAL_PCD_SuspendCallback(hpcd);
 800148c:	4620      	mov	r0, r4
 800148e:	f007 fb35 	bl	8008afc <HAL_PCD_SuspendCallback>
 8001492:	e7a6      	b.n	80013e2 <HAL_PCD_IRQHandler+0x9e>
        HAL_PCD_DisconnectCallback(hpcd);
 8001494:	4620      	mov	r0, r4
 8001496:	f007 fb59 	bl	8008b4c <HAL_PCD_DisconnectCallback>
 800149a:	6823      	ldr	r3, [r4, #0]
 800149c:	e7e8      	b.n	8001470 <HAL_PCD_IRQHandler+0x12c>
        if ((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 800149e:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 80014a2:	421e      	tst	r6, r3
 80014a4:	d0bf      	beq.n	8001426 <HAL_PCD_IRQHandler+0xe2>
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 80014a6:	ebc7 07c7 	rsb	r7, r7, r7, lsl #3
 80014aa:	f3c6 160a 	ubfx	r6, r6, #4, #11
 80014ae:	4628      	mov	r0, r5
 80014b0:	eb04 0787 	add.w	r7, r4, r7, lsl #2
 80014b4:	4632      	mov	r2, r6
 80014b6:	f8d7 1208 	ldr.w	r1, [r7, #520]	; 0x208
 80014ba:	f002 fe6f 	bl	800419c <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80014be:	f8d7 2208 	ldr.w	r2, [r7, #520]	; 0x208
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80014c2:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80014c6:	4432      	add	r2, r6
 80014c8:	6820      	ldr	r0, [r4, #0]
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80014ca:	441e      	add	r6, r3
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80014cc:	f8c7 2208 	str.w	r2, [r7, #520]	; 0x208
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80014d0:	f8c7 6214 	str.w	r6, [r7, #532]	; 0x214
 80014d4:	e7a7      	b.n	8001426 <HAL_PCD_IRQHandler+0xe2>
        HAL_PCD_SuspendCallback(hpcd);
 80014d6:	4620      	mov	r0, r4
 80014d8:	f007 fb10 	bl	8008afc <HAL_PCD_SuspendCallback>
 80014dc:	e7d0      	b.n	8001480 <HAL_PCD_IRQHandler+0x13c>
      if (hpcd->LPM_State == LPM_L1)
 80014de:	f894 13f4 	ldrb.w	r1, [r4, #1012]	; 0x3f4
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80014e2:	f8d5 2804 	ldr.w	r2, [r5, #2052]	; 0x804
      if (hpcd->LPM_State == LPM_L1)
 80014e6:	2901      	cmp	r1, #1
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 80014e8:	f022 0201 	bic.w	r2, r2, #1
 80014ec:	f8c5 2804 	str.w	r2, [r5, #2052]	; 0x804
      if (hpcd->LPM_State == LPM_L1)
 80014f0:	f000 81ff 	beq.w	80018f2 <HAL_PCD_IRQHandler+0x5ae>
        HAL_PCD_ResumeCallback(hpcd);
 80014f4:	4620      	mov	r0, r4
 80014f6:	f007 fb19 	bl	8008b2c <HAL_PCD_ResumeCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 80014fa:	6820      	ldr	r0, [r4, #0]
 80014fc:	6943      	ldr	r3, [r0, #20]
 80014fe:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8001502:	6143      	str	r3, [r0, #20]
 8001504:	e750      	b.n	80013a8 <HAL_PCD_IRQHandler+0x64>
      (void)USB_ActivateSetup(hpcd->Instance);
 8001506:	f002 ff19 	bl	800433c <USB_ActivateSetup>
      if (USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 800150a:	6820      	ldr	r0, [r4, #0]
 800150c:	f002 fc20 	bl	8003d50 <USB_GetDevSpeed>
        hpcd->Init.speed = USB_OTG_SPEED_FULL;
 8001510:	2800      	cmp	r0, #0
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8001512:	6827      	ldr	r7, [r4, #0]
        hpcd->Init.speed = USB_OTG_SPEED_FULL;
 8001514:	bf18      	it	ne
 8001516:	2603      	movne	r6, #3
 8001518:	60e6      	str	r6, [r4, #12]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 800151a:	f000 ff37 	bl	800238c <HAL_RCC_GetHCLKFreq>
 800151e:	7b22      	ldrb	r2, [r4, #12]
 8001520:	4601      	mov	r1, r0
 8001522:	4638      	mov	r0, r7
 8001524:	f002 fa5c 	bl	80039e0 <USB_SetTurnaroundTime>
      HAL_PCD_ResetCallback(hpcd);
 8001528:	4620      	mov	r0, r4
 800152a:	f007 fad1 	bl	8008ad0 <HAL_PCD_ResetCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 800152e:	6820      	ldr	r0, [r4, #0]
 8001530:	6943      	ldr	r3, [r0, #20]
 8001532:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8001536:	6143      	str	r3, [r0, #20]
 8001538:	e761      	b.n	80013fe <HAL_PCD_IRQHandler+0xba>
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800153a:	f505 6700 	add.w	r7, r5, #2048	; 0x800
 800153e:	687b      	ldr	r3, [r7, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8001540:	6820      	ldr	r0, [r4, #0]
 8001542:	2110      	movs	r1, #16
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8001544:	f023 0301 	bic.w	r3, r3, #1
 8001548:	607b      	str	r3, [r7, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 800154a:	f002 fbef 	bl	8003d2c <USB_FlushTxFifo>
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800154e:	f8d4 e004 	ldr.w	lr, [r4, #4]
 8001552:	f1be 0f00 	cmp.w	lr, #0
 8001556:	d016      	beq.n	8001586 <HAL_PCD_IRQHandler+0x242>
 8001558:	f505 6310 	add.w	r3, r5, #2304	; 0x900
 800155c:	2100      	movs	r1, #0
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 800155e:	f64f 307f 	movw	r0, #64383	; 0xfb7f
 8001562:	6098      	str	r0, [r3, #8]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001564:	3101      	adds	r1, #1
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8001566:	681a      	ldr	r2, [r3, #0]
 8001568:	3320      	adds	r3, #32
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800156a:	4571      	cmp	r1, lr
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800156c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8001570:	f843 2c20 	str.w	r2, [r3, #-32]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8001574:	f8c3 01e8 	str.w	r0, [r3, #488]	; 0x1e8
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8001578:	f8d3 21e0 	ldr.w	r2, [r3, #480]	; 0x1e0
 800157c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8001580:	f8c3 21e0 	str.w	r2, [r3, #480]	; 0x1e0
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8001584:	d1ed      	bne.n	8001562 <HAL_PCD_IRQHandler+0x21e>
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8001586:	69fb      	ldr	r3, [r7, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8001588:	6b22      	ldr	r2, [r4, #48]	; 0x30
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 800158a:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 800158e:	61fb      	str	r3, [r7, #28]
      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8001590:	2a00      	cmp	r2, #0
 8001592:	f000 81a4 	beq.w	80018de <HAL_PCD_IRQHandler+0x59a>
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8001596:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800159a:	f043 030b 	orr.w	r3, r3, #11
 800159e:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 80015a2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80015a4:	f043 030b 	orr.w	r3, r3, #11
 80015a8:	647b      	str	r3, [r7, #68]	; 0x44
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 80015aa:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 80015ae:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 80015b2:	7c21      	ldrb	r1, [r4, #16]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 80015b4:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 80015b8:	6820      	ldr	r0, [r4, #0]
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 80015ba:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 80015be:	f002 fed9 	bl	8004374 <USB_EP0_OutStart>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 80015c2:	6820      	ldr	r0, [r4, #0]
 80015c4:	6943      	ldr	r3, [r0, #20]
 80015c6:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80015ca:	6143      	str	r3, [r0, #20]
 80015cc:	e710      	b.n	80013f0 <HAL_PCD_IRQHandler+0xac>
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 80015ce:	6820      	ldr	r0, [r4, #0]
 80015d0:	f002 fe8a 	bl	80042e8 <USB_ReadDevAllInEpInterrupt>
      while (ep_intr != 0U)
 80015d4:	4681      	mov	r9, r0
 80015d6:	2800      	cmp	r0, #0
 80015d8:	f000 81f0 	beq.w	80019bc <HAL_PCD_IRQHandler+0x678>
 80015dc:	f505 6310 	add.w	r3, r5, #2304	; 0x900
 80015e0:	f8d4 a000 	ldr.w	sl, [r4]
 80015e4:	46a0      	mov	r8, r4
      epnum = 0U;
 80015e6:	f04f 0b00 	mov.w	fp, #0
 80015ea:	9303      	str	r3, [sp, #12]
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 80015ec:	e9cd 5604 	strd	r5, r6, [sp, #16]
 80015f0:	e007      	b.n	8001602 <HAL_PCD_IRQHandler+0x2be>
      while (ep_intr != 0U)
 80015f2:	ea5f 0959 	movs.w	r9, r9, lsr #1
        epnum++;
 80015f6:	f10b 0b01 	add.w	fp, fp, #1
 80015fa:	f108 081c 	add.w	r8, r8, #28
      while (ep_intr != 0U)
 80015fe:	f000 8126 	beq.w	800184e <HAL_PCD_IRQHandler+0x50a>
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 8001602:	f019 0f01 	tst.w	r9, #1
 8001606:	d0f4      	beq.n	80015f2 <HAL_PCD_IRQHandler+0x2ae>
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001608:	fa5f f68b 	uxtb.w	r6, fp
 800160c:	4650      	mov	r0, sl
 800160e:	4631      	mov	r1, r6
 8001610:	f002 fe7c 	bl	800430c <USB_ReadDevInEPInterrupt>
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8001614:	07c7      	lsls	r7, r0, #31
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001616:	4605      	mov	r5, r0
          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8001618:	f100 80e5 	bmi.w	80017e6 <HAL_PCD_IRQHandler+0x4a2>
 800161c:	f8d4 a000 	ldr.w	sl, [r4]
 8001620:	4657      	mov	r7, sl
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8001622:	0728      	lsls	r0, r5, #28
 8001624:	d504      	bpl.n	8001630 <HAL_PCD_IRQHandler+0x2ec>
 8001626:	9b03      	ldr	r3, [sp, #12]
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8001628:	2208      	movs	r2, #8
 800162a:	eb03 134b 	add.w	r3, r3, fp, lsl #5
 800162e:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8001630:	06e9      	lsls	r1, r5, #27
 8001632:	d504      	bpl.n	800163e <HAL_PCD_IRQHandler+0x2fa>
 8001634:	9b03      	ldr	r3, [sp, #12]
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8001636:	2210      	movs	r2, #16
 8001638:	eb03 134b 	add.w	r3, r3, fp, lsl #5
 800163c:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 800163e:	066a      	lsls	r2, r5, #25
 8001640:	d504      	bpl.n	800164c <HAL_PCD_IRQHandler+0x308>
 8001642:	9b03      	ldr	r3, [sp, #12]
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8001644:	2240      	movs	r2, #64	; 0x40
 8001646:	eb03 134b 	add.w	r3, r3, fp, lsl #5
 800164a:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 800164c:	07ab      	lsls	r3, r5, #30
 800164e:	d504      	bpl.n	800165a <HAL_PCD_IRQHandler+0x316>
 8001650:	9b03      	ldr	r3, [sp, #12]
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8001652:	2202      	movs	r2, #2
 8001654:	eb03 134b 	add.w	r3, r3, fp, lsl #5
 8001658:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 800165a:	062d      	lsls	r5, r5, #24
 800165c:	d5c9      	bpl.n	80015f2 <HAL_PCD_IRQHandler+0x2ae>
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];

  if (ep->xfer_count > ep->xfer_len)
 800165e:	e9d8 2314 	ldrd	r2, r3, [r8, #80]	; 0x50
 8001662:	4293      	cmp	r3, r2
 8001664:	d8c5      	bhi.n	80015f2 <HAL_PCD_IRQHandler+0x2ae>
  {
    return HAL_ERROR;
  }

  len = ep->xfer_len - ep->xfer_count;
 8001666:	1ad5      	subs	r5, r2, r3

  if (len > ep->maxpacket)
 8001668:	f8d8 0044 	ldr.w	r0, [r8, #68]	; 0x44
    len = ep->maxpacket;
  }

  len32b = (len + 3U) / 4U;

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800166c:	eb07 114b 	add.w	r1, r7, fp, lsl #5
  len32b = (len + 3U) / 4U;
 8001670:	4285      	cmp	r5, r0
 8001672:	46ac      	mov	ip, r5
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8001674:	f501 6110 	add.w	r1, r1, #2304	; 0x900
  len32b = (len + 3U) / 4U;
 8001678:	bf28      	it	cs
 800167a:	4684      	movcs	ip, r0
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800167c:	9106      	str	r1, [sp, #24]
 800167e:	6989      	ldr	r1, [r1, #24]
  len32b = (len + 3U) / 4U;
 8001680:	f10c 0c03 	add.w	ip, ip, #3
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8001684:	b289      	uxth	r1, r1
 8001686:	ebb1 0f9c 	cmp.w	r1, ip, lsr #2
 800168a:	d335      	bcc.n	80016f8 <HAL_PCD_IRQHandler+0x3b4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 800168c:	4293      	cmp	r3, r2
 800168e:	d233      	bcs.n	80016f8 <HAL_PCD_IRQHandler+0x3b4>
 8001690:	b392      	cbz	r2, 80016f8 <HAL_PCD_IRQHandler+0x3b4>
 8001692:	f8cd b01c 	str.w	fp, [sp, #28]
 8001696:	f8d8 1048 	ldr.w	r1, [r8, #72]	; 0x48
 800169a:	f8dd b018 	ldr.w	fp, [sp, #24]
 800169e:	e00b      	b.n	80016b8 <HAL_PCD_IRQHandler+0x374>
 80016a0:	f8d8 2050 	ldr.w	r2, [r8, #80]	; 0x50
 80016a4:	429a      	cmp	r2, r3
 80016a6:	eba2 0503 	sub.w	r5, r2, r3
 80016aa:	f240 817e 	bls.w	80019aa <HAL_PCD_IRQHandler+0x666>
 80016ae:	2a00      	cmp	r2, #0
 80016b0:	f000 817b 	beq.w	80019aa <HAL_PCD_IRQHandler+0x666>
 80016b4:	f8d8 0044 	ldr.w	r0, [r8, #68]	; 0x44
 80016b8:	4285      	cmp	r5, r0
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 80016ba:	4632      	mov	r2, r6
 80016bc:	bf28      	it	cs
 80016be:	4605      	movcs	r5, r0
 80016c0:	7c20      	ldrb	r0, [r4, #16]
 80016c2:	b2ab      	uxth	r3, r5
 80016c4:	9000      	str	r0, [sp, #0]
 80016c6:	4638      	mov	r0, r7
 80016c8:	f002 fd52 	bl	8004170 <USB_WritePacket>
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80016cc:	f8db 2018 	ldr.w	r2, [fp, #24]
                          (uint8_t)hpcd->Init.dma_enable);

    ep->xfer_buff  += len;
 80016d0:	f8d8 1048 	ldr.w	r1, [r8, #72]	; 0x48
    len32b = (len + 3U) / 4U;
 80016d4:	1ce8      	adds	r0, r5, #3
    ep->xfer_count += len;
 80016d6:	f8d8 3054 	ldr.w	r3, [r8, #84]	; 0x54
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80016da:	b292      	uxth	r2, r2
    ep->xfer_buff  += len;
 80016dc:	4429      	add	r1, r5
    ep->xfer_count += len;
 80016de:	442b      	add	r3, r5
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80016e0:	ebb2 0f90 	cmp.w	r2, r0, lsr #2
    ep->xfer_buff  += len;
 80016e4:	f8c8 1048 	str.w	r1, [r8, #72]	; 0x48
    ep->xfer_count += len;
 80016e8:	f8c8 3054 	str.w	r3, [r8, #84]	; 0x54
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80016ec:	d2d8      	bcs.n	80016a0 <HAL_PCD_IRQHandler+0x35c>
 80016ee:	f8dd b01c 	ldr.w	fp, [sp, #28]
 80016f2:	f8d8 2050 	ldr.w	r2, [r8, #80]	; 0x50
 80016f6:	6827      	ldr	r7, [r4, #0]
  }

  if (ep->xfer_len <= ep->xfer_count)
 80016f8:	429a      	cmp	r2, r3
 80016fa:	f200 815a 	bhi.w	80019b2 <HAL_PCD_IRQHandler+0x66e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80016fe:	f50a 6100 	add.w	r1, sl, #2048	; 0x800
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8001702:	f00b 020f 	and.w	r2, fp, #15
 8001706:	2001      	movs	r0, #1
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001708:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800170a:	46ba      	mov	sl, r7
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800170c:	fa00 f202 	lsl.w	r2, r0, r2
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001710:	ea23 0302 	bic.w	r3, r3, r2
 8001714:	634b      	str	r3, [r1, #52]	; 0x34
 8001716:	e76c      	b.n	80015f2 <HAL_PCD_IRQHandler+0x2ae>
      HAL_PCD_ConnectCallback(hpcd);
 8001718:	4620      	mov	r0, r4
 800171a:	f007 fa13 	bl	8008b44 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 800171e:	6820      	ldr	r0, [r4, #0]
 8001720:	6943      	ldr	r3, [r0, #20]
 8001722:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8001726:	6143      	str	r3, [r0, #20]
 8001728:	e699      	b.n	800145e <HAL_PCD_IRQHandler+0x11a>
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 800172a:	f002 fdd5 	bl	80042d8 <USB_ReadDevAllOutEpInterrupt>
      while (ep_intr != 0U)
 800172e:	4607      	mov	r7, r0
 8001730:	2800      	cmp	r0, #0
 8001732:	f000 8140 	beq.w	80019b6 <HAL_PCD_IRQHandler+0x672>
 8001736:	6820      	ldr	r0, [r4, #0]
      epnum = 0U;
 8001738:	f04f 0b00 	mov.w	fp, #0
 800173c:	f505 6a30 	add.w	sl, r5, #2816	; 0xb00
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 8001740:	e9cd 6503 	strd	r6, r5, [sp, #12]
 8001744:	e004      	b.n	8001750 <HAL_PCD_IRQHandler+0x40c>
      while (ep_intr != 0U)
 8001746:	087f      	lsrs	r7, r7, #1
        epnum++;
 8001748:	f10b 0b01 	add.w	fp, fp, #1
      while (ep_intr != 0U)
 800174c:	f000 8082 	beq.w	8001854 <HAL_PCD_IRQHandler+0x510>
        if ((ep_intr & 0x1U) != 0U)
 8001750:	07fd      	lsls	r5, r7, #31
 8001752:	d5f8      	bpl.n	8001746 <HAL_PCD_IRQHandler+0x402>
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001754:	fa5f f68b 	uxtb.w	r6, fp
 8001758:	4631      	mov	r1, r6
 800175a:	f002 fdcd 	bl	80042f8 <USB_ReadDevOutEPInterrupt>
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 800175e:	f010 0f01 	tst.w	r0, #1
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8001762:	4680      	mov	r8, r0
          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8001764:	d179      	bne.n	800185a <HAL_PCD_IRQHandler+0x516>
 8001766:	f000 0308 	and.w	r3, r0, #8
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 800176a:	2b00      	cmp	r3, #0
 800176c:	f040 809a 	bne.w	80018a4 <HAL_PCD_IRQHandler+0x560>
 8001770:	6820      	ldr	r0, [r4, #0]
          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8001772:	f018 0f10 	tst.w	r8, #16
 8001776:	d003      	beq.n	8001780 <HAL_PCD_IRQHandler+0x43c>
 8001778:	eb0a 134b 	add.w	r3, sl, fp, lsl #5
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800177c:	2210      	movs	r2, #16
 800177e:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8001780:	f018 0f20 	tst.w	r8, #32
 8001784:	d007      	beq.n	8001796 <HAL_PCD_IRQHandler+0x452>
            if (hpcd->Init.dma_enable == 1U)
 8001786:	6921      	ldr	r1, [r4, #16]
 8001788:	2901      	cmp	r1, #1
 800178a:	f000 8108 	beq.w	800199e <HAL_PCD_IRQHandler+0x65a>
 800178e:	eb0a 134b 	add.w	r3, sl, fp, lsl #5
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8001792:	2220      	movs	r2, #32
 8001794:	609a      	str	r2, [r3, #8]
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 8001796:	f418 5f00 	tst.w	r8, #8192	; 0x2000
 800179a:	d0d4      	beq.n	8001746 <HAL_PCD_IRQHandler+0x402>
 800179c:	eb0a 134b 	add.w	r3, sl, fp, lsl #5
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 80017a0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80017a4:	609a      	str	r2, [r3, #8]
 80017a6:	e7ce      	b.n	8001746 <HAL_PCD_IRQHandler+0x402>
      HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 80017a8:	4620      	mov	r0, r4
 80017aa:	fa5f f18b 	uxtb.w	r1, fp
 80017ae:	f007 f9c5 	bl	8008b3c <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 80017b2:	6820      	ldr	r0, [r4, #0]
 80017b4:	6943      	ldr	r3, [r0, #20]
 80017b6:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80017ba:	6143      	str	r3, [r0, #20]
 80017bc:	e643      	b.n	8001446 <HAL_PCD_IRQHandler+0x102>
      HAL_PCD_SOFCallback(hpcd);
 80017be:	4620      	mov	r0, r4
 80017c0:	f007 f982 	bl	8008ac8 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 80017c4:	6820      	ldr	r0, [r4, #0]
 80017c6:	6943      	ldr	r3, [r0, #20]
 80017c8:	f003 0308 	and.w	r3, r3, #8
 80017cc:	6143      	str	r3, [r0, #20]
 80017ce:	e634      	b.n	800143a <HAL_PCD_IRQHandler+0xf6>
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 80017d0:	4620      	mov	r0, r4
 80017d2:	fa5f f18b 	uxtb.w	r1, fp
 80017d6:	f007 f9ad 	bl	8008b34 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 80017da:	6820      	ldr	r0, [r4, #0]
 80017dc:	6943      	ldr	r3, [r0, #20]
 80017de:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80017e2:	6143      	str	r3, [r0, #20]
 80017e4:	e635      	b.n	8001452 <HAL_PCD_IRQHandler+0x10e>
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80017e6:	9b04      	ldr	r3, [sp, #16]
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 80017e8:	2701      	movs	r7, #1
 80017ea:	f00b 000f 	and.w	r0, fp, #15
 80017ee:	9a03      	ldr	r2, [sp, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80017f0:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 80017f4:	fa07 f000 	lsl.w	r0, r7, r0
 80017f8:	eb02 124b 	add.w	r2, r2, fp, lsl #5
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80017fc:	ea21 0100 	bic.w	r1, r1, r0
            if (hpcd->Init.dma_enable == 1U)
 8001800:	6920      	ldr	r0, [r4, #16]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8001802:	f8c3 1834 	str.w	r1, [r3, #2100]	; 0x834
            if (hpcd->Init.dma_enable == 1U)
 8001806:	42b8      	cmp	r0, r7
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 8001808:	4613      	mov	r3, r2
 800180a:	609f      	str	r7, [r3, #8]
            if (hpcd->Init.dma_enable == 1U)
 800180c:	d104      	bne.n	8001818 <HAL_PCD_IRQHandler+0x4d4>
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 800180e:	e9d8 2311 	ldrd	r2, r3, [r8, #68]	; 0x44
 8001812:	4413      	add	r3, r2
 8001814:	f8c8 3048 	str.w	r3, [r8, #72]	; 0x48
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8001818:	4631      	mov	r1, r6
 800181a:	4620      	mov	r0, r4
 800181c:	f007 f94a 	bl	8008ab4 <HAL_PCD_DataInStageCallback>
            if (hpcd->Init.dma_enable == 1U)
 8001820:	6923      	ldr	r3, [r4, #16]
 8001822:	6827      	ldr	r7, [r4, #0]
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 8001824:	2b01      	cmp	r3, #1
 8001826:	d102      	bne.n	800182e <HAL_PCD_IRQHandler+0x4ea>
 8001828:	f1bb 0f00 	cmp.w	fp, #0
 800182c:	d001      	beq.n	8001832 <HAL_PCD_IRQHandler+0x4ee>
 800182e:	46ba      	mov	sl, r7
 8001830:	e6f7      	b.n	8001622 <HAL_PCD_IRQHandler+0x2de>
 8001832:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8001834:	46ba      	mov	sl, r7
 8001836:	2b00      	cmp	r3, #0
 8001838:	f47f aef3 	bne.w	8001622 <HAL_PCD_IRQHandler+0x2de>
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800183c:	4638      	mov	r0, r7
 800183e:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 8001842:	2101      	movs	r1, #1
 8001844:	f002 fd96 	bl	8004374 <USB_EP0_OutStart>
 8001848:	6827      	ldr	r7, [r4, #0]
 800184a:	46ba      	mov	sl, r7
 800184c:	e6e9      	b.n	8001622 <HAL_PCD_IRQHandler+0x2de>
 800184e:	e9dd 5604 	ldrd	r5, r6, [sp, #16]
 8001852:	e5a2      	b.n	800139a <HAL_PCD_IRQHandler+0x56>
 8001854:	e9dd 6503 	ldrd	r6, r5, [sp, #12]
 8001858:	e598      	b.n	800138c <HAL_PCD_IRQHandler+0x48>
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800185a:	6820      	ldr	r0, [r4, #0]
 800185c:	ea4f 194b 	mov.w	r9, fp, lsl #5
  if (hpcd->Init.dma_enable == 1U)
 8001860:	6921      	ldr	r1, [r4, #16]
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8001862:	2201      	movs	r2, #1
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8001864:	f500 6e30 	add.w	lr, r0, #2816	; 0xb00
 8001868:	eb0a 0509 	add.w	r5, sl, r9
  if (hpcd->Init.dma_enable == 1U)
 800186c:	2901      	cmp	r1, #1
 800186e:	f008 0308 	and.w	r3, r8, #8
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8001872:	44f1      	add	r9, lr
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 8001874:	60aa      	str	r2, [r5, #8]
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8001876:	f8d0 e040 	ldr.w	lr, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800187a:	f8d9 2008 	ldr.w	r2, [r9, #8]
  if (hpcd->Init.dma_enable == 1U)
 800187e:	d061      	beq.n	8001944 <HAL_PCD_IRQHandler+0x600>
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8001880:	4972      	ldr	r1, [pc, #456]	; (8001a4c <HAL_PCD_IRQHandler+0x708>)
 8001882:	458e      	cmp	lr, r1
 8001884:	d107      	bne.n	8001896 <HAL_PCD_IRQHandler+0x552>
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 8001886:	0411      	lsls	r1, r2, #16
 8001888:	f100 80d0 	bmi.w	8001a2c <HAL_PCD_IRQHandler+0x6e8>
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 800188c:	0691      	lsls	r1, r2, #26
 800188e:	d502      	bpl.n	8001896 <HAL_PCD_IRQHandler+0x552>
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8001890:	2120      	movs	r1, #32
 8001892:	f8c9 1008 	str.w	r1, [r9, #8]
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8001896:	4631      	mov	r1, r6
 8001898:	4620      	mov	r0, r4
 800189a:	9305      	str	r3, [sp, #20]
 800189c:	f007 f900 	bl	8008aa0 <HAL_PCD_DataOutStageCallback>
 80018a0:	9b05      	ldr	r3, [sp, #20]
 80018a2:	e762      	b.n	800176a <HAL_PCD_IRQHandler+0x426>
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80018a4:	6823      	ldr	r3, [r4, #0]
 80018a6:	ea4f 194b 	mov.w	r9, fp, lsl #5
  if (hpcd->Init.dma_enable == 1U)
 80018aa:	6922      	ldr	r2, [r4, #16]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80018ac:	f503 6130 	add.w	r1, r3, #2816	; 0xb00
 80018b0:	eb0a 0509 	add.w	r5, sl, r9
  if (hpcd->Init.dma_enable == 1U)
 80018b4:	2a01      	cmp	r2, #1
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 80018b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 80018b8:	4489      	add	r9, r1
 80018ba:	f8d9 1008 	ldr.w	r1, [r9, #8]
  if (hpcd->Init.dma_enable == 1U)
 80018be:	d03a      	beq.n	8001936 <HAL_PCD_IRQHandler+0x5f2>
    if ((gSNPSiD == USB_OTG_CORE_ID_310A) &&
 80018c0:	4a62      	ldr	r2, [pc, #392]	; (8001a4c <HAL_PCD_IRQHandler+0x708>)
 80018c2:	4293      	cmp	r3, r2
 80018c4:	d01c      	beq.n	8001900 <HAL_PCD_IRQHandler+0x5bc>
  HAL_PCD_SetupStageCallback(hpcd);
 80018c6:	4620      	mov	r0, r4
 80018c8:	9305      	str	r3, [sp, #20]
 80018ca:	f007 f8e3 	bl	8008a94 <HAL_PCD_SetupStageCallback>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 80018ce:	4a60      	ldr	r2, [pc, #384]	; (8001a50 <HAL_PCD_IRQHandler+0x70c>)
 80018d0:	9b05      	ldr	r3, [sp, #20]
 80018d2:	4293      	cmp	r3, r2
 80018d4:	d81d      	bhi.n	8001912 <HAL_PCD_IRQHandler+0x5ce>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 80018d6:	2308      	movs	r3, #8
 80018d8:	6820      	ldr	r0, [r4, #0]
 80018da:	60ab      	str	r3, [r5, #8]
 80018dc:	e749      	b.n	8001772 <HAL_PCD_IRQHandler+0x42e>
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 80018de:	697a      	ldr	r2, [r7, #20]
 80018e0:	f242 032b 	movw	r3, #8235	; 0x202b
 80018e4:	4313      	orrs	r3, r2
 80018e6:	617b      	str	r3, [r7, #20]
        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 80018e8:	693b      	ldr	r3, [r7, #16]
 80018ea:	f043 030b 	orr.w	r3, r3, #11
 80018ee:	613b      	str	r3, [r7, #16]
 80018f0:	e65b      	b.n	80015aa <HAL_PCD_IRQHandler+0x266>
        hpcd->LPM_State = LPM_L0;
 80018f2:	2100      	movs	r1, #0
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 80018f4:	4620      	mov	r0, r4
        hpcd->LPM_State = LPM_L0;
 80018f6:	f884 13f4 	strb.w	r1, [r4, #1012]	; 0x3f4
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 80018fa:	f007 f9e9 	bl	8008cd0 <HAL_PCDEx_LPM_Callback>
 80018fe:	e5fc      	b.n	80014fa <HAL_PCD_IRQHandler+0x1b6>
    if ((gSNPSiD == USB_OTG_CORE_ID_310A) &&
 8001900:	040a      	lsls	r2, r1, #16
 8001902:	d503      	bpl.n	800190c <HAL_PCD_IRQHandler+0x5c8>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8001904:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001908:	f8c9 3008 	str.w	r3, [r9, #8]
  HAL_PCD_SetupStageCallback(hpcd);
 800190c:	4620      	mov	r0, r4
 800190e:	f007 f8c1 	bl	8008a94 <HAL_PCD_SetupStageCallback>
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 8001912:	6921      	ldr	r1, [r4, #16]
 8001914:	2901      	cmp	r1, #1
 8001916:	d1de      	bne.n	80018d6 <HAL_PCD_IRQHandler+0x592>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8001918:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 800191c:	6820      	ldr	r0, [r4, #0]
 800191e:	f002 fd29 	bl	8004374 <USB_EP0_OutStart>
 8001922:	e7d8      	b.n	80018d6 <HAL_PCD_IRQHandler+0x592>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8001924:	2220      	movs	r2, #32
 8001926:	f8c9 2008 	str.w	r2, [r9, #8]
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 800192a:	2b00      	cmp	r3, #0
 800192c:	f43f af21 	beq.w	8001772 <HAL_PCD_IRQHandler+0x42e>
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8001930:	6c03      	ldr	r3, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8001932:	f8d9 1008 	ldr.w	r1, [r9, #8]
    if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8001936:	4a46      	ldr	r2, [pc, #280]	; (8001a50 <HAL_PCD_IRQHandler+0x70c>)
 8001938:	4293      	cmp	r3, r2
 800193a:	d8e1      	bhi.n	8001900 <HAL_PCD_IRQHandler+0x5bc>
  HAL_PCD_SetupStageCallback(hpcd);
 800193c:	4620      	mov	r0, r4
 800193e:	f007 f8a9 	bl	8008a94 <HAL_PCD_SetupStageCallback>
 8001942:	e7c8      	b.n	80018d6 <HAL_PCD_IRQHandler+0x592>
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 8001944:	0711      	lsls	r1, r2, #28
 8001946:	d53d      	bpl.n	80019c4 <HAL_PCD_IRQHandler+0x680>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8001948:	4941      	ldr	r1, [pc, #260]	; (8001a50 <HAL_PCD_IRQHandler+0x70c>)
 800194a:	458e      	cmp	lr, r1
 800194c:	d905      	bls.n	800195a <HAL_PCD_IRQHandler+0x616>
 800194e:	0410      	lsls	r0, r2, #16
 8001950:	d503      	bpl.n	800195a <HAL_PCD_IRQHandler+0x616>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8001952:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8001956:	f8c9 2008 	str.w	r2, [r9, #8]
      HAL_PCD_SetupStageCallback(hpcd);
 800195a:	4620      	mov	r0, r4
 800195c:	9305      	str	r3, [sp, #20]
 800195e:	f007 f899 	bl	8008a94 <HAL_PCD_SetupStageCallback>
      (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8001962:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 8001966:	2101      	movs	r1, #1
 8001968:	6820      	ldr	r0, [r4, #0]
 800196a:	f002 fd03 	bl	8004374 <USB_EP0_OutStart>
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 800196e:	2208      	movs	r2, #8
 8001970:	9b05      	ldr	r3, [sp, #20]
 8001972:	f8c9 2008 	str.w	r2, [r9, #8]
 8001976:	e6f8      	b.n	800176a <HAL_PCD_IRQHandler+0x426>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001978:	ebc7 07c7 	rsb	r7, r7, r7, lsl #3
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 800197c:	2208      	movs	r2, #8
 800197e:	f504 7171 	add.w	r1, r4, #964	; 0x3c4
 8001982:	4628      	mov	r0, r5
 8001984:	f002 fc0a 	bl	800419c <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 8001988:	f3c6 130a 	ubfx	r3, r6, #4, #11
 800198c:	eb04 0287 	add.w	r2, r4, r7, lsl #2
 8001990:	6820      	ldr	r0, [r4, #0]
 8001992:	f8d2 1214 	ldr.w	r1, [r2, #532]	; 0x214
 8001996:	440b      	add	r3, r1
 8001998:	f8c2 3214 	str.w	r3, [r2, #532]	; 0x214
 800199c:	e543      	b.n	8001426 <HAL_PCD_IRQHandler+0xe2>
              (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800199e:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 80019a2:	f002 fce7 	bl	8004374 <USB_EP0_OutStart>
 80019a6:	6820      	ldr	r0, [r4, #0]
 80019a8:	e6f1      	b.n	800178e <HAL_PCD_IRQHandler+0x44a>
 80019aa:	f8dd b01c 	ldr.w	fp, [sp, #28]
 80019ae:	6827      	ldr	r7, [r4, #0]
 80019b0:	e6a2      	b.n	80016f8 <HAL_PCD_IRQHandler+0x3b4>
 80019b2:	46ba      	mov	sl, r7
 80019b4:	e61d      	b.n	80015f2 <HAL_PCD_IRQHandler+0x2ae>
      epnum = 0U;
 80019b6:	4683      	mov	fp, r0
 80019b8:	6820      	ldr	r0, [r4, #0]
 80019ba:	e4e7      	b.n	800138c <HAL_PCD_IRQHandler+0x48>
      epnum = 0U;
 80019bc:	4683      	mov	fp, r0
 80019be:	f8d4 a000 	ldr.w	sl, [r4]
 80019c2:	e4ea      	b.n	800139a <HAL_PCD_IRQHandler+0x56>
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 80019c4:	0691      	lsls	r1, r2, #26
 80019c6:	d4ad      	bmi.n	8001924 <HAL_PCD_IRQHandler+0x5e0>
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 80019c8:	f012 0f28 	tst.w	r2, #40	; 0x28
 80019cc:	d1ad      	bne.n	800192a <HAL_PCD_IRQHandler+0x5e6>
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 80019ce:	4920      	ldr	r1, [pc, #128]	; (8001a50 <HAL_PCD_IRQHandler+0x70c>)
 80019d0:	458e      	cmp	lr, r1
 80019d2:	d901      	bls.n	80019d8 <HAL_PCD_IRQHandler+0x694>
 80019d4:	0412      	lsls	r2, r2, #16
 80019d6:	d434      	bmi.n	8001a42 <HAL_PCD_IRQHandler+0x6fe>
 80019d8:	f04f 0c1c 	mov.w	ip, #28
          (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 80019dc:	f8d9 e010 	ldr.w	lr, [r9, #16]
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80019e0:	4631      	mov	r1, r6
 80019e2:	4620      	mov	r0, r4
 80019e4:	fb0c 4c0b 	mla	ip, ip, fp, r4
          (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 80019e8:	f3ce 0e12 	ubfx	lr, lr, #0, #19
 80019ec:	9305      	str	r3, [sp, #20]
          hpcd->OUT_ep[epnum].maxpacket -
 80019ee:	f8dc 2204 	ldr.w	r2, [ip, #516]	; 0x204
        hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;
 80019f2:	f8dc 5208 	ldr.w	r5, [ip, #520]	; 0x208
          hpcd->OUT_ep[epnum].maxpacket -
 80019f6:	eba2 0e0e 	sub.w	lr, r2, lr
        hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;
 80019fa:	442a      	add	r2, r5
        hpcd->OUT_ep[epnum].xfer_count =
 80019fc:	f8cc e214 	str.w	lr, [ip, #532]	; 0x214
        hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;
 8001a00:	f8cc 2208 	str.w	r2, [ip, #520]	; 0x208
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8001a04:	f007 f84c 	bl	8008aa0 <HAL_PCD_DataOutStageCallback>
        if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8001a08:	9b05      	ldr	r3, [sp, #20]
 8001a0a:	f1bb 0f00 	cmp.w	fp, #0
 8001a0e:	f47f aeac 	bne.w	800176a <HAL_PCD_IRQHandler+0x426>
 8001a12:	f8d4 2210 	ldr.w	r2, [r4, #528]	; 0x210
 8001a16:	2a00      	cmp	r2, #0
 8001a18:	f47f aea7 	bne.w	800176a <HAL_PCD_IRQHandler+0x426>
          (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8001a1c:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 8001a20:	2101      	movs	r1, #1
 8001a22:	6820      	ldr	r0, [r4, #0]
 8001a24:	f002 fca6 	bl	8004374 <USB_EP0_OutStart>
 8001a28:	9b05      	ldr	r3, [sp, #20]
 8001a2a:	e69e      	b.n	800176a <HAL_PCD_IRQHandler+0x426>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8001a2c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8001a30:	f8c9 2008 	str.w	r2, [r9, #8]
          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8001a34:	2b00      	cmp	r3, #0
 8001a36:	f43f ae9c 	beq.w	8001772 <HAL_PCD_IRQHandler+0x42e>
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8001a3a:	6c03      	ldr	r3, [r0, #64]	; 0x40
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8001a3c:	f8d9 1008 	ldr.w	r1, [r9, #8]
 8001a40:	e73e      	b.n	80018c0 <HAL_PCD_IRQHandler+0x57c>
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8001a42:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8001a46:	f8c9 2008 	str.w	r2, [r9, #8]
 8001a4a:	e76e      	b.n	800192a <HAL_PCD_IRQHandler+0x5e6>
 8001a4c:	4f54310a 	.word	0x4f54310a
 8001a50:	4f54300a 	.word	0x4f54300a

08001a54 <HAL_PCD_SetAddress>:
  __HAL_LOCK(hpcd);
 8001a54:	f890 23bc 	ldrb.w	r2, [r0, #956]	; 0x3bc
 8001a58:	2a01      	cmp	r2, #1
 8001a5a:	d00d      	beq.n	8001a78 <HAL_PCD_SetAddress+0x24>
 8001a5c:	2201      	movs	r2, #1
{
 8001a5e:	b510      	push	{r4, lr}
 8001a60:	4604      	mov	r4, r0
  hpcd->USB_Address = address;
 8001a62:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8001a66:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8001a68:	f884 23bc 	strb.w	r2, [r4, #956]	; 0x3bc
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8001a6c:	f002 fc06 	bl	800427c <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8001a70:	2000      	movs	r0, #0
 8001a72:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8001a76:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hpcd);
 8001a78:	2002      	movs	r0, #2
}
 8001a7a:	4770      	bx	lr

08001a7c <HAL_PCD_EP_Open>:
{
 8001a7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001a7e:	f001 040f 	and.w	r4, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 8001a82:	0609      	lsls	r1, r1, #24
 8001a84:	ebc4 05c4 	rsb	r5, r4, r4, lsl #3
 8001a88:	ea4f 0585 	mov.w	r5, r5, lsl #2
 8001a8c:	d422      	bmi.n	8001ad4 <HAL_PCD_EP_Open+0x58>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001a8e:	f505 71fe 	add.w	r1, r5, #508	; 0x1fc
    ep->is_in = 0U;
 8001a92:	ebc4 05c4 	rsb	r5, r4, r4, lsl #3
 8001a96:	2600      	movs	r6, #0
 8001a98:	eb00 0585 	add.w	r5, r0, r5, lsl #2
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001a9c:	4401      	add	r1, r0
    ep->is_in = 0U;
 8001a9e:	f885 61fd 	strb.w	r6, [r5, #509]	; 0x1fd
  if (ep->is_in != 0U)
 8001aa2:	784d      	ldrb	r5, [r1, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8001aa4:	700c      	strb	r4, [r1, #0]
  ep->maxpacket = ep_mps;
 8001aa6:	608a      	str	r2, [r1, #8]
  ep->type = ep_type;
 8001aa8:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in != 0U)
 8001aaa:	b105      	cbz	r5, 8001aae <HAL_PCD_EP_Open+0x32>
    ep->tx_fifo_num = ep->num;
 8001aac:	80cc      	strh	r4, [r1, #6]
  if (ep_type == EP_TYPE_BULK)
 8001aae:	2b02      	cmp	r3, #2
 8001ab0:	d101      	bne.n	8001ab6 <HAL_PCD_EP_Open+0x3a>
    ep->data_pid_start = 0U;
 8001ab2:	2300      	movs	r3, #0
 8001ab4:	710b      	strb	r3, [r1, #4]
  __HAL_LOCK(hpcd);
 8001ab6:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 8001aba:	2b01      	cmp	r3, #1
 8001abc:	d015      	beq.n	8001aea <HAL_PCD_EP_Open+0x6e>
 8001abe:	4604      	mov	r4, r0
 8001ac0:	2301      	movs	r3, #1
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8001ac2:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8001ac4:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8001ac8:	f002 f94e 	bl	8003d68 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8001acc:	2000      	movs	r0, #0
 8001ace:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8001ad2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ep->is_in = 1U;
 8001ad4:	ebc4 06c4 	rsb	r6, r4, r4, lsl #3
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001ad8:	f105 013c 	add.w	r1, r5, #60	; 0x3c
    ep->is_in = 1U;
 8001adc:	2701      	movs	r7, #1
 8001ade:	eb00 0586 	add.w	r5, r0, r6, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001ae2:	4401      	add	r1, r0
    ep->is_in = 1U;
 8001ae4:	f885 703d 	strb.w	r7, [r5, #61]	; 0x3d
 8001ae8:	e7db      	b.n	8001aa2 <HAL_PCD_EP_Open+0x26>
  __HAL_LOCK(hpcd);
 8001aea:	2002      	movs	r0, #2
}
 8001aec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001aee:	bf00      	nop

08001af0 <HAL_PCD_EP_Close>:
{
 8001af0:	f001 020f 	and.w	r2, r1, #15
  if ((ep_addr & 0x80U) == 0x80U)
 8001af4:	0609      	lsls	r1, r1, #24
{
 8001af6:	b538      	push	{r3, r4, r5, lr}
 8001af8:	ebc2 03c2 	rsb	r3, r2, r2, lsl #3
 8001afc:	ea4f 0383 	mov.w	r3, r3, lsl #2
  if ((ep_addr & 0x80U) == 0x80U)
 8001b00:	d419      	bmi.n	8001b36 <HAL_PCD_EP_Close+0x46>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001b02:	f503 71fe 	add.w	r1, r3, #508	; 0x1fc
    ep->is_in = 0U;
 8001b06:	ebc2 03c2 	rsb	r3, r2, r2, lsl #3
 8001b0a:	2400      	movs	r4, #0
 8001b0c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001b10:	4401      	add	r1, r0
    ep->is_in = 0U;
 8001b12:	f883 41fd 	strb.w	r4, [r3, #509]	; 0x1fd
  ep->num   = ep_addr & EP_ADDR_MSK;
 8001b16:	700a      	strb	r2, [r1, #0]
  __HAL_LOCK(hpcd);
 8001b18:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 8001b1c:	2b01      	cmp	r3, #1
 8001b1e:	d019      	beq.n	8001b54 <HAL_PCD_EP_Close+0x64>
 8001b20:	4604      	mov	r4, r0
 8001b22:	2301      	movs	r3, #1
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8001b24:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8001b26:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8001b2a:	f002 f95f 	bl	8003dec <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8001b2e:	2000      	movs	r0, #0
 8001b30:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8001b34:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001b36:	f103 013c 	add.w	r1, r3, #60	; 0x3c
    ep->is_in = 1U;
 8001b3a:	ebc2 04c2 	rsb	r4, r2, r2, lsl #3
 8001b3e:	2501      	movs	r5, #1
 8001b40:	eb00 0384 	add.w	r3, r0, r4, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001b44:	4401      	add	r1, r0
    ep->is_in = 1U;
 8001b46:	f883 503d 	strb.w	r5, [r3, #61]	; 0x3d
  ep->num   = ep_addr & EP_ADDR_MSK;
 8001b4a:	700a      	strb	r2, [r1, #0]
  __HAL_LOCK(hpcd);
 8001b4c:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 8001b50:	2b01      	cmp	r3, #1
 8001b52:	d1e5      	bne.n	8001b20 <HAL_PCD_EP_Close+0x30>
 8001b54:	2002      	movs	r0, #2
}
 8001b56:	bd38      	pop	{r3, r4, r5, pc}

08001b58 <HAL_PCD_EP_Receive>:
{
 8001b58:	b570      	push	{r4, r5, r6, lr}
 8001b5a:	f001 050f 	and.w	r5, r1, #15
  ep->xfer_count = 0U;
 8001b5e:	2600      	movs	r6, #0
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001b60:	211c      	movs	r1, #28
  ep->xfer_buff = pBuf;
 8001b62:	ebc5 04c5 	rsb	r4, r5, r5, lsl #3
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001b66:	fb01 0105 	mla	r1, r1, r5, r0
  ep->xfer_buff = pBuf;
 8001b6a:	eb00 0484 	add.w	r4, r0, r4, lsl #2
  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001b6e:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
  ep->xfer_buff = pBuf;
 8001b72:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
  ep->xfer_len = len;
 8001b76:	f8c4 3210 	str.w	r3, [r4, #528]	; 0x210
  ep->num = ep_addr & EP_ADDR_MSK;
 8001b7a:	f884 51fc 	strb.w	r5, [r4, #508]	; 0x1fc
  ep->xfer_count = 0U;
 8001b7e:	f8c4 6214 	str.w	r6, [r4, #532]	; 0x214
  ep->is_in = 0U;
 8001b82:	f884 61fd 	strb.w	r6, [r4, #509]	; 0x1fd
  if (hpcd->Init.dma_enable == 1U)
 8001b86:	6903      	ldr	r3, [r0, #16]
 8001b88:	6800      	ldr	r0, [r0, #0]
 8001b8a:	2b01      	cmp	r3, #1
    ep->dma_addr = (uint32_t)pBuf;
 8001b8c:	bf08      	it	eq
 8001b8e:	f8c4 220c 	streq.w	r2, [r4, #524]	; 0x20c
 8001b92:	b2da      	uxtb	r2, r3
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8001b94:	b11d      	cbz	r5, 8001b9e <HAL_PCD_EP_Receive+0x46>
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001b96:	f002 f95d 	bl	8003e54 <USB_EPStartXfer>
}
 8001b9a:	2000      	movs	r0, #0
 8001b9c:	bd70      	pop	{r4, r5, r6, pc}
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001b9e:	f002 fa5b 	bl	8004058 <USB_EP0StartXfer>
}
 8001ba2:	2000      	movs	r0, #0
 8001ba4:	bd70      	pop	{r4, r5, r6, pc}
 8001ba6:	bf00      	nop

08001ba8 <HAL_PCD_EP_GetRxCount>:
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 8001ba8:	f001 010f 	and.w	r1, r1, #15
 8001bac:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8001bb0:	eb00 0181 	add.w	r1, r0, r1, lsl #2
}
 8001bb4:	f8d1 0214 	ldr.w	r0, [r1, #532]	; 0x214
 8001bb8:	4770      	bx	lr
 8001bba:	bf00      	nop

08001bbc <HAL_PCD_EP_Transmit>:
{
 8001bbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001bbe:	f001 050f 	and.w	r5, r1, #15
  ep->is_in = 1U;
 8001bc2:	2601      	movs	r6, #1
  ep->xfer_count = 0U;
 8001bc4:	2700      	movs	r7, #0
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001bc6:	211c      	movs	r1, #28
  ep->xfer_buff = pBuf;
 8001bc8:	ebc5 04c5 	rsb	r4, r5, r5, lsl #3
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001bcc:	fb01 0105 	mla	r1, r1, r5, r0
  ep->xfer_buff = pBuf;
 8001bd0:	eb00 0484 	add.w	r4, r0, r4, lsl #2
  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001bd4:	313c      	adds	r1, #60	; 0x3c
  ep->xfer_buff = pBuf;
 8001bd6:	64a2      	str	r2, [r4, #72]	; 0x48
  ep->xfer_len = len;
 8001bd8:	6523      	str	r3, [r4, #80]	; 0x50
  ep->num = ep_addr & EP_ADDR_MSK;
 8001bda:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
  ep->xfer_count = 0U;
 8001bde:	6567      	str	r7, [r4, #84]	; 0x54
  ep->is_in = 1U;
 8001be0:	f884 603d 	strb.w	r6, [r4, #61]	; 0x3d
  if (hpcd->Init.dma_enable == 1U)
 8001be4:	6903      	ldr	r3, [r0, #16]
 8001be6:	6800      	ldr	r0, [r0, #0]
 8001be8:	42b3      	cmp	r3, r6
    ep->dma_addr = (uint32_t)pBuf;
 8001bea:	bf08      	it	eq
 8001bec:	64e2      	streq	r2, [r4, #76]	; 0x4c
 8001bee:	b2da      	uxtb	r2, r3
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8001bf0:	b11d      	cbz	r5, 8001bfa <HAL_PCD_EP_Transmit+0x3e>
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001bf2:	f002 f92f 	bl	8003e54 <USB_EPStartXfer>
}
 8001bf6:	2000      	movs	r0, #0
 8001bf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8001bfa:	f002 fa2d 	bl	8004058 <USB_EP0StartXfer>
}
 8001bfe:	2000      	movs	r0, #0
 8001c00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001c02:	bf00      	nop

08001c04 <HAL_PCD_EP_SetStall>:
{
 8001c04:	b538      	push	{r3, r4, r5, lr}
  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8001c06:	6843      	ldr	r3, [r0, #4]
 8001c08:	f001 050f 	and.w	r5, r1, #15
 8001c0c:	429d      	cmp	r5, r3
 8001c0e:	d81f      	bhi.n	8001c50 <HAL_PCD_EP_SetStall+0x4c>
  if ((0x80U & ep_addr) == 0x80U)
 8001c10:	060b      	lsls	r3, r1, #24
 8001c12:	d41f      	bmi.n	8001c54 <HAL_PCD_EP_SetStall+0x50>
    ep->is_in = 0U;
 8001c14:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
    ep = &hpcd->OUT_ep[ep_addr];
 8001c18:	241c      	movs	r4, #28
    ep->is_in = 0U;
 8001c1a:	2200      	movs	r2, #0
    ep = &hpcd->OUT_ep[ep_addr];
 8001c1c:	fb04 0101 	mla	r1, r4, r1, r0
    ep->is_in = 0U;
 8001c20:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    ep = &hpcd->OUT_ep[ep_addr];
 8001c24:	f501 71fe 	add.w	r1, r1, #508	; 0x1fc
    ep->is_in = 0U;
 8001c28:	f883 21fd 	strb.w	r2, [r3, #509]	; 0x1fd
  ep->is_stall = 1U;
 8001c2c:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 8001c2e:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 8001c30:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 8001c32:	f890 23bc 	ldrb.w	r2, [r0, #956]	; 0x3bc
 8001c36:	429a      	cmp	r2, r3
 8001c38:	d01e      	beq.n	8001c78 <HAL_PCD_EP_SetStall+0x74>
 8001c3a:	4604      	mov	r4, r0
 8001c3c:	f880 33bc 	strb.w	r3, [r0, #956]	; 0x3bc
  (void)USB_EPSetStall(hpcd->Instance, ep);
 8001c40:	6800      	ldr	r0, [r0, #0]
 8001c42:	f002 fabf 	bl	80041c4 <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8001c46:	b1cd      	cbz	r5, 8001c7c <HAL_PCD_EP_SetStall+0x78>
  __HAL_UNLOCK(hpcd);
 8001c48:	2000      	movs	r0, #0
 8001c4a:	f884 03bc 	strb.w	r0, [r4, #956]	; 0x3bc
}
 8001c4e:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8001c50:	2001      	movs	r0, #1
}
 8001c52:	bd38      	pop	{r3, r4, r5, pc}
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001c54:	211c      	movs	r1, #28
    ep->is_in = 1U;
 8001c56:	ebc5 03c5 	rsb	r3, r5, r5, lsl #3
 8001c5a:	2201      	movs	r2, #1
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001c5c:	fb01 0105 	mla	r1, r1, r5, r0
    ep->is_in = 1U;
 8001c60:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001c64:	313c      	adds	r1, #60	; 0x3c
    ep->is_in = 1U;
 8001c66:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
  ep->is_stall = 1U;
 8001c6a:	2301      	movs	r3, #1
  ep->num = ep_addr & EP_ADDR_MSK;
 8001c6c:	700d      	strb	r5, [r1, #0]
  ep->is_stall = 1U;
 8001c6e:	708b      	strb	r3, [r1, #2]
  __HAL_LOCK(hpcd);
 8001c70:	f890 23bc 	ldrb.w	r2, [r0, #956]	; 0x3bc
 8001c74:	429a      	cmp	r2, r3
 8001c76:	d1e0      	bne.n	8001c3a <HAL_PCD_EP_SetStall+0x36>
 8001c78:	2002      	movs	r0, #2
}
 8001c7a:	bd38      	pop	{r3, r4, r5, pc}
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8001c7c:	f504 7271 	add.w	r2, r4, #964	; 0x3c4
 8001c80:	7c21      	ldrb	r1, [r4, #16]
 8001c82:	6820      	ldr	r0, [r4, #0]
 8001c84:	f002 fb76 	bl	8004374 <USB_EP0_OutStart>
 8001c88:	e7de      	b.n	8001c48 <HAL_PCD_EP_SetStall+0x44>
 8001c8a:	bf00      	nop

08001c8c <HAL_PCD_EP_ClrStall>:
{
 8001c8c:	b538      	push	{r3, r4, r5, lr}
 8001c8e:	f001 020f 	and.w	r2, r1, #15
  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 8001c92:	6843      	ldr	r3, [r0, #4]
 8001c94:	429a      	cmp	r2, r3
 8001c96:	d821      	bhi.n	8001cdc <HAL_PCD_EP_ClrStall+0x50>
 8001c98:	ebc2 03c2 	rsb	r3, r2, r2, lsl #3
  if ((0x80U & ep_addr) == 0x80U)
 8001c9c:	0609      	lsls	r1, r1, #24
 8001c9e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001ca2:	d41d      	bmi.n	8001ce0 <HAL_PCD_EP_ClrStall+0x54>
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001ca4:	f503 73fe 	add.w	r3, r3, #508	; 0x1fc
    ep->is_in = 0U;
 8001ca8:	ebc2 04c2 	rsb	r4, r2, r2, lsl #3
 8001cac:	2500      	movs	r5, #0
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8001cae:	18c1      	adds	r1, r0, r3
    ep->is_in = 0U;
 8001cb0:	eb00 0384 	add.w	r3, r0, r4, lsl #2
 8001cb4:	f883 51fd 	strb.w	r5, [r3, #509]	; 0x1fd
  ep->is_stall = 0U;
 8001cb8:	2500      	movs	r5, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 8001cba:	700a      	strb	r2, [r1, #0]
  ep->is_stall = 0U;
 8001cbc:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 8001cbe:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 8001cc2:	2b01      	cmp	r3, #1
 8001cc4:	d01c      	beq.n	8001d00 <HAL_PCD_EP_ClrStall+0x74>
 8001cc6:	4604      	mov	r4, r0
 8001cc8:	2301      	movs	r3, #1
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8001cca:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hpcd);
 8001ccc:	f884 33bc 	strb.w	r3, [r4, #956]	; 0x3bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 8001cd0:	f002 faa8 	bl	8004224 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 8001cd4:	f884 53bc 	strb.w	r5, [r4, #956]	; 0x3bc
  return HAL_OK;
 8001cd8:	4628      	mov	r0, r5
}
 8001cda:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8001cdc:	2001      	movs	r0, #1
}
 8001cde:	bd38      	pop	{r3, r4, r5, pc}
    ep->is_in = 1U;
 8001ce0:	ebc2 04c2 	rsb	r4, r2, r2, lsl #3
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001ce4:	333c      	adds	r3, #60	; 0x3c
    ep->is_in = 1U;
 8001ce6:	2501      	movs	r5, #1
 8001ce8:	eb00 0484 	add.w	r4, r0, r4, lsl #2
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8001cec:	18c1      	adds	r1, r0, r3
    ep->is_in = 1U;
 8001cee:	f884 503d 	strb.w	r5, [r4, #61]	; 0x3d
  ep->is_stall = 0U;
 8001cf2:	2500      	movs	r5, #0
  ep->num = ep_addr & EP_ADDR_MSK;
 8001cf4:	700a      	strb	r2, [r1, #0]
  ep->is_stall = 0U;
 8001cf6:	708d      	strb	r5, [r1, #2]
  __HAL_LOCK(hpcd);
 8001cf8:	f890 33bc 	ldrb.w	r3, [r0, #956]	; 0x3bc
 8001cfc:	2b01      	cmp	r3, #1
 8001cfe:	d1e2      	bne.n	8001cc6 <HAL_PCD_EP_ClrStall+0x3a>
 8001d00:	2002      	movs	r0, #2
}
 8001d02:	bd38      	pop	{r3, r4, r5, pc}

08001d04 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 8001d04:	b430      	push	{r4, r5}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 8001d06:	6805      	ldr	r5, [r0, #0]
 8001d08:	0412      	lsls	r2, r2, #16
 8001d0a:	6a6c      	ldr	r4, [r5, #36]	; 0x24

  if (fifo == 0U)
 8001d0c:	b1c1      	cbz	r1, 8001d40 <HAL_PCDEx_SetTxFiFo+0x3c>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8001d0e:	6aab      	ldr	r3, [r5, #40]	; 0x28
    for (i = 0U; i < (fifo - 1U); i++)
 8001d10:	3901      	subs	r1, #1
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 8001d12:	eb04 4413 	add.w	r4, r4, r3, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8001d16:	d00b      	beq.n	8001d30 <HAL_PCDEx_SetTxFiFo+0x2c>
 8001d18:	2300      	movs	r3, #0
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8001d1a:	f103 0040 	add.w	r0, r3, #64	; 0x40
    for (i = 0U; i < (fifo - 1U); i++)
 8001d1e:	3301      	adds	r3, #1
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8001d20:	eb05 0080 	add.w	r0, r5, r0, lsl #2
    for (i = 0U; i < (fifo - 1U); i++)
 8001d24:	b2db      	uxtb	r3, r3
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8001d26:	6840      	ldr	r0, [r0, #4]
    for (i = 0U; i < (fifo - 1U); i++)
 8001d28:	428b      	cmp	r3, r1
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 8001d2a:	eb04 4410 	add.w	r4, r4, r0, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 8001d2e:	d3f4      	bcc.n	8001d1a <HAL_PCDEx_SetTxFiFo+0x16>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8001d30:	3140      	adds	r1, #64	; 0x40
 8001d32:	4314      	orrs	r4, r2
  }

  return HAL_OK;
}
 8001d34:	2000      	movs	r0, #0
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8001d36:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 8001d3a:	604c      	str	r4, [r1, #4]
}
 8001d3c:	bc30      	pop	{r4, r5}
 8001d3e:	4770      	bx	lr
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 8001d40:	4314      	orrs	r4, r2
}
 8001d42:	2000      	movs	r0, #0
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 8001d44:	62ac      	str	r4, [r5, #40]	; 0x28
}
 8001d46:	bc30      	pop	{r4, r5}
 8001d48:	4770      	bx	lr
 8001d4a:	bf00      	nop

08001d4c <HAL_PCDEx_SetRxFiFo>:
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 8001d4c:	6803      	ldr	r3, [r0, #0]

  return HAL_OK;
}
 8001d4e:	2000      	movs	r0, #0
  hpcd->Instance->GRXFSIZ = size;
 8001d50:	6259      	str	r1, [r3, #36]	; 0x24
}
 8001d52:	4770      	bx	lr

08001d54 <HAL_PCDEx_ActivateLPM>:
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8001d54:	6803      	ldr	r3, [r0, #0]

  hpcd->lpm_active = 1U;
 8001d56:	2101      	movs	r1, #1
  hpcd->LPM_State = LPM_L0;
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8001d58:	4a08      	ldr	r2, [pc, #32]	; (8001d7c <HAL_PCDEx_ActivateLPM+0x28>)
{
 8001d5a:	b430      	push	{r4, r5}
  hpcd->lpm_active = 1U;
 8001d5c:	f8c0 13fc 	str.w	r1, [r0, #1020]	; 0x3fc
{
 8001d60:	4604      	mov	r4, r0
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8001d62:	6999      	ldr	r1, [r3, #24]
  hpcd->LPM_State = LPM_L0;
 8001d64:	2500      	movs	r5, #0
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8001d66:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
  hpcd->LPM_State = LPM_L0;
 8001d6a:	f884 53f4 	strb.w	r5, [r4, #1012]	; 0x3f4

  return HAL_OK;
}
 8001d6e:	4628      	mov	r0, r5
  USBx->GINTMSK |= USB_OTG_GINTMSK_LPMINTM;
 8001d70:	6199      	str	r1, [r3, #24]
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8001d72:	6d59      	ldr	r1, [r3, #84]	; 0x54
 8001d74:	430a      	orrs	r2, r1
}
 8001d76:	bc30      	pop	{r4, r5}
  USBx->GLPMCFG |= (USB_OTG_GLPMCFG_LPMEN | USB_OTG_GLPMCFG_LPMACK | USB_OTG_GLPMCFG_ENBESL);
 8001d78:	655a      	str	r2, [r3, #84]	; 0x54
}
 8001d7a:	4770      	bx	lr
 8001d7c:	10000003 	.word	0x10000003

08001d80 <HAL_PWREx_EnableOverDrive>:
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  uint32_t tickstart = 0;

  __HAL_RCC_PWR_CLK_ENABLE();
 8001d80:	4a1b      	ldr	r2, [pc, #108]	; (8001df0 <HAL_PWREx_EnableOverDrive+0x70>)
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8001d82:	4b1c      	ldr	r3, [pc, #112]	; (8001df4 <HAL_PWREx_EnableOverDrive+0x74>)
  __HAL_RCC_PWR_CLK_ENABLE();
 8001d84:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8001d86:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
{
 8001d8a:	b530      	push	{r4, r5, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 8001d8c:	6411      	str	r1, [r2, #64]	; 0x40
{
 8001d8e:	b083      	sub	sp, #12
  __HAL_RCC_PWR_CLK_ENABLE();
 8001d90:	6c12      	ldr	r2, [r2, #64]	; 0x40

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001d92:	461c      	mov	r4, r3
  __HAL_RCC_PWR_CLK_ENABLE();
 8001d94:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8001d98:	9201      	str	r2, [sp, #4]
 8001d9a:	9a01      	ldr	r2, [sp, #4]
  __HAL_PWR_OVERDRIVE_ENABLE();
 8001d9c:	681a      	ldr	r2, [r3, #0]
 8001d9e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001da2:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 8001da4:	f7fe fbee 	bl	8000584 <HAL_GetTick>
 8001da8:	4605      	mov	r5, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001daa:	e005      	b.n	8001db8 <HAL_PWREx_EnableOverDrive+0x38>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8001dac:	f7fe fbea 	bl	8000584 <HAL_GetTick>
 8001db0:	1b40      	subs	r0, r0, r5
 8001db2:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001db6:	d817      	bhi.n	8001de8 <HAL_PWREx_EnableOverDrive+0x68>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8001db8:	6863      	ldr	r3, [r4, #4]
 8001dba:	03da      	lsls	r2, r3, #15
 8001dbc:	d5f6      	bpl.n	8001dac <HAL_PWREx_EnableOverDrive+0x2c>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8001dbe:	6823      	ldr	r3, [r4, #0]

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8001dc0:	4d0c      	ldr	r5, [pc, #48]	; (8001df4 <HAL_PWREx_EnableOverDrive+0x74>)
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8001dc2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001dc6:	6023      	str	r3, [r4, #0]
  tickstart = HAL_GetTick();
 8001dc8:	f7fe fbdc 	bl	8000584 <HAL_GetTick>
 8001dcc:	4604      	mov	r4, r0
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8001dce:	e005      	b.n	8001ddc <HAL_PWREx_EnableOverDrive+0x5c>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8001dd0:	f7fe fbd8 	bl	8000584 <HAL_GetTick>
 8001dd4:	1b00      	subs	r0, r0, r4
 8001dd6:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8001dda:	d805      	bhi.n	8001de8 <HAL_PWREx_EnableOverDrive+0x68>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8001ddc:	686b      	ldr	r3, [r5, #4]
 8001dde:	039b      	lsls	r3, r3, #14
 8001de0:	d5f6      	bpl.n	8001dd0 <HAL_PWREx_EnableOverDrive+0x50>
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8001de2:	2000      	movs	r0, #0
}
 8001de4:	b003      	add	sp, #12
 8001de6:	bd30      	pop	{r4, r5, pc}
      return HAL_TIMEOUT;
 8001de8:	2003      	movs	r0, #3
}
 8001dea:	b003      	add	sp, #12
 8001dec:	bd30      	pop	{r4, r5, pc}
 8001dee:	bf00      	nop
 8001df0:	40023800 	.word	0x40023800
 8001df4:	40007000 	.word	0x40007000

08001df8 <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8001df8:	2800      	cmp	r0, #0
 8001dfa:	f000 8134 	beq.w	8002066 <HAL_RCC_OscConfig+0x26e>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001dfe:	6803      	ldr	r3, [r0, #0]
{
 8001e00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001e04:	07dd      	lsls	r5, r3, #31
{
 8001e06:	b082      	sub	sp, #8
 8001e08:	4604      	mov	r4, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001e0a:	d535      	bpl.n	8001e78 <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 8001e0c:	49ab      	ldr	r1, [pc, #684]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001e0e:	688a      	ldr	r2, [r1, #8]
 8001e10:	f002 020c 	and.w	r2, r2, #12
 8001e14:	2a04      	cmp	r2, #4
 8001e16:	f000 80fe 	beq.w	8002016 <HAL_RCC_OscConfig+0x21e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001e1a:	688a      	ldr	r2, [r1, #8]
 8001e1c:	f002 020c 	and.w	r2, r2, #12
 8001e20:	2a08      	cmp	r2, #8
 8001e22:	f000 80f4 	beq.w	800200e <HAL_RCC_OscConfig+0x216>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001e26:	6863      	ldr	r3, [r4, #4]
 8001e28:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001e2c:	d010      	beq.n	8001e50 <HAL_RCC_OscConfig+0x58>
 8001e2e:	2b00      	cmp	r3, #0
 8001e30:	f000 811b 	beq.w	800206a <HAL_RCC_OscConfig+0x272>
 8001e34:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001e38:	4ba0      	ldr	r3, [pc, #640]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001e3a:	681a      	ldr	r2, [r3, #0]
 8001e3c:	f000 8162 	beq.w	8002104 <HAL_RCC_OscConfig+0x30c>
 8001e40:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001e44:	601a      	str	r2, [r3, #0]
 8001e46:	681a      	ldr	r2, [r3, #0]
 8001e48:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001e4c:	601a      	str	r2, [r3, #0]
 8001e4e:	e004      	b.n	8001e5a <HAL_RCC_OscConfig+0x62>
 8001e50:	4a9a      	ldr	r2, [pc, #616]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001e52:	6813      	ldr	r3, [r2, #0]
 8001e54:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001e58:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001e5a:	f7fe fb93 	bl	8000584 <HAL_GetTick>

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001e5e:	4d97      	ldr	r5, [pc, #604]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
        tickstart = HAL_GetTick();
 8001e60:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001e62:	e005      	b.n	8001e70 <HAL_RCC_OscConfig+0x78>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001e64:	f7fe fb8e 	bl	8000584 <HAL_GetTick>
 8001e68:	1b80      	subs	r0, r0, r6
 8001e6a:	2864      	cmp	r0, #100	; 0x64
 8001e6c:	f200 80ee 	bhi.w	800204c <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001e70:	682b      	ldr	r3, [r5, #0]
 8001e72:	039a      	lsls	r2, r3, #14
 8001e74:	d5f6      	bpl.n	8001e64 <HAL_RCC_OscConfig+0x6c>
 8001e76:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001e78:	079f      	lsls	r7, r3, #30
 8001e7a:	d442      	bmi.n	8001f02 <HAL_RCC_OscConfig+0x10a>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001e7c:	071a      	lsls	r2, r3, #28
 8001e7e:	d517      	bpl.n	8001eb0 <HAL_RCC_OscConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001e80:	6963      	ldr	r3, [r4, #20]
 8001e82:	2b00      	cmp	r3, #0
 8001e84:	f000 80b0 	beq.w	8001fe8 <HAL_RCC_OscConfig+0x1f0>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001e88:	4b8c      	ldr	r3, [pc, #560]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001e8a:	6f5a      	ldr	r2, [r3, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001e8c:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
 8001e8e:	f042 0201 	orr.w	r2, r2, #1
 8001e92:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 8001e94:	f7fe fb76 	bl	8000584 <HAL_GetTick>
 8001e98:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001e9a:	e005      	b.n	8001ea8 <HAL_RCC_OscConfig+0xb0>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001e9c:	f7fe fb72 	bl	8000584 <HAL_GetTick>
 8001ea0:	1b80      	subs	r0, r0, r6
 8001ea2:	2802      	cmp	r0, #2
 8001ea4:	f200 80d2 	bhi.w	800204c <HAL_RCC_OscConfig+0x254>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001ea8:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8001eaa:	079b      	lsls	r3, r3, #30
 8001eac:	d5f6      	bpl.n	8001e9c <HAL_RCC_OscConfig+0xa4>
 8001eae:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001eb0:	075d      	lsls	r5, r3, #29
 8001eb2:	d56b      	bpl.n	8001f8c <HAL_RCC_OscConfig+0x194>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001eb4:	4b81      	ldr	r3, [pc, #516]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001eb6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001eb8:	00d0      	lsls	r0, r2, #3
 8001eba:	f100 80ed 	bmi.w	8002098 <HAL_RCC_OscConfig+0x2a0>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 8001ebe:	6c1a      	ldr	r2, [r3, #64]	; 0x40
      pwrclkchanged = SET;
 8001ec0:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 8001ec2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001ec6:	641a      	str	r2, [r3, #64]	; 0x40
 8001ec8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001eca:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001ece:	9301      	str	r3, [sp, #4]
 8001ed0:	9b01      	ldr	r3, [sp, #4]
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001ed2:	4b7b      	ldr	r3, [pc, #492]	; (80020c0 <HAL_RCC_OscConfig+0x2c8>)
 8001ed4:	681a      	ldr	r2, [r3, #0]
 8001ed6:	05d1      	lsls	r1, r2, #23
 8001ed8:	f140 80a7 	bpl.w	800202a <HAL_RCC_OscConfig+0x232>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001edc:	68a3      	ldr	r3, [r4, #8]
 8001ede:	2b01      	cmp	r3, #1
 8001ee0:	d039      	beq.n	8001f56 <HAL_RCC_OscConfig+0x15e>
 8001ee2:	2b00      	cmp	r3, #0
 8001ee4:	f000 80da 	beq.w	800209c <HAL_RCC_OscConfig+0x2a4>
 8001ee8:	2b05      	cmp	r3, #5
 8001eea:	4b74      	ldr	r3, [pc, #464]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001eec:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001eee:	f000 8111 	beq.w	8002114 <HAL_RCC_OscConfig+0x31c>
 8001ef2:	f022 0201 	bic.w	r2, r2, #1
 8001ef6:	671a      	str	r2, [r3, #112]	; 0x70
 8001ef8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001efa:	f022 0204 	bic.w	r2, r2, #4
 8001efe:	671a      	str	r2, [r3, #112]	; 0x70
 8001f00:	e02e      	b.n	8001f60 <HAL_RCC_OscConfig+0x168>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 8001f02:	4a6e      	ldr	r2, [pc, #440]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001f04:	6891      	ldr	r1, [r2, #8]
 8001f06:	f011 0f0c 	tst.w	r1, #12
 8001f0a:	d062      	beq.n	8001fd2 <HAL_RCC_OscConfig+0x1da>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001f0c:	6891      	ldr	r1, [r2, #8]
 8001f0e:	f001 010c 	and.w	r1, r1, #12
 8001f12:	2908      	cmp	r1, #8
 8001f14:	d05a      	beq.n	8001fcc <HAL_RCC_OscConfig+0x1d4>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8001f16:	68e3      	ldr	r3, [r4, #12]
 8001f18:	2b00      	cmp	r3, #0
 8001f1a:	f000 80df 	beq.w	80020dc <HAL_RCC_OscConfig+0x2e4>
        __HAL_RCC_HSI_ENABLE();
 8001f1e:	4b67      	ldr	r3, [pc, #412]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001f20:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001f22:	461d      	mov	r5, r3
        __HAL_RCC_HSI_ENABLE();
 8001f24:	f042 0201 	orr.w	r2, r2, #1
 8001f28:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001f2a:	f7fe fb2b 	bl	8000584 <HAL_GetTick>
 8001f2e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001f30:	e005      	b.n	8001f3e <HAL_RCC_OscConfig+0x146>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001f32:	f7fe fb27 	bl	8000584 <HAL_GetTick>
 8001f36:	1b80      	subs	r0, r0, r6
 8001f38:	2802      	cmp	r0, #2
 8001f3a:	f200 8087 	bhi.w	800204c <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001f3e:	682b      	ldr	r3, [r5, #0]
 8001f40:	0798      	lsls	r0, r3, #30
 8001f42:	d5f6      	bpl.n	8001f32 <HAL_RCC_OscConfig+0x13a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001f44:	682b      	ldr	r3, [r5, #0]
 8001f46:	6922      	ldr	r2, [r4, #16]
 8001f48:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8001f4c:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8001f50:	602b      	str	r3, [r5, #0]
 8001f52:	6823      	ldr	r3, [r4, #0]
 8001f54:	e792      	b.n	8001e7c <HAL_RCC_OscConfig+0x84>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001f56:	4a59      	ldr	r2, [pc, #356]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001f58:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8001f5a:	f043 0301 	orr.w	r3, r3, #1
 8001f5e:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001f60:	f7fe fb10 	bl	8000584 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001f64:	4e55      	ldr	r6, [pc, #340]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
      tickstart = HAL_GetTick();
 8001f66:	4680      	mov	r8, r0
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001f68:	f241 3788 	movw	r7, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001f6c:	e005      	b.n	8001f7a <HAL_RCC_OscConfig+0x182>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001f6e:	f7fe fb09 	bl	8000584 <HAL_GetTick>
 8001f72:	eba0 0008 	sub.w	r0, r0, r8
 8001f76:	42b8      	cmp	r0, r7
 8001f78:	d868      	bhi.n	800204c <HAL_RCC_OscConfig+0x254>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001f7a:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8001f7c:	079b      	lsls	r3, r3, #30
 8001f7e:	d5f6      	bpl.n	8001f6e <HAL_RCC_OscConfig+0x176>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8001f80:	b125      	cbz	r5, 8001f8c <HAL_RCC_OscConfig+0x194>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001f82:	4a4e      	ldr	r2, [pc, #312]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001f84:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8001f86:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001f8a:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001f8c:	69a3      	ldr	r3, [r4, #24]
 8001f8e:	b1cb      	cbz	r3, 8001fc4 <HAL_RCC_OscConfig+0x1cc>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8001f90:	4a4a      	ldr	r2, [pc, #296]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001f92:	6891      	ldr	r1, [r2, #8]
 8001f94:	f001 010c 	and.w	r1, r1, #12
 8001f98:	2908      	cmp	r1, #8
 8001f9a:	d021      	beq.n	8001fe0 <HAL_RCC_OscConfig+0x1e8>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001f9c:	2b02      	cmp	r3, #2
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001f9e:	6813      	ldr	r3, [r2, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001fa0:	f000 80c0 	beq.w	8002124 <HAL_RCC_OscConfig+0x32c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001fa4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001fa8:	4614      	mov	r4, r2
        __HAL_RCC_PLL_DISABLE();
 8001faa:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8001fac:	f7fe faea 	bl	8000584 <HAL_GetTick>
 8001fb0:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001fb2:	e004      	b.n	8001fbe <HAL_RCC_OscConfig+0x1c6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001fb4:	f7fe fae6 	bl	8000584 <HAL_GetTick>
 8001fb8:	1b40      	subs	r0, r0, r5
 8001fba:	2802      	cmp	r0, #2
 8001fbc:	d846      	bhi.n	800204c <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001fbe:	6823      	ldr	r3, [r4, #0]
 8001fc0:	019b      	lsls	r3, r3, #6
 8001fc2:	d4f7      	bmi.n	8001fb4 <HAL_RCC_OscConfig+0x1bc>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8001fc4:	2000      	movs	r0, #0
}
 8001fc6:	b002      	add	sp, #8
 8001fc8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8001fcc:	6852      	ldr	r2, [r2, #4]
 8001fce:	0256      	lsls	r6, r2, #9
 8001fd0:	d4a1      	bmi.n	8001f16 <HAL_RCC_OscConfig+0x11e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001fd2:	4a3a      	ldr	r2, [pc, #232]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001fd4:	6812      	ldr	r2, [r2, #0]
 8001fd6:	0795      	lsls	r5, r2, #30
 8001fd8:	d53c      	bpl.n	8002054 <HAL_RCC_OscConfig+0x25c>
 8001fda:	68e2      	ldr	r2, [r4, #12]
 8001fdc:	2a01      	cmp	r2, #1
 8001fde:	d039      	beq.n	8002054 <HAL_RCC_OscConfig+0x25c>
    return HAL_ERROR;
 8001fe0:	2001      	movs	r0, #1
}
 8001fe2:	b002      	add	sp, #8
 8001fe4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 8001fe8:	4b34      	ldr	r3, [pc, #208]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8001fea:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001fec:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
 8001fee:	f022 0201 	bic.w	r2, r2, #1
 8001ff2:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 8001ff4:	f7fe fac6 	bl	8000584 <HAL_GetTick>
 8001ff8:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001ffa:	e004      	b.n	8002006 <HAL_RCC_OscConfig+0x20e>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001ffc:	f7fe fac2 	bl	8000584 <HAL_GetTick>
 8002000:	1b80      	subs	r0, r0, r6
 8002002:	2802      	cmp	r0, #2
 8002004:	d822      	bhi.n	800204c <HAL_RCC_OscConfig+0x254>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002006:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8002008:	079f      	lsls	r7, r3, #30
 800200a:	d4f7      	bmi.n	8001ffc <HAL_RCC_OscConfig+0x204>
 800200c:	e74f      	b.n	8001eae <HAL_RCC_OscConfig+0xb6>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800200e:	684a      	ldr	r2, [r1, #4]
 8002010:	0250      	lsls	r0, r2, #9
 8002012:	f57f af08 	bpl.w	8001e26 <HAL_RCC_OscConfig+0x2e>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002016:	4a29      	ldr	r2, [pc, #164]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8002018:	6812      	ldr	r2, [r2, #0]
 800201a:	0391      	lsls	r1, r2, #14
 800201c:	f57f af2c 	bpl.w	8001e78 <HAL_RCC_OscConfig+0x80>
 8002020:	6862      	ldr	r2, [r4, #4]
 8002022:	2a00      	cmp	r2, #0
 8002024:	f47f af28 	bne.w	8001e78 <HAL_RCC_OscConfig+0x80>
 8002028:	e7da      	b.n	8001fe0 <HAL_RCC_OscConfig+0x1e8>
      PWR->CR1 |= PWR_CR1_DBP;
 800202a:	681a      	ldr	r2, [r3, #0]
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800202c:	461e      	mov	r6, r3
      PWR->CR1 |= PWR_CR1_DBP;
 800202e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002032:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8002034:	f7fe faa6 	bl	8000584 <HAL_GetTick>
 8002038:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800203a:	6833      	ldr	r3, [r6, #0]
 800203c:	05da      	lsls	r2, r3, #23
 800203e:	f53f af4d 	bmi.w	8001edc <HAL_RCC_OscConfig+0xe4>
        if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8002042:	f7fe fa9f 	bl	8000584 <HAL_GetTick>
 8002046:	1bc0      	subs	r0, r0, r7
 8002048:	2864      	cmp	r0, #100	; 0x64
 800204a:	d9f6      	bls.n	800203a <HAL_RCC_OscConfig+0x242>
            return HAL_TIMEOUT;
 800204c:	2003      	movs	r0, #3
}
 800204e:	b002      	add	sp, #8
 8002050:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002054:	4919      	ldr	r1, [pc, #100]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 8002056:	6920      	ldr	r0, [r4, #16]
 8002058:	680a      	ldr	r2, [r1, #0]
 800205a:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800205e:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 8002062:	600a      	str	r2, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002064:	e70a      	b.n	8001e7c <HAL_RCC_OscConfig+0x84>
    return HAL_ERROR;
 8002066:	2001      	movs	r0, #1
}
 8002068:	4770      	bx	lr
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800206a:	4b14      	ldr	r3, [pc, #80]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
 800206c:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800206e:	461d      	mov	r5, r3
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002070:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002074:	601a      	str	r2, [r3, #0]
 8002076:	681a      	ldr	r2, [r3, #0]
 8002078:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800207c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800207e:	f7fe fa81 	bl	8000584 <HAL_GetTick>
 8002082:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002084:	e004      	b.n	8002090 <HAL_RCC_OscConfig+0x298>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002086:	f7fe fa7d 	bl	8000584 <HAL_GetTick>
 800208a:	1b80      	subs	r0, r0, r6
 800208c:	2864      	cmp	r0, #100	; 0x64
 800208e:	d8dd      	bhi.n	800204c <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002090:	682b      	ldr	r3, [r5, #0]
 8002092:	039b      	lsls	r3, r3, #14
 8002094:	d4f7      	bmi.n	8002086 <HAL_RCC_OscConfig+0x28e>
 8002096:	e6ee      	b.n	8001e76 <HAL_RCC_OscConfig+0x7e>
  FlagStatus pwrclkchanged = RESET;
 8002098:	2500      	movs	r5, #0
 800209a:	e71a      	b.n	8001ed2 <HAL_RCC_OscConfig+0xda>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800209c:	4b07      	ldr	r3, [pc, #28]	; (80020bc <HAL_RCC_OscConfig+0x2c4>)
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800209e:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80020a2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80020a4:	461e      	mov	r6, r3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80020a6:	f022 0201 	bic.w	r2, r2, #1
 80020aa:	671a      	str	r2, [r3, #112]	; 0x70
 80020ac:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80020ae:	f022 0204 	bic.w	r2, r2, #4
 80020b2:	671a      	str	r2, [r3, #112]	; 0x70
      tickstart = HAL_GetTick();
 80020b4:	f7fe fa66 	bl	8000584 <HAL_GetTick>
 80020b8:	4607      	mov	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80020ba:	e008      	b.n	80020ce <HAL_RCC_OscConfig+0x2d6>
 80020bc:	40023800 	.word	0x40023800
 80020c0:	40007000 	.word	0x40007000
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80020c4:	f7fe fa5e 	bl	8000584 <HAL_GetTick>
 80020c8:	1bc0      	subs	r0, r0, r7
 80020ca:	4540      	cmp	r0, r8
 80020cc:	d8be      	bhi.n	800204c <HAL_RCC_OscConfig+0x254>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80020ce:	6f33      	ldr	r3, [r6, #112]	; 0x70
 80020d0:	0798      	lsls	r0, r3, #30
 80020d2:	d4f7      	bmi.n	80020c4 <HAL_RCC_OscConfig+0x2cc>
    if(pwrclkchanged == SET)
 80020d4:	2d00      	cmp	r5, #0
 80020d6:	f43f af59 	beq.w	8001f8c <HAL_RCC_OscConfig+0x194>
 80020da:	e752      	b.n	8001f82 <HAL_RCC_OscConfig+0x18a>
        __HAL_RCC_HSI_DISABLE();
 80020dc:	4b2b      	ldr	r3, [pc, #172]	; (800218c <HAL_RCC_OscConfig+0x394>)
 80020de:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80020e0:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
 80020e2:	f022 0201 	bic.w	r2, r2, #1
 80020e6:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80020e8:	f7fe fa4c 	bl	8000584 <HAL_GetTick>
 80020ec:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80020ee:	e004      	b.n	80020fa <HAL_RCC_OscConfig+0x302>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80020f0:	f7fe fa48 	bl	8000584 <HAL_GetTick>
 80020f4:	1b80      	subs	r0, r0, r6
 80020f6:	2802      	cmp	r0, #2
 80020f8:	d8a8      	bhi.n	800204c <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80020fa:	682b      	ldr	r3, [r5, #0]
 80020fc:	0799      	lsls	r1, r3, #30
 80020fe:	d4f7      	bmi.n	80020f0 <HAL_RCC_OscConfig+0x2f8>
 8002100:	6823      	ldr	r3, [r4, #0]
 8002102:	e6bb      	b.n	8001e7c <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002104:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8002108:	601a      	str	r2, [r3, #0]
 800210a:	681a      	ldr	r2, [r3, #0]
 800210c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002110:	601a      	str	r2, [r3, #0]
 8002112:	e6a2      	b.n	8001e5a <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002114:	f042 0204 	orr.w	r2, r2, #4
 8002118:	671a      	str	r2, [r3, #112]	; 0x70
 800211a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800211c:	f042 0201 	orr.w	r2, r2, #1
 8002120:	671a      	str	r2, [r3, #112]	; 0x70
 8002122:	e71d      	b.n	8001f60 <HAL_RCC_OscConfig+0x168>
        __HAL_RCC_PLL_DISABLE();
 8002124:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002128:	4615      	mov	r5, r2
        __HAL_RCC_PLL_DISABLE();
 800212a:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800212c:	f7fe fa2a 	bl	8000584 <HAL_GetTick>
 8002130:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002132:	e004      	b.n	800213e <HAL_RCC_OscConfig+0x346>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002134:	f7fe fa26 	bl	8000584 <HAL_GetTick>
 8002138:	1b80      	subs	r0, r0, r6
 800213a:	2802      	cmp	r0, #2
 800213c:	d886      	bhi.n	800204c <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800213e:	682b      	ldr	r3, [r5, #0]
 8002140:	0199      	lsls	r1, r3, #6
 8002142:	d4f7      	bmi.n	8002134 <HAL_RCC_OscConfig+0x33c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002144:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 8002148:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800214a:	4313      	orrs	r3, r2
 800214c:	e9d4 210a 	ldrd	r2, r1, [r4, #40]	; 0x28
 8002150:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002154:	4c0d      	ldr	r4, [pc, #52]	; (800218c <HAL_RCC_OscConfig+0x394>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002156:	0852      	lsrs	r2, r2, #1
 8002158:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 800215c:	3a01      	subs	r2, #1
 800215e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8002162:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8002166:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8002168:	682b      	ldr	r3, [r5, #0]
 800216a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800216e:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8002170:	f7fe fa08 	bl	8000584 <HAL_GetTick>
 8002174:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002176:	e005      	b.n	8002184 <HAL_RCC_OscConfig+0x38c>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002178:	f7fe fa04 	bl	8000584 <HAL_GetTick>
 800217c:	1b40      	subs	r0, r0, r5
 800217e:	2802      	cmp	r0, #2
 8002180:	f63f af64 	bhi.w	800204c <HAL_RCC_OscConfig+0x254>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002184:	6823      	ldr	r3, [r4, #0]
 8002186:	019a      	lsls	r2, r3, #6
 8002188:	d5f6      	bpl.n	8002178 <HAL_RCC_OscConfig+0x380>
 800218a:	e71b      	b.n	8001fc4 <HAL_RCC_OscConfig+0x1cc>
 800218c:	40023800 	.word	0x40023800

08002190 <HAL_RCC_ClockConfig>:
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  uint32_t tickstart = 0;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8002190:	b178      	cbz	r0, 80021b2 <HAL_RCC_ClockConfig+0x22>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8002192:	4a5e      	ldr	r2, [pc, #376]	; (800230c <HAL_RCC_ClockConfig+0x17c>)
 8002194:	6813      	ldr	r3, [r2, #0]
 8002196:	f003 030f 	and.w	r3, r3, #15
 800219a:	428b      	cmp	r3, r1
 800219c:	d20b      	bcs.n	80021b6 <HAL_RCC_ClockConfig+0x26>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800219e:	6813      	ldr	r3, [r2, #0]
 80021a0:	f023 030f 	bic.w	r3, r3, #15
 80021a4:	430b      	orrs	r3, r1
 80021a6:	6013      	str	r3, [r2, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80021a8:	6813      	ldr	r3, [r2, #0]
 80021aa:	f003 030f 	and.w	r3, r3, #15
 80021ae:	428b      	cmp	r3, r1
 80021b0:	d001      	beq.n	80021b6 <HAL_RCC_ClockConfig+0x26>
    return HAL_ERROR;
 80021b2:	2001      	movs	r0, #1

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);

  return HAL_OK;
}
 80021b4:	4770      	bx	lr
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80021b6:	6803      	ldr	r3, [r0, #0]
{
 80021b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80021bc:	079d      	lsls	r5, r3, #30
 80021be:	d514      	bpl.n	80021ea <HAL_RCC_ClockConfig+0x5a>
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80021c0:	075c      	lsls	r4, r3, #29
 80021c2:	d504      	bpl.n	80021ce <HAL_RCC_ClockConfig+0x3e>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80021c4:	4c52      	ldr	r4, [pc, #328]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
 80021c6:	68a2      	ldr	r2, [r4, #8]
 80021c8:	f442 52e0 	orr.w	r2, r2, #7168	; 0x1c00
 80021cc:	60a2      	str	r2, [r4, #8]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80021ce:	071a      	lsls	r2, r3, #28
 80021d0:	d504      	bpl.n	80021dc <HAL_RCC_ClockConfig+0x4c>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80021d2:	4c4f      	ldr	r4, [pc, #316]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
 80021d4:	68a2      	ldr	r2, [r4, #8]
 80021d6:	f442 4260 	orr.w	r2, r2, #57344	; 0xe000
 80021da:	60a2      	str	r2, [r4, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80021dc:	4c4c      	ldr	r4, [pc, #304]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
 80021de:	6885      	ldr	r5, [r0, #8]
 80021e0:	68a2      	ldr	r2, [r4, #8]
 80021e2:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80021e6:	432a      	orrs	r2, r5
 80021e8:	60a2      	str	r2, [r4, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80021ea:	07df      	lsls	r7, r3, #31
 80021ec:	4604      	mov	r4, r0
 80021ee:	460d      	mov	r5, r1
 80021f0:	d521      	bpl.n	8002236 <HAL_RCC_ClockConfig+0xa6>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80021f2:	6842      	ldr	r2, [r0, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80021f4:	4b46      	ldr	r3, [pc, #280]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80021f6:	2a01      	cmp	r2, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80021f8:	681b      	ldr	r3, [r3, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80021fa:	d063      	beq.n	80022c4 <HAL_RCC_ClockConfig+0x134>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80021fc:	2a02      	cmp	r2, #2
 80021fe:	d078      	beq.n	80022f2 <HAL_RCC_ClockConfig+0x162>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002200:	0799      	lsls	r1, r3, #30
 8002202:	d528      	bpl.n	8002256 <HAL_RCC_ClockConfig+0xc6>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8002204:	4942      	ldr	r1, [pc, #264]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002206:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800220a:	688b      	ldr	r3, [r1, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800220c:	460e      	mov	r6, r1
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800220e:	f023 0303 	bic.w	r3, r3, #3
 8002212:	4313      	orrs	r3, r2
 8002214:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8002216:	f7fe f9b5 	bl	8000584 <HAL_GetTick>
 800221a:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800221c:	e004      	b.n	8002228 <HAL_RCC_ClockConfig+0x98>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800221e:	f7fe f9b1 	bl	8000584 <HAL_GetTick>
 8002222:	1bc0      	subs	r0, r0, r7
 8002224:	4540      	cmp	r0, r8
 8002226:	d862      	bhi.n	80022ee <HAL_RCC_ClockConfig+0x15e>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002228:	68b3      	ldr	r3, [r6, #8]
 800222a:	6862      	ldr	r2, [r4, #4]
 800222c:	f003 030c 	and.w	r3, r3, #12
 8002230:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8002234:	d1f3      	bne.n	800221e <HAL_RCC_ClockConfig+0x8e>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8002236:	4a35      	ldr	r2, [pc, #212]	; (800230c <HAL_RCC_ClockConfig+0x17c>)
 8002238:	6813      	ldr	r3, [r2, #0]
 800223a:	f003 030f 	and.w	r3, r3, #15
 800223e:	42ab      	cmp	r3, r5
 8002240:	d90c      	bls.n	800225c <HAL_RCC_ClockConfig+0xcc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002242:	6813      	ldr	r3, [r2, #0]
 8002244:	f023 030f 	bic.w	r3, r3, #15
 8002248:	432b      	orrs	r3, r5
 800224a:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800224c:	6813      	ldr	r3, [r2, #0]
 800224e:	f003 030f 	and.w	r3, r3, #15
 8002252:	42ab      	cmp	r3, r5
 8002254:	d002      	beq.n	800225c <HAL_RCC_ClockConfig+0xcc>
    return HAL_ERROR;
 8002256:	2001      	movs	r0, #1
}
 8002258:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800225c:	6823      	ldr	r3, [r4, #0]
 800225e:	075a      	lsls	r2, r3, #29
 8002260:	d506      	bpl.n	8002270 <HAL_RCC_ClockConfig+0xe0>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8002262:	492b      	ldr	r1, [pc, #172]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
 8002264:	68e0      	ldr	r0, [r4, #12]
 8002266:	688a      	ldr	r2, [r1, #8]
 8002268:	f422 52e0 	bic.w	r2, r2, #7168	; 0x1c00
 800226c:	4302      	orrs	r2, r0
 800226e:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002270:	071b      	lsls	r3, r3, #28
 8002272:	d507      	bpl.n	8002284 <HAL_RCC_ClockConfig+0xf4>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8002274:	4a26      	ldr	r2, [pc, #152]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
 8002276:	6921      	ldr	r1, [r4, #16]
 8002278:	6893      	ldr	r3, [r2, #8]
 800227a:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800227e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8002282:	6093      	str	r3, [r2, #8]
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002284:	4922      	ldr	r1, [pc, #136]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
 8002286:	688b      	ldr	r3, [r1, #8]
 8002288:	f003 030c 	and.w	r3, r3, #12
 800228c:	2b04      	cmp	r3, #4
 800228e:	d01c      	beq.n	80022ca <HAL_RCC_ClockConfig+0x13a>
 8002290:	2b08      	cmp	r3, #8
 8002292:	d12a      	bne.n	80022ea <HAL_RCC_ClockConfig+0x15a>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002294:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8002296:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002298:	f002 023f 	and.w	r2, r2, #63	; 0x3f
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800229c:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800229e:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
 80022a2:	d129      	bne.n	80022f8 <HAL_RCC_ClockConfig+0x168>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80022a4:	481b      	ldr	r0, [pc, #108]	; (8002314 <HAL_RCC_ClockConfig+0x184>)
 80022a6:	f3c1 1188 	ubfx	r1, r1, #6, #9
 80022aa:	fba1 0100 	umull	r0, r1, r1, r0
 80022ae:	f7fd ffab 	bl	8000208 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
 80022b2:	4b17      	ldr	r3, [pc, #92]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
 80022b4:	685b      	ldr	r3, [r3, #4]
 80022b6:	f3c3 4301 	ubfx	r3, r3, #16, #2
 80022ba:	3301      	adds	r3, #1
 80022bc:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco/pllp;
 80022be:	fbb0 f3f3 	udiv	r3, r0, r3
 80022c2:	e003      	b.n	80022cc <HAL_RCC_ClockConfig+0x13c>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80022c4:	039e      	lsls	r6, r3, #14
 80022c6:	d49d      	bmi.n	8002204 <HAL_RCC_ClockConfig+0x74>
 80022c8:	e7c5      	b.n	8002256 <HAL_RCC_ClockConfig+0xc6>
      sysclockfreq = HSE_VALUE;
 80022ca:	4b13      	ldr	r3, [pc, #76]	; (8002318 <HAL_RCC_ClockConfig+0x188>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80022cc:	4a10      	ldr	r2, [pc, #64]	; (8002310 <HAL_RCC_ClockConfig+0x180>)
  HAL_InitTick (TICK_INT_PRIORITY);
 80022ce:	2000      	movs	r0, #0
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80022d0:	4c12      	ldr	r4, [pc, #72]	; (800231c <HAL_RCC_ClockConfig+0x18c>)
 80022d2:	6892      	ldr	r2, [r2, #8]
 80022d4:	4912      	ldr	r1, [pc, #72]	; (8002320 <HAL_RCC_ClockConfig+0x190>)
 80022d6:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80022da:	5ca2      	ldrb	r2, [r4, r2]
 80022dc:	40d3      	lsrs	r3, r2
 80022de:	600b      	str	r3, [r1, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 80022e0:	f7fe f912 	bl	8000508 <HAL_InitTick>
  return HAL_OK;
 80022e4:	2000      	movs	r0, #0
}
 80022e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      sysclockfreq = HSI_VALUE;
 80022ea:	4b0a      	ldr	r3, [pc, #40]	; (8002314 <HAL_RCC_ClockConfig+0x184>)
 80022ec:	e7ee      	b.n	80022cc <HAL_RCC_ClockConfig+0x13c>
        return HAL_TIMEOUT;
 80022ee:	2003      	movs	r0, #3
 80022f0:	e7b2      	b.n	8002258 <HAL_RCC_ClockConfig+0xc8>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80022f2:	0198      	lsls	r0, r3, #6
 80022f4:	d486      	bmi.n	8002204 <HAL_RCC_ClockConfig+0x74>
 80022f6:	e7ae      	b.n	8002256 <HAL_RCC_ClockConfig+0xc6>
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80022f8:	4807      	ldr	r0, [pc, #28]	; (8002318 <HAL_RCC_ClockConfig+0x188>)
 80022fa:	f3c1 1188 	ubfx	r1, r1, #6, #9
 80022fe:	2300      	movs	r3, #0
 8002300:	fba1 0100 	umull	r0, r1, r1, r0
 8002304:	f7fd ff80 	bl	8000208 <__aeabi_uldivmod>
 8002308:	e7d3      	b.n	80022b2 <HAL_RCC_ClockConfig+0x122>
 800230a:	bf00      	nop
 800230c:	40023c00 	.word	0x40023c00
 8002310:	40023800 	.word	0x40023800
 8002314:	00f42400 	.word	0x00f42400
 8002318:	017d7840 	.word	0x017d7840
 800231c:	08009254 	.word	0x08009254
 8002320:	20000184 	.word	0x20000184

08002324 <HAL_RCC_GetSysClockFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002324:	4916      	ldr	r1, [pc, #88]	; (8002380 <HAL_RCC_GetSysClockFreq+0x5c>)
{
 8002326:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8002328:	688b      	ldr	r3, [r1, #8]
 800232a:	f003 030c 	and.w	r3, r3, #12
 800232e:	2b04      	cmp	r3, #4
 8002330:	d01b      	beq.n	800236a <HAL_RCC_GetSysClockFreq+0x46>
 8002332:	2b08      	cmp	r3, #8
 8002334:	d117      	bne.n	8002366 <HAL_RCC_GetSysClockFreq+0x42>
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002336:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8002338:	684b      	ldr	r3, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800233a:	f002 023f 	and.w	r2, r2, #63	; 0x3f
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800233e:	6849      	ldr	r1, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8002340:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
 8002344:	d113      	bne.n	800236e <HAL_RCC_GetSysClockFreq+0x4a>
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8002346:	480f      	ldr	r0, [pc, #60]	; (8002384 <HAL_RCC_GetSysClockFreq+0x60>)
 8002348:	f3c1 1188 	ubfx	r1, r1, #6, #9
 800234c:	fba1 0100 	umull	r0, r1, r1, r0
 8002350:	f7fd ff5a 	bl	8000208 <__aeabi_uldivmod>
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
 8002354:	4b0a      	ldr	r3, [pc, #40]	; (8002380 <HAL_RCC_GetSysClockFreq+0x5c>)
 8002356:	685b      	ldr	r3, [r3, #4]
 8002358:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800235c:	3301      	adds	r3, #1
 800235e:	005b      	lsls	r3, r3, #1
      sysclockfreq = pllvco/pllp;
 8002360:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8002364:	bd08      	pop	{r3, pc}
      sysclockfreq = HSI_VALUE;
 8002366:	4807      	ldr	r0, [pc, #28]	; (8002384 <HAL_RCC_GetSysClockFreq+0x60>)
}
 8002368:	bd08      	pop	{r3, pc}
      sysclockfreq = HSE_VALUE;
 800236a:	4807      	ldr	r0, [pc, #28]	; (8002388 <HAL_RCC_GetSysClockFreq+0x64>)
}
 800236c:	bd08      	pop	{r3, pc}
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800236e:	4806      	ldr	r0, [pc, #24]	; (8002388 <HAL_RCC_GetSysClockFreq+0x64>)
 8002370:	f3c1 1188 	ubfx	r1, r1, #6, #9
 8002374:	2300      	movs	r3, #0
 8002376:	fba1 0100 	umull	r0, r1, r1, r0
 800237a:	f7fd ff45 	bl	8000208 <__aeabi_uldivmod>
 800237e:	e7e9      	b.n	8002354 <HAL_RCC_GetSysClockFreq+0x30>
 8002380:	40023800 	.word	0x40023800
 8002384:	00f42400 	.word	0x00f42400
 8002388:	017d7840 	.word	0x017d7840

0800238c <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
 800238c:	4b01      	ldr	r3, [pc, #4]	; (8002394 <HAL_RCC_GetHCLKFreq+0x8>)
}
 800238e:	6818      	ldr	r0, [r3, #0]
 8002390:	4770      	bx	lr
 8002392:	bf00      	nop
 8002394:	20000184 	.word	0x20000184

08002398 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8002398:	4b04      	ldr	r3, [pc, #16]	; (80023ac <HAL_RCC_GetPCLK1Freq+0x14>)
 800239a:	4a05      	ldr	r2, [pc, #20]	; (80023b0 <HAL_RCC_GetPCLK1Freq+0x18>)
 800239c:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 800239e:	4905      	ldr	r1, [pc, #20]	; (80023b4 <HAL_RCC_GetPCLK1Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 80023a0:	f3c3 2382 	ubfx	r3, r3, #10, #3
 80023a4:	6808      	ldr	r0, [r1, #0]
 80023a6:	5cd3      	ldrb	r3, [r2, r3]
}
 80023a8:	40d8      	lsrs	r0, r3
 80023aa:	4770      	bx	lr
 80023ac:	40023800 	.word	0x40023800
 80023b0:	08009264 	.word	0x08009264
 80023b4:	20000184 	.word	0x20000184

080023b8 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 80023b8:	4b04      	ldr	r3, [pc, #16]	; (80023cc <HAL_RCC_GetPCLK2Freq+0x14>)
 80023ba:	4a05      	ldr	r2, [pc, #20]	; (80023d0 <HAL_RCC_GetPCLK2Freq+0x18>)
 80023bc:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 80023be:	4905      	ldr	r1, [pc, #20]	; (80023d4 <HAL_RCC_GetPCLK2Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 80023c0:	f3c3 3342 	ubfx	r3, r3, #13, #3
 80023c4:	6808      	ldr	r0, [r1, #0]
 80023c6:	5cd3      	ldrb	r3, [r2, r3]
}
 80023c8:	40d8      	lsrs	r0, r3
 80023ca:	4770      	bx	lr
 80023cc:	40023800 	.word	0x40023800
 80023d0:	08009264 	.word	0x08009264
 80023d4:	20000184 	.word	0x20000184

080023d8 <HAL_RCCEx_PeriphCLKConfig>:

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80023d8:	6803      	ldr	r3, [r0, #0]
{
 80023da:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80023de:	f013 0601 	ands.w	r6, r3, #1
{
 80023e2:	b083      	sub	sp, #12
 80023e4:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80023e6:	d00b      	beq.n	8002400 <HAL_RCCEx_PeriphCLKConfig+0x28>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80023e8:	4ab8      	ldr	r2, [pc, #736]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80023ea:	6891      	ldr	r1, [r2, #8]
 80023ec:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
 80023f0:	6091      	str	r1, [r2, #8]
 80023f2:	6b46      	ldr	r6, [r0, #52]	; 0x34
 80023f4:	6891      	ldr	r1, [r2, #8]
 80023f6:	4331      	orrs	r1, r6

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 80023f8:	fab6 f686 	clz	r6, r6
 80023fc:	0976      	lsrs	r6, r6, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80023fe:	6091      	str	r1, [r2, #8]
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 8002400:	f413 2500 	ands.w	r5, r3, #524288	; 0x80000
 8002404:	d010      	beq.n	8002428 <HAL_RCCEx_PeriphCLKConfig+0x50>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8002406:	49b1      	ldr	r1, [pc, #708]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8002408:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 800240a:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 800240e:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8002412:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8002416:	ea42 0205 	orr.w	r2, r2, r5
 800241a:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 800241e:	f000 81b0 	beq.w	8002782 <HAL_RCCEx_PeriphCLKConfig+0x3aa>
    {
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8002422:	fab5 f585 	clz	r5, r5
 8002426:	096d      	lsrs	r5, r5, #5
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8002428:	02d9      	lsls	r1, r3, #11
 800242a:	d510      	bpl.n	800244e <HAL_RCCEx_PeriphCLKConfig+0x76>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 800242c:	48a7      	ldr	r0, [pc, #668]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800242e:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8002430:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8002434:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8002438:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800243c:	ea42 0201 	orr.w	r2, r2, r1
 8002440:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8002444:	f000 819b 	beq.w	800277e <HAL_RCCEx_PeriphCLKConfig+0x3a6>
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
    {
      pllsaiused = 1;
 8002448:	2900      	cmp	r1, #0
 800244a:	bf08      	it	eq
 800244c:	2501      	moveq	r5, #1
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  {
      plli2sused = 1;
 800244e:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 8002452:	bf18      	it	ne
 8002454:	2601      	movne	r6, #1
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8002456:	069a      	lsls	r2, r3, #26
 8002458:	f100 8149 	bmi.w	80026ee <HAL_RCCEx_PeriphCLKConfig+0x316>
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 800245c:	06d9      	lsls	r1, r3, #27
 800245e:	d50c      	bpl.n	800247a <HAL_RCCEx_PeriphCLKConfig+0xa2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8002460:	4a9a      	ldr	r2, [pc, #616]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8002462:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8002466:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
 800246a:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
 800246e:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
 8002472:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8002474:	4301      	orrs	r1, r0
 8002476:	f8c2 108c 	str.w	r1, [r2, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800247a:	045a      	lsls	r2, r3, #17
 800247c:	d508      	bpl.n	8002490 <HAL_RCCEx_PeriphCLKConfig+0xb8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 800247e:	4993      	ldr	r1, [pc, #588]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8002480:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8002482:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002486:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800248a:	4302      	orrs	r2, r0
 800248c:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8002490:	041f      	lsls	r7, r3, #16
 8002492:	d508      	bpl.n	80024a6 <HAL_RCCEx_PeriphCLKConfig+0xce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8002494:	498d      	ldr	r1, [pc, #564]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8002496:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8002498:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800249c:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 80024a0:	4302      	orrs	r2, r0
 80024a2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80024a6:	03d8      	lsls	r0, r3, #15
 80024a8:	d508      	bpl.n	80024bc <HAL_RCCEx_PeriphCLKConfig+0xe4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80024aa:	4988      	ldr	r1, [pc, #544]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80024ac:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80024ae:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80024b2:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 80024b6:	4302      	orrs	r2, r0
 80024b8:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 80024bc:	0399      	lsls	r1, r3, #14
 80024be:	d508      	bpl.n	80024d2 <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 80024c0:	4982      	ldr	r1, [pc, #520]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80024c2:	6f20      	ldr	r0, [r4, #112]	; 0x70
 80024c4:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80024c8:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 80024cc:	4302      	orrs	r2, r0
 80024ce:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80024d2:	065a      	lsls	r2, r3, #25
 80024d4:	d508      	bpl.n	80024e8 <HAL_RCCEx_PeriphCLKConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80024d6:	497d      	ldr	r1, [pc, #500]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80024d8:	6c60      	ldr	r0, [r4, #68]	; 0x44
 80024da:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80024de:	f022 0203 	bic.w	r2, r2, #3
 80024e2:	4302      	orrs	r2, r0
 80024e4:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80024e8:	061f      	lsls	r7, r3, #24
 80024ea:	d508      	bpl.n	80024fe <HAL_RCCEx_PeriphCLKConfig+0x126>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80024ec:	4977      	ldr	r1, [pc, #476]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80024ee:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80024f0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80024f4:	f022 020c 	bic.w	r2, r2, #12
 80024f8:	4302      	orrs	r2, r0
 80024fa:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 80024fe:	05d8      	lsls	r0, r3, #23
 8002500:	d508      	bpl.n	8002514 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8002502:	4972      	ldr	r1, [pc, #456]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8002504:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8002506:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800250a:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 800250e:	4302      	orrs	r2, r0
 8002510:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8002514:	0599      	lsls	r1, r3, #22
 8002516:	d508      	bpl.n	800252a <HAL_RCCEx_PeriphCLKConfig+0x152>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8002518:	496c      	ldr	r1, [pc, #432]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800251a:	6d20      	ldr	r0, [r4, #80]	; 0x50
 800251c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002520:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8002524:	4302      	orrs	r2, r0
 8002526:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 800252a:	055a      	lsls	r2, r3, #21
 800252c:	d508      	bpl.n	8002540 <HAL_RCCEx_PeriphCLKConfig+0x168>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 800252e:	4967      	ldr	r1, [pc, #412]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8002530:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8002532:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002536:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800253a:	4302      	orrs	r2, r0
 800253c:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8002540:	051f      	lsls	r7, r3, #20
 8002542:	d508      	bpl.n	8002556 <HAL_RCCEx_PeriphCLKConfig+0x17e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8002544:	4961      	ldr	r1, [pc, #388]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8002546:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8002548:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800254c:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8002550:	4302      	orrs	r2, r0
 8002552:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8002556:	04d8      	lsls	r0, r3, #19
 8002558:	d508      	bpl.n	800256c <HAL_RCCEx_PeriphCLKConfig+0x194>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 800255a:	495c      	ldr	r1, [pc, #368]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800255c:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 800255e:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002562:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8002566:	4302      	orrs	r2, r0
 8002568:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 800256c:	0499      	lsls	r1, r3, #18
 800256e:	d508      	bpl.n	8002582 <HAL_RCCEx_PeriphCLKConfig+0x1aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8002570:	4956      	ldr	r1, [pc, #344]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8002572:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8002574:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8002578:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 800257c:	4302      	orrs	r2, r0
 800257e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8002582:	025a      	lsls	r2, r3, #9
 8002584:	d508      	bpl.n	8002598 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8002586:	4951      	ldr	r1, [pc, #324]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8002588:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800258a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 800258e:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8002592:	4302      	orrs	r2, r0
 8002594:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8002598:	029f      	lsls	r7, r3, #10
 800259a:	d50c      	bpl.n	80025b6 <HAL_RCCEx_PeriphCLKConfig+0x1de>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 800259c:	494b      	ldr	r1, [pc, #300]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800259e:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 80025a0:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
    {
      pllsaiused = 1;
 80025a4:	f1b0 6f00 	cmp.w	r0, #134217728	; 0x8000000
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 80025a8:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
      pllsaiused = 1;
 80025ac:	bf08      	it	eq
 80025ae:	2501      	moveq	r5, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 80025b0:	4302      	orrs	r2, r0
 80025b2:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  {
    pllsaiused = 1;
 80025b6:	f013 0f08 	tst.w	r3, #8
 80025ba:	bf18      	it	ne
 80025bc:	2501      	movne	r5, #1
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 80025be:	0358      	lsls	r0, r3, #13
 80025c0:	d508      	bpl.n	80025d4 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80025c2:	4942      	ldr	r1, [pc, #264]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80025c4:	6f60      	ldr	r0, [r4, #116]	; 0x74
 80025c6:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80025ca:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 80025ce:	4302      	orrs	r2, r0
 80025d0:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 80025d4:	0219      	lsls	r1, r3, #8
 80025d6:	d40b      	bmi.n	80025f0 <HAL_RCCEx_PeriphCLKConfig+0x218>
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 80025d8:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80025dc:	d016      	beq.n	800260c <HAL_RCCEx_PeriphCLKConfig+0x234>
 80025de:	07f2      	lsls	r2, r6, #31
 80025e0:	d414      	bmi.n	800260c <HAL_RCCEx_PeriphCLKConfig+0x234>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 80025e2:	2d01      	cmp	r5, #1
 80025e4:	f000 80d0 	beq.w	8002788 <HAL_RCCEx_PeriphCLKConfig+0x3b0>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 80025e8:	2000      	movs	r0, #0
}
 80025ea:	b003      	add	sp, #12
 80025ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80025f0:	4936      	ldr	r1, [pc, #216]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 80025f2:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80025f6:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 80025fa:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 80025fe:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8002602:	ea42 0200 	orr.w	r2, r2, r0
 8002606:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 800260a:	d1e8      	bne.n	80025de <HAL_RCCEx_PeriphCLKConfig+0x206>
    __HAL_RCC_PLLI2S_DISABLE();
 800260c:	4b2f      	ldr	r3, [pc, #188]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800260e:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8002610:	461e      	mov	r6, r3
    __HAL_RCC_PLLI2S_DISABLE();
 8002612:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8002616:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002618:	f7fd ffb4 	bl	8000584 <HAL_GetTick>
 800261c:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800261e:	e004      	b.n	800262a <HAL_RCCEx_PeriphCLKConfig+0x252>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8002620:	f7fd ffb0 	bl	8000584 <HAL_GetTick>
 8002624:	1bc0      	subs	r0, r0, r7
 8002626:	2864      	cmp	r0, #100	; 0x64
 8002628:	d85d      	bhi.n	80026e6 <HAL_RCCEx_PeriphCLKConfig+0x30e>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800262a:	6833      	ldr	r3, [r6, #0]
 800262c:	011b      	lsls	r3, r3, #4
 800262e:	d4f7      	bmi.n	8002620 <HAL_RCCEx_PeriphCLKConfig+0x248>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8002630:	6823      	ldr	r3, [r4, #0]
 8002632:	07df      	lsls	r7, r3, #31
 8002634:	d512      	bpl.n	800265c <HAL_RCCEx_PeriphCLKConfig+0x284>
 8002636:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002638:	b982      	cbnz	r2, 800265c <HAL_RCCEx_PeriphCLKConfig+0x284>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 800263a:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 800263e:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8002642:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8002646:	6860      	ldr	r0, [r4, #4]
 8002648:	f007 6770 	and.w	r7, r7, #251658240	; 0xf000000
 800264c:	68a1      	ldr	r1, [r4, #8]
 800264e:	433a      	orrs	r2, r7
 8002650:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8002654:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
 8002658:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 800265c:	031e      	lsls	r6, r3, #12
 800265e:	f100 8111 	bmi.w	8002884 <HAL_RCCEx_PeriphCLKConfig+0x4ac>
 8002662:	02d8      	lsls	r0, r3, #11
 8002664:	d504      	bpl.n	8002670 <HAL_RCCEx_PeriphCLKConfig+0x298>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 8002666:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8002668:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 800266c:	f000 810f 	beq.w	800288e <HAL_RCCEx_PeriphCLKConfig+0x4b6>
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8002670:	01d9      	lsls	r1, r3, #7
 8002672:	d511      	bpl.n	8002698 <HAL_RCCEx_PeriphCLKConfig+0x2c0>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8002674:	4e15      	ldr	r6, [pc, #84]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8002676:	6860      	ldr	r0, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8002678:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 800267c:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8002680:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8002684:	6921      	ldr	r1, [r4, #16]
 8002686:	f007 47e0 	and.w	r7, r7, #1879048192	; 0x70000000
 800268a:	433a      	orrs	r2, r7
 800268c:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 8002690:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8002694:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 8002698:	019a      	lsls	r2, r3, #6
 800269a:	d50d      	bpl.n	80026b8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 800269c:	6923      	ldr	r3, [r4, #16]
 800269e:	6862      	ldr	r2, [r4, #4]
 80026a0:	041b      	lsls	r3, r3, #16
 80026a2:	e9d4 1002 	ldrd	r1, r0, [r4, #8]
 80026a6:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 80026aa:	4a08      	ldr	r2, [pc, #32]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80026ac:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 80026b0:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 80026b4:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 80026b8:	4b04      	ldr	r3, [pc, #16]	; (80026cc <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80026ba:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80026bc:	461e      	mov	r6, r3
    __HAL_RCC_PLLI2S_ENABLE();
 80026be:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80026c2:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80026c4:	f7fd ff5e 	bl	8000584 <HAL_GetTick>
 80026c8:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80026ca:	e006      	b.n	80026da <HAL_RCCEx_PeriphCLKConfig+0x302>
 80026cc:	40023800 	.word	0x40023800
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 80026d0:	f7fd ff58 	bl	8000584 <HAL_GetTick>
 80026d4:	1bc0      	subs	r0, r0, r7
 80026d6:	2864      	cmp	r0, #100	; 0x64
 80026d8:	d805      	bhi.n	80026e6 <HAL_RCCEx_PeriphCLKConfig+0x30e>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80026da:	6833      	ldr	r3, [r6, #0]
 80026dc:	011b      	lsls	r3, r3, #4
 80026de:	d5f7      	bpl.n	80026d0 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
  if(pllsaiused == 1)
 80026e0:	2d01      	cmp	r5, #1
 80026e2:	d181      	bne.n	80025e8 <HAL_RCCEx_PeriphCLKConfig+0x210>
 80026e4:	e050      	b.n	8002788 <HAL_RCCEx_PeriphCLKConfig+0x3b0>
        return HAL_TIMEOUT;
 80026e6:	2003      	movs	r0, #3
}
 80026e8:	b003      	add	sp, #12
 80026ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 80026ee:	4a87      	ldr	r2, [pc, #540]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
    PWR->CR1 |= PWR_CR1_DBP;
 80026f0:	4b87      	ldr	r3, [pc, #540]	; (8002910 <HAL_RCCEx_PeriphCLKConfig+0x538>)
    __HAL_RCC_PWR_CLK_ENABLE();
 80026f2:	6c11      	ldr	r1, [r2, #64]	; 0x40
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 80026f4:	461f      	mov	r7, r3
    __HAL_RCC_PWR_CLK_ENABLE();
 80026f6:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80026fa:	6411      	str	r1, [r2, #64]	; 0x40
 80026fc:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80026fe:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8002702:	9201      	str	r2, [sp, #4]
 8002704:	9a01      	ldr	r2, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 8002706:	681a      	ldr	r2, [r3, #0]
 8002708:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800270c:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800270e:	f7fd ff39 	bl	8000584 <HAL_GetTick>
 8002712:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8002714:	e005      	b.n	8002722 <HAL_RCCEx_PeriphCLKConfig+0x34a>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002716:	f7fd ff35 	bl	8000584 <HAL_GetTick>
 800271a:	eba0 0008 	sub.w	r0, r0, r8
 800271e:	2864      	cmp	r0, #100	; 0x64
 8002720:	d8e1      	bhi.n	80026e6 <HAL_RCCEx_PeriphCLKConfig+0x30e>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8002722:	683b      	ldr	r3, [r7, #0]
 8002724:	05db      	lsls	r3, r3, #23
 8002726:	d5f6      	bpl.n	8002716 <HAL_RCCEx_PeriphCLKConfig+0x33e>
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8002728:	4a78      	ldr	r2, [pc, #480]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
 800272a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800272c:	6f11      	ldr	r1, [r2, #112]	; 0x70
 800272e:	f403 7040 	and.w	r0, r3, #768	; 0x300
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8002732:	f411 7140 	ands.w	r1, r1, #768	; 0x300
 8002736:	d011      	beq.n	800275c <HAL_RCCEx_PeriphCLKConfig+0x384>
 8002738:	4281      	cmp	r1, r0
 800273a:	d00f      	beq.n	800275c <HAL_RCCEx_PeriphCLKConfig+0x384>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800273c:	6f11      	ldr	r1, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 800273e:	6f17      	ldr	r7, [r2, #112]	; 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002740:	f421 7140 	bic.w	r1, r1, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8002744:	f447 3780 	orr.w	r7, r7, #65536	; 0x10000
 8002748:	6717      	str	r7, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 800274a:	6f17      	ldr	r7, [r2, #112]	; 0x70
 800274c:	f427 3780 	bic.w	r7, r7, #65536	; 0x10000
 8002750:	6717      	str	r7, [r2, #112]	; 0x70
      RCC->BDCR = tmpreg0;
 8002752:	6711      	str	r1, [r2, #112]	; 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8002754:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8002756:	07cf      	lsls	r7, r1, #31
 8002758:	f100 80c3 	bmi.w	80028e2 <HAL_RCCEx_PeriphCLKConfig+0x50a>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800275c:	f5b0 7f40 	cmp.w	r0, #768	; 0x300
 8002760:	f000 80b1 	beq.w	80028c6 <HAL_RCCEx_PeriphCLKConfig+0x4ee>
 8002764:	4969      	ldr	r1, [pc, #420]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
 8002766:	688a      	ldr	r2, [r1, #8]
 8002768:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 800276c:	608a      	str	r2, [r1, #8]
 800276e:	4a67      	ldr	r2, [pc, #412]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
 8002770:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002774:	6f11      	ldr	r1, [r2, #112]	; 0x70
 8002776:	430b      	orrs	r3, r1
 8002778:	6713      	str	r3, [r2, #112]	; 0x70
 800277a:	6823      	ldr	r3, [r4, #0]
 800277c:	e66e      	b.n	800245c <HAL_RCCEx_PeriphCLKConfig+0x84>
      plli2sused = 1;
 800277e:	2601      	movs	r6, #1
 8002780:	e665      	b.n	800244e <HAL_RCCEx_PeriphCLKConfig+0x76>
  uint32_t pllsaiused = 0;
 8002782:	2500      	movs	r5, #0
      plli2sused = 1;
 8002784:	2601      	movs	r6, #1
 8002786:	e64f      	b.n	8002428 <HAL_RCCEx_PeriphCLKConfig+0x50>
    __HAL_RCC_PLLSAI_DISABLE();
 8002788:	4b60      	ldr	r3, [pc, #384]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
 800278a:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 800278c:	461d      	mov	r5, r3
    __HAL_RCC_PLLSAI_DISABLE();
 800278e:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8002792:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002794:	f7fd fef6 	bl	8000584 <HAL_GetTick>
 8002798:	4606      	mov	r6, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 800279a:	e004      	b.n	80027a6 <HAL_RCCEx_PeriphCLKConfig+0x3ce>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 800279c:	f7fd fef2 	bl	8000584 <HAL_GetTick>
 80027a0:	1b80      	subs	r0, r0, r6
 80027a2:	2864      	cmp	r0, #100	; 0x64
 80027a4:	d89f      	bhi.n	80026e6 <HAL_RCCEx_PeriphCLKConfig+0x30e>
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80027a6:	682b      	ldr	r3, [r5, #0]
 80027a8:	009f      	lsls	r7, r3, #2
 80027aa:	d4f7      	bmi.n	800279c <HAL_RCCEx_PeriphCLKConfig+0x3c4>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 80027ac:	6823      	ldr	r3, [r4, #0]
 80027ae:	031d      	lsls	r5, r3, #12
 80027b0:	f100 8092 	bmi.w	80028d8 <HAL_RCCEx_PeriphCLKConfig+0x500>
 80027b4:	02d8      	lsls	r0, r3, #11
 80027b6:	d51d      	bpl.n	80027f4 <HAL_RCCEx_PeriphCLKConfig+0x41c>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 80027b8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80027ba:	b9da      	cbnz	r2, 80027f4 <HAL_RCCEx_PeriphCLKConfig+0x41c>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80027bc:	4953      	ldr	r1, [pc, #332]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 80027be:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80027c0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 80027c4:	f8d1 6088 	ldr.w	r6, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 80027c8:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 80027cc:	69a0      	ldr	r0, [r4, #24]
 80027ce:	f006 46e0 	and.w	r6, r6, #1879048192	; 0x70000000
 80027d2:	4332      	orrs	r2, r6
 80027d4:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
 80027d8:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 80027dc:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 80027e0:	f8d1 208c 	ldr.w	r2, [r1, #140]	; 0x8c
 80027e4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80027e6:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 80027ea:	3801      	subs	r0, #1
 80027ec:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80027f0:	f8c1 208c 	str.w	r2, [r1, #140]	; 0x8c
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 80027f4:	0299      	lsls	r1, r3, #10
 80027f6:	d515      	bpl.n	8002824 <HAL_RCCEx_PeriphCLKConfig+0x44c>
 80027f8:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 80027fa:	f1b2 6f00 	cmp.w	r2, #134217728	; 0x8000000
 80027fe:	d111      	bne.n	8002824 <HAL_RCCEx_PeriphCLKConfig+0x44c>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8002800:	4942      	ldr	r1, [pc, #264]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8002802:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8002804:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8002808:	f8d1 6088 	ldr.w	r6, [r1, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 800280c:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 8002810:	6a20      	ldr	r0, [r4, #32]
 8002812:	f006 46e0 	and.w	r6, r6, #1879048192	; 0x70000000
 8002816:	4332      	orrs	r2, r6
 8002818:	ea42 1285 	orr.w	r2, r2, r5, lsl #6
 800281c:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8002820:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8002824:	071a      	lsls	r2, r3, #28
 8002826:	d519      	bpl.n	800285c <HAL_RCCEx_PeriphCLKConfig+0x484>
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8002828:	4a38      	ldr	r2, [pc, #224]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 800282a:	6965      	ldr	r5, [r4, #20]
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 800282c:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8002830:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8002834:	f001 6170 	and.w	r1, r1, #251658240	; 0xf000000
 8002838:	69e0      	ldr	r0, [r4, #28]
 800283a:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 800283e:	430b      	orrs	r3, r1
 8002840:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
 8002844:	ea43 7300 	orr.w	r3, r3, r0, lsl #28
 8002848:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 800284c:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
 8002850:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8002852:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8002856:	430b      	orrs	r3, r1
 8002858:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_PLLSAI_ENABLE();
 800285c:	4b2b      	ldr	r3, [pc, #172]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
 800285e:	681a      	ldr	r2, [r3, #0]
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8002860:	461c      	mov	r4, r3
    __HAL_RCC_PLLSAI_ENABLE();
 8002862:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002866:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8002868:	f7fd fe8c 	bl	8000584 <HAL_GetTick>
 800286c:	4605      	mov	r5, r0
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800286e:	e005      	b.n	800287c <HAL_RCCEx_PeriphCLKConfig+0x4a4>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8002870:	f7fd fe88 	bl	8000584 <HAL_GetTick>
 8002874:	1b40      	subs	r0, r0, r5
 8002876:	2864      	cmp	r0, #100	; 0x64
 8002878:	f63f af35 	bhi.w	80026e6 <HAL_RCCEx_PeriphCLKConfig+0x30e>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800287c:	6823      	ldr	r3, [r4, #0]
 800287e:	009b      	lsls	r3, r3, #2
 8002880:	d5f6      	bpl.n	8002870 <HAL_RCCEx_PeriphCLKConfig+0x498>
 8002882:	e6b1      	b.n	80025e8 <HAL_RCCEx_PeriphCLKConfig+0x210>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8002884:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8002886:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 800288a:	f47f aeea 	bne.w	8002662 <HAL_RCCEx_PeriphCLKConfig+0x28a>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 800288e:	4e1f      	ldr	r6, [pc, #124]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8002890:	6860      	ldr	r0, [r4, #4]
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8002892:	f8d6 2084 	ldr.w	r2, [r6, #132]	; 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8002896:	f8d6 7084 	ldr.w	r7, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 800289a:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 800289e:	68e1      	ldr	r1, [r4, #12]
 80028a0:	f007 47e0 	and.w	r7, r7, #1879048192	; 0x70000000
 80028a4:	433a      	orrs	r2, r7
 80028a6:	ea42 1280 	orr.w	r2, r2, r0, lsl #6
 80028aa:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 80028ae:	f8c6 2084 	str.w	r2, [r6, #132]	; 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 80028b2:	f8d6 108c 	ldr.w	r1, [r6, #140]	; 0x8c
 80028b6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80028b8:	f021 011f 	bic.w	r1, r1, #31
 80028bc:	3a01      	subs	r2, #1
 80028be:	430a      	orrs	r2, r1
 80028c0:	f8c6 208c 	str.w	r2, [r6, #140]	; 0x8c
 80028c4:	e6d4      	b.n	8002670 <HAL_RCCEx_PeriphCLKConfig+0x298>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80028c6:	4811      	ldr	r0, [pc, #68]	; (800290c <HAL_RCCEx_PeriphCLKConfig+0x534>)
 80028c8:	4912      	ldr	r1, [pc, #72]	; (8002914 <HAL_RCCEx_PeriphCLKConfig+0x53c>)
 80028ca:	6882      	ldr	r2, [r0, #8]
 80028cc:	4019      	ands	r1, r3
 80028ce:	f422 12f8 	bic.w	r2, r2, #2031616	; 0x1f0000
 80028d2:	430a      	orrs	r2, r1
 80028d4:	6082      	str	r2, [r0, #8]
 80028d6:	e74a      	b.n	800276e <HAL_RCCEx_PeriphCLKConfig+0x396>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 80028d8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80028da:	2a00      	cmp	r2, #0
 80028dc:	f43f af6e 	beq.w	80027bc <HAL_RCCEx_PeriphCLKConfig+0x3e4>
 80028e0:	e768      	b.n	80027b4 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80028e2:	4617      	mov	r7, r2
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80028e4:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
 80028e8:	f7fd fe4c 	bl	8000584 <HAL_GetTick>
 80028ec:	4681      	mov	r9, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80028ee:	e006      	b.n	80028fe <HAL_RCCEx_PeriphCLKConfig+0x526>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80028f0:	f7fd fe48 	bl	8000584 <HAL_GetTick>
 80028f4:	eba0 0009 	sub.w	r0, r0, r9
 80028f8:	4540      	cmp	r0, r8
 80028fa:	f63f aef4 	bhi.w	80026e6 <HAL_RCCEx_PeriphCLKConfig+0x30e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80028fe:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8002900:	0798      	lsls	r0, r3, #30
 8002902:	d5f5      	bpl.n	80028f0 <HAL_RCCEx_PeriphCLKConfig+0x518>
 8002904:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002906:	f403 7040 	and.w	r0, r3, #768	; 0x300
 800290a:	e727      	b.n	800275c <HAL_RCCEx_PeriphCLKConfig+0x384>
 800290c:	40023800 	.word	0x40023800
 8002910:	40007000 	.word	0x40007000
 8002914:	0ffffcff 	.word	0x0ffffcff

08002918 <HAL_TIM_Base_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8002918:	2800      	cmp	r0, #0
 800291a:	d065      	beq.n	80029e8 <HAL_TIM_Base_Init+0xd0>
{
 800291c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800291e:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002922:	4604      	mov	r4, r0
 8002924:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002928:	2b00      	cmp	r3, #0
 800292a:	d03b      	beq.n	80029a4 <HAL_TIM_Base_Init+0x8c>

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800292c:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 800292e:	2002      	movs	r0, #2
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002930:	4e36      	ldr	r6, [pc, #216]	; (8002a0c <HAL_TIM_Base_Init+0xf4>)
 8002932:	4f37      	ldr	r7, [pc, #220]	; (8002a10 <HAL_TIM_Base_Init+0xf8>)
 8002934:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8002938:	eba2 0606 	sub.w	r6, r2, r6
  htim->State = HAL_TIM_STATE_BUSY;
 800293c:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
 8002940:	eba2 0707 	sub.w	r7, r2, r7
  tmpcr1 = TIMx->CR1;
 8002944:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002946:	fab6 f686 	clz	r6, r6
 800294a:	fab7 f787 	clz	r7, r7
 800294e:	ea4f 1656 	mov.w	r6, r6, lsr #5
 8002952:	ea4f 1757 	mov.w	r7, r7, lsr #5
 8002956:	d02a      	beq.n	80029ae <HAL_TIM_Base_Init+0x96>
 8002958:	bb4e      	cbnz	r6, 80029ae <HAL_TIM_Base_Init+0x96>
 800295a:	492e      	ldr	r1, [pc, #184]	; (8002a14 <HAL_TIM_Base_Init+0xfc>)
 800295c:	428a      	cmp	r2, r1
 800295e:	d045      	beq.n	80029ec <HAL_TIM_Base_Init+0xd4>
 8002960:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8002964:	428a      	cmp	r2, r1
 8002966:	d041      	beq.n	80029ec <HAL_TIM_Base_Init+0xd4>
 8002968:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800296c:	428a      	cmp	r2, r1
 800296e:	d042      	beq.n	80029f6 <HAL_TIM_Base_Init+0xde>
 8002970:	2f00      	cmp	r7, #0
 8002972:	d140      	bne.n	80029f6 <HAL_TIM_Base_Init+0xde>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002974:	4928      	ldr	r1, [pc, #160]	; (8002a18 <HAL_TIM_Base_Init+0x100>)
 8002976:	428a      	cmp	r2, r1
 8002978:	d01e      	beq.n	80029b8 <HAL_TIM_Base_Init+0xa0>
 800297a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800297e:	428a      	cmp	r2, r1
 8002980:	d01a      	beq.n	80029b8 <HAL_TIM_Base_Init+0xa0>
 8002982:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8002986:	428a      	cmp	r2, r1
 8002988:	d016      	beq.n	80029b8 <HAL_TIM_Base_Init+0xa0>
 800298a:	f5a1 3198 	sub.w	r1, r1, #77824	; 0x13000
 800298e:	428a      	cmp	r2, r1
 8002990:	d012      	beq.n	80029b8 <HAL_TIM_Base_Init+0xa0>
 8002992:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8002996:	428a      	cmp	r2, r1
 8002998:	d00e      	beq.n	80029b8 <HAL_TIM_Base_Init+0xa0>
 800299a:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800299e:	428a      	cmp	r2, r1
 80029a0:	d10e      	bne.n	80029c0 <HAL_TIM_Base_Init+0xa8>
 80029a2:	e009      	b.n	80029b8 <HAL_TIM_Base_Init+0xa0>
    htim->Lock = HAL_UNLOCKED;
 80029a4:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 80029a8:	f005 ff68 	bl	800887c <HAL_TIM_Base_MspInit>
 80029ac:	e7be      	b.n	800292c <HAL_TIM_Base_Init+0x14>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80029ae:	f023 0570 	bic.w	r5, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80029b2:	68a0      	ldr	r0, [r4, #8]
 80029b4:	ea45 0300 	orr.w	r3, r5, r0
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 80029b8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 80029bc:	6920      	ldr	r0, [r4, #16]
 80029be:	4303      	orrs	r3, r0
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80029c0:	69a1      	ldr	r1, [r4, #24]
 80029c2:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  TIMx->CR1 = tmpcr1;

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 80029c6:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 80029c8:	430b      	orrs	r3, r1

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 80029ca:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 80029cc:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 80029ce:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 80029d0:	6291      	str	r1, [r2, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 80029d2:	b936      	cbnz	r6, 80029e2 <HAL_TIM_Base_Init+0xca>
 80029d4:	b92f      	cbnz	r7, 80029e2 <HAL_TIM_Base_Init+0xca>
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80029d6:	2301      	movs	r3, #1
  return HAL_OK;
 80029d8:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 80029da:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 80029dc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 80029e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TIMx->RCR = Structure->RepetitionCounter;
 80029e2:	6963      	ldr	r3, [r4, #20]
 80029e4:	6313      	str	r3, [r2, #48]	; 0x30
 80029e6:	e7f6      	b.n	80029d6 <HAL_TIM_Base_Init+0xbe>
    return HAL_ERROR;
 80029e8:	2001      	movs	r0, #1
}
 80029ea:	4770      	bx	lr
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80029ec:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80029f0:	68a1      	ldr	r1, [r4, #8]
 80029f2:	430b      	orrs	r3, r1
 80029f4:	e7e0      	b.n	80029b8 <HAL_TIM_Base_Init+0xa0>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80029f6:	4909      	ldr	r1, [pc, #36]	; (8002a1c <HAL_TIM_Base_Init+0x104>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80029f8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 80029fc:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80029fe:	428a      	cmp	r2, r1
    tmpcr1 |= Structure->CounterMode;
 8002a00:	ea43 0300 	orr.w	r3, r3, r0
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002a04:	d0d8      	beq.n	80029b8 <HAL_TIM_Base_Init+0xa0>
 8002a06:	2f00      	cmp	r7, #0
 8002a08:	d1d6      	bne.n	80029b8 <HAL_TIM_Base_Init+0xa0>
 8002a0a:	e7b3      	b.n	8002974 <HAL_TIM_Base_Init+0x5c>
 8002a0c:	40010000 	.word	0x40010000
 8002a10:	40010400 	.word	0x40010400
 8002a14:	40000400 	.word	0x40000400
 8002a18:	40014000 	.word	0x40014000
 8002a1c:	40000c00 	.word	0x40000c00

08002a20 <HAL_TIM_Base_Start_IT>:
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002a20:	6803      	ldr	r3, [r0, #0]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8002a22:	4a09      	ldr	r2, [pc, #36]	; (8002a48 <HAL_TIM_Base_Start_IT+0x28>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002a24:	68d9      	ldr	r1, [r3, #12]
 8002a26:	f041 0101 	orr.w	r1, r1, #1
 8002a2a:	60d9      	str	r1, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8002a2c:	6899      	ldr	r1, [r3, #8]
 8002a2e:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8002a30:	2a06      	cmp	r2, #6
 8002a32:	d006      	beq.n	8002a42 <HAL_TIM_Base_Start_IT+0x22>
 8002a34:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8002a38:	d003      	beq.n	8002a42 <HAL_TIM_Base_Start_IT+0x22>
    __HAL_TIM_ENABLE(htim);
 8002a3a:	681a      	ldr	r2, [r3, #0]
 8002a3c:	f042 0201 	orr.w	r2, r2, #1
 8002a40:	601a      	str	r2, [r3, #0]
}
 8002a42:	2000      	movs	r0, #0
 8002a44:	4770      	bx	lr
 8002a46:	bf00      	nop
 8002a48:	00010007 	.word	0x00010007

08002a4c <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 8002a4c:	2800      	cmp	r0, #0
 8002a4e:	d065      	beq.n	8002b1c <HAL_TIM_PWM_Init+0xd0>
{
 8002a50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8002a52:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002a56:	4604      	mov	r4, r0
 8002a58:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002a5c:	2b00      	cmp	r3, #0
 8002a5e:	d03b      	beq.n	8002ad8 <HAL_TIM_PWM_Init+0x8c>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002a60:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8002a62:	2002      	movs	r0, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002a64:	4e36      	ldr	r6, [pc, #216]	; (8002b40 <HAL_TIM_PWM_Init+0xf4>)
 8002a66:	4f37      	ldr	r7, [pc, #220]	; (8002b44 <HAL_TIM_PWM_Init+0xf8>)
 8002a68:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8002a6c:	eba2 0606 	sub.w	r6, r2, r6
  htim->State = HAL_TIM_STATE_BUSY;
 8002a70:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
 8002a74:	eba2 0707 	sub.w	r7, r2, r7
  tmpcr1 = TIMx->CR1;
 8002a78:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002a7a:	fab6 f686 	clz	r6, r6
 8002a7e:	fab7 f787 	clz	r7, r7
 8002a82:	ea4f 1656 	mov.w	r6, r6, lsr #5
 8002a86:	ea4f 1757 	mov.w	r7, r7, lsr #5
 8002a8a:	d02a      	beq.n	8002ae2 <HAL_TIM_PWM_Init+0x96>
 8002a8c:	bb4e      	cbnz	r6, 8002ae2 <HAL_TIM_PWM_Init+0x96>
 8002a8e:	492e      	ldr	r1, [pc, #184]	; (8002b48 <HAL_TIM_PWM_Init+0xfc>)
 8002a90:	428a      	cmp	r2, r1
 8002a92:	d045      	beq.n	8002b20 <HAL_TIM_PWM_Init+0xd4>
 8002a94:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8002a98:	428a      	cmp	r2, r1
 8002a9a:	d041      	beq.n	8002b20 <HAL_TIM_PWM_Init+0xd4>
 8002a9c:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8002aa0:	428a      	cmp	r2, r1
 8002aa2:	d042      	beq.n	8002b2a <HAL_TIM_PWM_Init+0xde>
 8002aa4:	2f00      	cmp	r7, #0
 8002aa6:	d140      	bne.n	8002b2a <HAL_TIM_PWM_Init+0xde>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002aa8:	4928      	ldr	r1, [pc, #160]	; (8002b4c <HAL_TIM_PWM_Init+0x100>)
 8002aaa:	428a      	cmp	r2, r1
 8002aac:	d01e      	beq.n	8002aec <HAL_TIM_PWM_Init+0xa0>
 8002aae:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8002ab2:	428a      	cmp	r2, r1
 8002ab4:	d01a      	beq.n	8002aec <HAL_TIM_PWM_Init+0xa0>
 8002ab6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8002aba:	428a      	cmp	r2, r1
 8002abc:	d016      	beq.n	8002aec <HAL_TIM_PWM_Init+0xa0>
 8002abe:	f5a1 3198 	sub.w	r1, r1, #77824	; 0x13000
 8002ac2:	428a      	cmp	r2, r1
 8002ac4:	d012      	beq.n	8002aec <HAL_TIM_PWM_Init+0xa0>
 8002ac6:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8002aca:	428a      	cmp	r2, r1
 8002acc:	d00e      	beq.n	8002aec <HAL_TIM_PWM_Init+0xa0>
 8002ace:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 8002ad2:	428a      	cmp	r2, r1
 8002ad4:	d10e      	bne.n	8002af4 <HAL_TIM_PWM_Init+0xa8>
 8002ad6:	e009      	b.n	8002aec <HAL_TIM_PWM_Init+0xa0>
    htim->Lock = HAL_UNLOCKED;
 8002ad8:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8002adc:	f005 fe44 	bl	8008768 <HAL_TIM_PWM_MspInit>
 8002ae0:	e7be      	b.n	8002a60 <HAL_TIM_PWM_Init+0x14>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002ae2:	f023 0570 	bic.w	r5, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8002ae6:	68a0      	ldr	r0, [r4, #8]
 8002ae8:	ea45 0300 	orr.w	r3, r5, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 8002aec:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002af0:	6920      	ldr	r0, [r4, #16]
 8002af2:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002af4:	69a1      	ldr	r1, [r4, #24]
 8002af6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002afa:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002afc:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 8002afe:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 8002b00:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002b02:	62d0      	str	r0, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8002b04:	6291      	str	r1, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8002b06:	b936      	cbnz	r6, 8002b16 <HAL_TIM_PWM_Init+0xca>
 8002b08:	b92f      	cbnz	r7, 8002b16 <HAL_TIM_PWM_Init+0xca>
  TIMx->EGR = TIM_EGR_UG;
 8002b0a:	2301      	movs	r3, #1
  return HAL_OK;
 8002b0c:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 8002b0e:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 8002b10:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 8002b14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TIMx->RCR = Structure->RepetitionCounter;
 8002b16:	6963      	ldr	r3, [r4, #20]
 8002b18:	6313      	str	r3, [r2, #48]	; 0x30
 8002b1a:	e7f6      	b.n	8002b0a <HAL_TIM_PWM_Init+0xbe>
    return HAL_ERROR;
 8002b1c:	2001      	movs	r0, #1
}
 8002b1e:	4770      	bx	lr
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002b20:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8002b24:	68a1      	ldr	r1, [r4, #8]
 8002b26:	430b      	orrs	r3, r1
 8002b28:	e7e0      	b.n	8002aec <HAL_TIM_PWM_Init+0xa0>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002b2a:	4909      	ldr	r1, [pc, #36]	; (8002b50 <HAL_TIM_PWM_Init+0x104>)
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002b2c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8002b30:	68a0      	ldr	r0, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002b32:	428a      	cmp	r2, r1
    tmpcr1 |= Structure->CounterMode;
 8002b34:	ea43 0300 	orr.w	r3, r3, r0
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002b38:	d0d8      	beq.n	8002aec <HAL_TIM_PWM_Init+0xa0>
 8002b3a:	2f00      	cmp	r7, #0
 8002b3c:	d1d6      	bne.n	8002aec <HAL_TIM_PWM_Init+0xa0>
 8002b3e:	e7b3      	b.n	8002aa8 <HAL_TIM_PWM_Init+0x5c>
 8002b40:	40010000 	.word	0x40010000
 8002b44:	40010400 	.word	0x40010400
 8002b48:	40000400 	.word	0x40000400
 8002b4c:	40014000 	.word	0x40014000
 8002b50:	40000c00 	.word	0x40000c00

08002b54 <HAL_TIM_PWM_Start>:
 8002b54:	6803      	ldr	r3, [r0, #0]
 8002b56:	2201      	movs	r2, #1
 8002b58:	f001 011f 	and.w	r1, r1, #31
 8002b5c:	6a18      	ldr	r0, [r3, #32]
 8002b5e:	fa02 f101 	lsl.w	r1, r2, r1
 8002b62:	ea20 0001 	bic.w	r0, r0, r1
 8002b66:	b410      	push	{r4}
 8002b68:	6218      	str	r0, [r3, #32]
 8002b6a:	4c0f      	ldr	r4, [pc, #60]	; (8002ba8 <HAL_TIM_PWM_Start+0x54>)
 8002b6c:	6a1a      	ldr	r2, [r3, #32]
 8002b6e:	42a3      	cmp	r3, r4
 8002b70:	ea41 0102 	orr.w	r1, r1, r2
 8002b74:	6219      	str	r1, [r3, #32]
 8002b76:	d012      	beq.n	8002b9e <HAL_TIM_PWM_Start+0x4a>
 8002b78:	4a0c      	ldr	r2, [pc, #48]	; (8002bac <HAL_TIM_PWM_Start+0x58>)
 8002b7a:	4293      	cmp	r3, r2
 8002b7c:	d00f      	beq.n	8002b9e <HAL_TIM_PWM_Start+0x4a>
 8002b7e:	6899      	ldr	r1, [r3, #8]
 8002b80:	4a0b      	ldr	r2, [pc, #44]	; (8002bb0 <HAL_TIM_PWM_Start+0x5c>)
 8002b82:	400a      	ands	r2, r1
 8002b84:	2a06      	cmp	r2, #6
 8002b86:	d006      	beq.n	8002b96 <HAL_TIM_PWM_Start+0x42>
 8002b88:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8002b8c:	d003      	beq.n	8002b96 <HAL_TIM_PWM_Start+0x42>
 8002b8e:	681a      	ldr	r2, [r3, #0]
 8002b90:	f042 0201 	orr.w	r2, r2, #1
 8002b94:	601a      	str	r2, [r3, #0]
 8002b96:	2000      	movs	r0, #0
 8002b98:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b9c:	4770      	bx	lr
 8002b9e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002ba0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002ba4:	645a      	str	r2, [r3, #68]	; 0x44
 8002ba6:	e7ea      	b.n	8002b7e <HAL_TIM_PWM_Start+0x2a>
 8002ba8:	40010000 	.word	0x40010000
 8002bac:	40010400 	.word	0x40010400
 8002bb0:	00010007 	.word	0x00010007

08002bb4 <HAL_TIM_PWM_Stop>:
{
 8002bb4:	b410      	push	{r4}
 8002bb6:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8002bb8:	f001 011f 	and.w	r1, r1, #31
 8002bbc:	2201      	movs	r2, #1
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8002bbe:	4819      	ldr	r0, [pc, #100]	; (8002c24 <HAL_TIM_PWM_Stop+0x70>)
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 8002bc0:	6823      	ldr	r3, [r4, #0]
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8002bc2:	408a      	lsls	r2, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8002bc4:	6a19      	ldr	r1, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8002bc6:	4283      	cmp	r3, r0
  TIMx->CCER &= ~tmp;
 8002bc8:	ea21 0102 	bic.w	r1, r1, r2
 8002bcc:	6219      	str	r1, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8002bce:	6a1a      	ldr	r2, [r3, #32]
 8002bd0:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8002bd2:	d017      	beq.n	8002c04 <HAL_TIM_PWM_Stop+0x50>
 8002bd4:	4a14      	ldr	r2, [pc, #80]	; (8002c28 <HAL_TIM_PWM_Stop+0x74>)
 8002bd6:	4293      	cmp	r3, r2
 8002bd8:	d014      	beq.n	8002c04 <HAL_TIM_PWM_Stop+0x50>
  __HAL_TIM_DISABLE(htim);
 8002bda:	6a19      	ldr	r1, [r3, #32]
 8002bdc:	f241 1211 	movw	r2, #4369	; 0x1111
 8002be0:	4211      	tst	r1, r2
 8002be2:	d108      	bne.n	8002bf6 <HAL_TIM_PWM_Stop+0x42>
 8002be4:	6a19      	ldr	r1, [r3, #32]
 8002be6:	f240 4244 	movw	r2, #1092	; 0x444
 8002bea:	4211      	tst	r1, r2
 8002bec:	d103      	bne.n	8002bf6 <HAL_TIM_PWM_Stop+0x42>
 8002bee:	681a      	ldr	r2, [r3, #0]
 8002bf0:	f022 0201 	bic.w	r2, r2, #1
 8002bf4:	601a      	str	r2, [r3, #0]
  htim->State = HAL_TIM_STATE_READY;
 8002bf6:	2301      	movs	r3, #1
}
 8002bf8:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8002bfa:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 8002bfe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002c02:	4770      	bx	lr
    __HAL_TIM_MOE_DISABLE(htim);
 8002c04:	6a19      	ldr	r1, [r3, #32]
 8002c06:	f241 1211 	movw	r2, #4369	; 0x1111
 8002c0a:	4211      	tst	r1, r2
 8002c0c:	d1e5      	bne.n	8002bda <HAL_TIM_PWM_Stop+0x26>
 8002c0e:	6a19      	ldr	r1, [r3, #32]
 8002c10:	f240 4244 	movw	r2, #1092	; 0x444
 8002c14:	4211      	tst	r1, r2
 8002c16:	d1e0      	bne.n	8002bda <HAL_TIM_PWM_Stop+0x26>
 8002c18:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002c1a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8002c1e:	645a      	str	r2, [r3, #68]	; 0x44
 8002c20:	e7db      	b.n	8002bda <HAL_TIM_PWM_Stop+0x26>
 8002c22:	bf00      	nop
 8002c24:	40010000 	.word	0x40010000
 8002c28:	40010400 	.word	0x40010400

08002c2c <HAL_TIM_PWM_ConfigChannel>:
{
 8002c2c:	4603      	mov	r3, r0
  __HAL_LOCK(htim);
 8002c2e:	f890 003c 	ldrb.w	r0, [r0, #60]	; 0x3c
 8002c32:	2801      	cmp	r0, #1
 8002c34:	f000 813e 	beq.w	8002eb4 <HAL_TIM_PWM_ConfigChannel+0x288>
  htim->State = HAL_TIM_STATE_BUSY;
 8002c38:	2002      	movs	r0, #2
{
 8002c3a:	b4f0      	push	{r4, r5, r6, r7}
  __HAL_LOCK(htim);
 8002c3c:	2401      	movs	r4, #1
  htim->State = HAL_TIM_STATE_BUSY;
 8002c3e:	f883 003d 	strb.w	r0, [r3, #61]	; 0x3d
  __HAL_LOCK(htim);
 8002c42:	f883 403c 	strb.w	r4, [r3, #60]	; 0x3c
  switch (Channel)
 8002c46:	2a14      	cmp	r2, #20
 8002c48:	d843      	bhi.n	8002cd2 <HAL_TIM_PWM_ConfigChannel+0xa6>
 8002c4a:	e8df f012 	tbh	[pc, r2, lsl #1]
 8002c4e:	0015      	.short	0x0015
 8002c50:	00420042 	.word	0x00420042
 8002c54:	007b0042 	.word	0x007b0042
 8002c58:	00420042 	.word	0x00420042
 8002c5c:	00da0042 	.word	0x00da0042
 8002c60:	00420042 	.word	0x00420042
 8002c64:	00aa0042 	.word	0x00aa0042
 8002c68:	00420042 	.word	0x00420042
 8002c6c:	01060042 	.word	0x01060042
 8002c70:	00420042 	.word	0x00420042
 8002c74:	004b0042 	.word	0x004b0042
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8002c78:	681a      	ldr	r2, [r3, #0]
  tmpccer |= OC_Config->OCPolarity;
 8002c7a:	f8d1 c008 	ldr.w	ip, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002c7e:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= OC_Config->OCMode;
 8002c80:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002c82:	f025 0501 	bic.w	r5, r5, #1
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8002c86:	4cab      	ldr	r4, [pc, #684]	; (8002f34 <HAL_TIM_PWM_ConfigChannel+0x308>)
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002c88:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 8002c8a:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8002c8c:	6856      	ldr	r6, [r2, #4]
  tmpccmrx = TIMx->CCMR1;
 8002c8e:	6995      	ldr	r5, [r2, #24]
  tmpccer &= ~TIM_CCER_CC1P;
 8002c90:	f020 0002 	bic.w	r0, r0, #2
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8002c94:	402c      	ands	r4, r5
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8002c96:	4da8      	ldr	r5, [pc, #672]	; (8002f38 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccer |= OC_Config->OCPolarity;
 8002c98:	ea40 000c 	orr.w	r0, r0, ip
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8002c9c:	42aa      	cmp	r2, r5
  tmpccmrx |= OC_Config->OCMode;
 8002c9e:	ea44 0407 	orr.w	r4, r4, r7
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8002ca2:	f000 8115 	beq.w	8002ed0 <HAL_TIM_PWM_ConfigChannel+0x2a4>
 8002ca6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002caa:	42aa      	cmp	r2, r5
 8002cac:	f000 8110 	beq.w	8002ed0 <HAL_TIM_PWM_ConfigChannel+0x2a4>
  TIMx->CCR1 = OC_Config->Pulse;
 8002cb0:	684d      	ldr	r5, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8002cb2:	6056      	str	r6, [r2, #4]
  TIMx->CCMR1 = tmpccmrx;
 8002cb4:	6194      	str	r4, [r2, #24]
  TIMx->CCR1 = OC_Config->Pulse;
 8002cb6:	6355      	str	r5, [r2, #52]	; 0x34
  TIMx->CCER = tmpccer;
 8002cb8:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8002cba:	6990      	ldr	r0, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8002cbc:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8002cbe:	f040 0008 	orr.w	r0, r0, #8
 8002cc2:	6190      	str	r0, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8002cc4:	6990      	ldr	r0, [r2, #24]
 8002cc6:	f020 0004 	bic.w	r0, r0, #4
 8002cca:	6190      	str	r0, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8002ccc:	6991      	ldr	r1, [r2, #24]
 8002cce:	4321      	orrs	r1, r4
 8002cd0:	6191      	str	r1, [r2, #24]
  __HAL_UNLOCK(htim);
 8002cd2:	2200      	movs	r2, #0
  htim->State = HAL_TIM_STATE_READY;
 8002cd4:	2101      	movs	r1, #1
  return HAL_OK;
 8002cd6:	4610      	mov	r0, r2
  htim->State = HAL_TIM_STATE_READY;
 8002cd8:	f883 103d 	strb.w	r1, [r3, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8002cdc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 8002ce0:	bcf0      	pop	{r4, r5, r6, r7}
 8002ce2:	4770      	bx	lr
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8002ce4:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8002ce6:	688e      	ldr	r6, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8002ce8:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002cea:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8002cec:	f425 1580 	bic.w	r5, r5, #1048576	; 0x100000
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8002cf0:	4c92      	ldr	r4, [pc, #584]	; (8002f3c <HAL_TIM_PWM_ConfigChannel+0x310>)
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8002cf2:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 8002cf4:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8002cf6:	6855      	ldr	r5, [r2, #4]
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8002cf8:	f420 1000 	bic.w	r0, r0, #2097152	; 0x200000
  tmpccmrx = TIMx->CCMR3;
 8002cfc:	f8d2 c054 	ldr.w	ip, [r2, #84]	; 0x54
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8002d00:	ea40 5006 	orr.w	r0, r0, r6, lsl #20
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002d04:	4e8c      	ldr	r6, [pc, #560]	; (8002f38 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8002d06:	ea0c 0404 	and.w	r4, ip, r4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002d0a:	42b2      	cmp	r2, r6
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002d0c:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002d10:	f000 80d2 	beq.w	8002eb8 <HAL_TIM_PWM_ConfigChannel+0x28c>
 8002d14:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8002d18:	42b2      	cmp	r2, r6
 8002d1a:	f000 80cd 	beq.w	8002eb8 <HAL_TIM_PWM_ConfigChannel+0x28c>
  TIMx->CCR6 = OC_Config->Pulse;
 8002d1e:	684e      	ldr	r6, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8002d20:	6055      	str	r5, [r2, #4]
  TIMx->CCMR3 = tmpccmrx;
 8002d22:	6554      	str	r4, [r2, #84]	; 0x54
  TIMx->CCR6 = OC_Config->Pulse;
 8002d24:	65d6      	str	r6, [r2, #92]	; 0x5c
  TIMx->CCER = tmpccer;
 8002d26:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8002d28:	6d50      	ldr	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8002d2a:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8002d2c:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 8002d30:	6550      	str	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8002d32:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8002d34:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 8002d38:	6550      	str	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8002d3a:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8002d3c:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 8002d40:	6551      	str	r1, [r2, #84]	; 0x54
      break;
 8002d42:	e7c6      	b.n	8002cd2 <HAL_TIM_PWM_ConfigChannel+0xa6>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8002d44:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8002d46:	f8d1 c008 	ldr.w	ip, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8002d4a:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002d4c:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8002d4e:	f025 0510 	bic.w	r5, r5, #16
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8002d52:	4c7b      	ldr	r4, [pc, #492]	; (8002f40 <HAL_TIM_PWM_ConfigChannel+0x314>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8002d54:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 8002d56:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8002d58:	6856      	ldr	r6, [r2, #4]
  tmpccmrx = TIMx->CCMR1;
 8002d5a:	6995      	ldr	r5, [r2, #24]
  tmpccer &= ~TIM_CCER_CC2P;
 8002d5c:	f020 0020 	bic.w	r0, r0, #32
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8002d60:	402c      	ands	r4, r5
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8002d62:	4d75      	ldr	r5, [pc, #468]	; (8002f38 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8002d64:	ea40 100c 	orr.w	r0, r0, ip, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8002d68:	42aa      	cmp	r2, r5
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002d6a:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8002d6e:	f000 80c3 	beq.w	8002ef8 <HAL_TIM_PWM_ConfigChannel+0x2cc>
 8002d72:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002d76:	42aa      	cmp	r2, r5
 8002d78:	f000 80be 	beq.w	8002ef8 <HAL_TIM_PWM_ConfigChannel+0x2cc>
  TIMx->CCR2 = OC_Config->Pulse;
 8002d7c:	684d      	ldr	r5, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8002d7e:	6056      	str	r6, [r2, #4]
  TIMx->CCMR1 = tmpccmrx;
 8002d80:	6194      	str	r4, [r2, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8002d82:	6395      	str	r5, [r2, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8002d84:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8002d86:	6990      	ldr	r0, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8002d88:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8002d8a:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 8002d8e:	6190      	str	r0, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8002d90:	6990      	ldr	r0, [r2, #24]
 8002d92:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 8002d96:	6190      	str	r0, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8002d98:	6991      	ldr	r1, [r2, #24]
 8002d9a:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 8002d9e:	6191      	str	r1, [r2, #24]
      break;
 8002da0:	e797      	b.n	8002cd2 <HAL_TIM_PWM_ConfigChannel+0xa6>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8002da2:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8002da4:	688e      	ldr	r6, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8002da6:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002da8:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8002daa:	f425 5580 	bic.w	r5, r5, #4096	; 0x1000
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8002dae:	4c64      	ldr	r4, [pc, #400]	; (8002f40 <HAL_TIM_PWM_ConfigChannel+0x314>)
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8002db0:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 8002db2:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8002db4:	6855      	ldr	r5, [r2, #4]
  tmpccer &= ~TIM_CCER_CC4P;
 8002db6:	f420 5000 	bic.w	r0, r0, #8192	; 0x2000
  tmpccmrx = TIMx->CCMR2;
 8002dba:	f8d2 c01c 	ldr.w	ip, [r2, #28]
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8002dbe:	ea40 3006 	orr.w	r0, r0, r6, lsl #12
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002dc2:	4e5d      	ldr	r6, [pc, #372]	; (8002f38 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8002dc4:	ea0c 0404 	and.w	r4, ip, r4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002dc8:	42b2      	cmp	r2, r6
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8002dca:	ea44 2407 	orr.w	r4, r4, r7, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002dce:	f000 808d 	beq.w	8002eec <HAL_TIM_PWM_ConfigChannel+0x2c0>
 8002dd2:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8002dd6:	42b2      	cmp	r2, r6
 8002dd8:	f000 8088 	beq.w	8002eec <HAL_TIM_PWM_ConfigChannel+0x2c0>
  TIMx->CCR4 = OC_Config->Pulse;
 8002ddc:	684e      	ldr	r6, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8002dde:	6055      	str	r5, [r2, #4]
  TIMx->CCMR2 = tmpccmrx;
 8002de0:	61d4      	str	r4, [r2, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 8002de2:	6416      	str	r6, [r2, #64]	; 0x40
  TIMx->CCER = tmpccer;
 8002de4:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8002de6:	69d0      	ldr	r0, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8002de8:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8002dea:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 8002dee:	61d0      	str	r0, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8002df0:	69d0      	ldr	r0, [r2, #28]
 8002df2:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
 8002df6:	61d0      	str	r0, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8002df8:	69d1      	ldr	r1, [r2, #28]
 8002dfa:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
 8002dfe:	61d1      	str	r1, [r2, #28]
      break;
 8002e00:	e767      	b.n	8002cd2 <HAL_TIM_PWM_ConfigChannel+0xa6>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8002e02:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8002e04:	f8d1 c008 	ldr.w	ip, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8002e08:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= OC_Config->OCMode;
 8002e0a:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8002e0c:	f425 7580 	bic.w	r5, r5, #256	; 0x100
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8002e10:	4c48      	ldr	r4, [pc, #288]	; (8002f34 <HAL_TIM_PWM_ConfigChannel+0x308>)
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8002e12:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 8002e14:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8002e16:	6856      	ldr	r6, [r2, #4]
  tmpccmrx = TIMx->CCMR2;
 8002e18:	69d5      	ldr	r5, [r2, #28]
  tmpccer &= ~TIM_CCER_CC3P;
 8002e1a:	f420 7000 	bic.w	r0, r0, #512	; 0x200
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8002e1e:	402c      	ands	r4, r5
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8002e20:	4d45      	ldr	r5, [pc, #276]	; (8002f38 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8002e22:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8002e26:	42aa      	cmp	r2, r5
  tmpccmrx |= OC_Config->OCMode;
 8002e28:	ea44 0407 	orr.w	r4, r4, r7
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8002e2c:	d073      	beq.n	8002f16 <HAL_TIM_PWM_ConfigChannel+0x2ea>
 8002e2e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8002e32:	42aa      	cmp	r2, r5
 8002e34:	d06f      	beq.n	8002f16 <HAL_TIM_PWM_ConfigChannel+0x2ea>
  TIMx->CCR3 = OC_Config->Pulse;
 8002e36:	684d      	ldr	r5, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8002e38:	6056      	str	r6, [r2, #4]
  TIMx->CCMR2 = tmpccmrx;
 8002e3a:	61d4      	str	r4, [r2, #28]
  TIMx->CCR3 = OC_Config->Pulse;
 8002e3c:	63d5      	str	r5, [r2, #60]	; 0x3c
  TIMx->CCER = tmpccer;
 8002e3e:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8002e40:	69d0      	ldr	r0, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8002e42:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8002e44:	f040 0008 	orr.w	r0, r0, #8
 8002e48:	61d0      	str	r0, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8002e4a:	69d0      	ldr	r0, [r2, #28]
 8002e4c:	f020 0004 	bic.w	r0, r0, #4
 8002e50:	61d0      	str	r0, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8002e52:	69d1      	ldr	r1, [r2, #28]
 8002e54:	4321      	orrs	r1, r4
 8002e56:	61d1      	str	r1, [r2, #28]
      break;
 8002e58:	e73b      	b.n	8002cd2 <HAL_TIM_PWM_ConfigChannel+0xa6>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8002e5a:	681a      	ldr	r2, [r3, #0]
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8002e5c:	688e      	ldr	r6, [r1, #8]
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8002e5e:	6a15      	ldr	r5, [r2, #32]
  tmpccmrx |= OC_Config->OCMode;
 8002e60:	680f      	ldr	r7, [r1, #0]
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8002e62:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8002e66:	4c37      	ldr	r4, [pc, #220]	; (8002f44 <HAL_TIM_PWM_ConfigChannel+0x318>)
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8002e68:	6215      	str	r5, [r2, #32]
  tmpccer = TIMx->CCER;
 8002e6a:	6a10      	ldr	r0, [r2, #32]
  tmpcr2 =  TIMx->CR2;
 8002e6c:	6855      	ldr	r5, [r2, #4]
  tmpccer &= ~TIM_CCER_CC5P;
 8002e6e:	f420 3000 	bic.w	r0, r0, #131072	; 0x20000
  tmpccmrx = TIMx->CCMR3;
 8002e72:	f8d2 c054 	ldr.w	ip, [r2, #84]	; 0x54
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8002e76:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002e7a:	4e2f      	ldr	r6, [pc, #188]	; (8002f38 <HAL_TIM_PWM_ConfigChannel+0x30c>)
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8002e7c:	ea0c 0404 	and.w	r4, ip, r4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002e80:	42b2      	cmp	r2, r6
  tmpccmrx |= OC_Config->OCMode;
 8002e82:	ea44 0407 	orr.w	r4, r4, r7
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8002e86:	d01d      	beq.n	8002ec4 <HAL_TIM_PWM_ConfigChannel+0x298>
 8002e88:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8002e8c:	42b2      	cmp	r2, r6
 8002e8e:	d019      	beq.n	8002ec4 <HAL_TIM_PWM_ConfigChannel+0x298>
  TIMx->CCR5 = OC_Config->Pulse;
 8002e90:	684e      	ldr	r6, [r1, #4]
  TIMx->CR2 = tmpcr2;
 8002e92:	6055      	str	r5, [r2, #4]
  TIMx->CCMR3 = tmpccmrx;
 8002e94:	6554      	str	r4, [r2, #84]	; 0x54
  TIMx->CCR5 = OC_Config->Pulse;
 8002e96:	6596      	str	r6, [r2, #88]	; 0x58
  TIMx->CCER = tmpccer;
 8002e98:	6210      	str	r0, [r2, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8002e9a:	6d50      	ldr	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8002e9c:	690c      	ldr	r4, [r1, #16]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8002e9e:	f040 0008 	orr.w	r0, r0, #8
 8002ea2:	6550      	str	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8002ea4:	6d50      	ldr	r0, [r2, #84]	; 0x54
 8002ea6:	f020 0004 	bic.w	r0, r0, #4
 8002eaa:	6550      	str	r0, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8002eac:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8002eae:	4321      	orrs	r1, r4
 8002eb0:	6551      	str	r1, [r2, #84]	; 0x54
      break;
 8002eb2:	e70e      	b.n	8002cd2 <HAL_TIM_PWM_ConfigChannel+0xa6>
  __HAL_LOCK(htim);
 8002eb4:	2002      	movs	r0, #2
}
 8002eb6:	4770      	bx	lr
    tmpcr2 &= ~TIM_CR2_OIS6;
 8002eb8:	f425 2580 	bic.w	r5, r5, #262144	; 0x40000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8002ebc:	694e      	ldr	r6, [r1, #20]
 8002ebe:	ea45 2586 	orr.w	r5, r5, r6, lsl #10
 8002ec2:	e72c      	b.n	8002d1e <HAL_TIM_PWM_ConfigChannel+0xf2>
    tmpcr2 &= ~TIM_CR2_OIS5;
 8002ec4:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8002ec8:	694e      	ldr	r6, [r1, #20]
 8002eca:	ea45 2506 	orr.w	r5, r5, r6, lsl #8
 8002ece:	e7df      	b.n	8002e90 <HAL_TIM_PWM_ConfigChannel+0x264>
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8002ed0:	f426 7c40 	bic.w	ip, r6, #768	; 0x300
    tmpccer &= ~TIM_CCER_CC1NP;
 8002ed4:	f020 0008 	bic.w	r0, r0, #8
    tmpcr2 |= OC_Config->OCNIdleState;
 8002ed8:	698e      	ldr	r6, [r1, #24]
    tmpccer |= OC_Config->OCNPolarity;
 8002eda:	68cf      	ldr	r7, [r1, #12]
    tmpcr2 |= OC_Config->OCNIdleState;
 8002edc:	694d      	ldr	r5, [r1, #20]
    tmpccer |= OC_Config->OCNPolarity;
 8002ede:	4338      	orrs	r0, r7
    tmpcr2 |= OC_Config->OCNIdleState;
 8002ee0:	4335      	orrs	r5, r6
    tmpccer &= ~TIM_CCER_CC1NE;
 8002ee2:	f020 0004 	bic.w	r0, r0, #4
    tmpcr2 |= OC_Config->OCNIdleState;
 8002ee6:	ea45 060c 	orr.w	r6, r5, ip
 8002eea:	e6e1      	b.n	8002cb0 <HAL_TIM_PWM_ConfigChannel+0x84>
    tmpcr2 &= ~TIM_CR2_OIS4;
 8002eec:	f425 4580 	bic.w	r5, r5, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8002ef0:	694e      	ldr	r6, [r1, #20]
 8002ef2:	ea45 1586 	orr.w	r5, r5, r6, lsl #6
 8002ef6:	e771      	b.n	8002ddc <HAL_TIM_PWM_ConfigChannel+0x1b0>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8002ef8:	f426 6c40 	bic.w	ip, r6, #3072	; 0xc00
    tmpccer &= ~TIM_CCER_CC2NP;
 8002efc:	f020 0080 	bic.w	r0, r0, #128	; 0x80
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8002f00:	698e      	ldr	r6, [r1, #24]
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8002f02:	68cf      	ldr	r7, [r1, #12]
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8002f04:	694d      	ldr	r5, [r1, #20]
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8002f06:	ea40 1007 	orr.w	r0, r0, r7, lsl #4
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8002f0a:	4335      	orrs	r5, r6
    tmpccer &= ~TIM_CCER_CC2NE;
 8002f0c:	f020 0040 	bic.w	r0, r0, #64	; 0x40
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8002f10:	ea4c 0685 	orr.w	r6, ip, r5, lsl #2
 8002f14:	e732      	b.n	8002d7c <HAL_TIM_PWM_ConfigChannel+0x150>
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8002f16:	f426 5c40 	bic.w	ip, r6, #12288	; 0x3000
    tmpccer &= ~TIM_CCER_CC3NP;
 8002f1a:	f420 6000 	bic.w	r0, r0, #2048	; 0x800
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8002f1e:	698e      	ldr	r6, [r1, #24]
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8002f20:	68cf      	ldr	r7, [r1, #12]
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8002f22:	694d      	ldr	r5, [r1, #20]
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8002f24:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8002f28:	4335      	orrs	r5, r6
    tmpccer &= ~TIM_CCER_CC3NE;
 8002f2a:	f420 6080 	bic.w	r0, r0, #1024	; 0x400
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8002f2e:	ea4c 1605 	orr.w	r6, ip, r5, lsl #4
 8002f32:	e780      	b.n	8002e36 <HAL_TIM_PWM_ConfigChannel+0x20a>
 8002f34:	fffeff8c 	.word	0xfffeff8c
 8002f38:	40010000 	.word	0x40010000
 8002f3c:	feff8fff 	.word	0xfeff8fff
 8002f40:	feff8cff 	.word	0xfeff8cff
 8002f44:	fffeff8f 	.word	0xfffeff8f

08002f48 <HAL_TIM_OC_DelayElapsedCallback>:
 8002f48:	4770      	bx	lr
 8002f4a:	bf00      	nop

08002f4c <HAL_TIM_IC_CaptureCallback>:
 8002f4c:	4770      	bx	lr
 8002f4e:	bf00      	nop

08002f50 <HAL_TIM_PWM_PulseFinishedCallback>:
 8002f50:	4770      	bx	lr
 8002f52:	bf00      	nop

08002f54 <HAL_TIM_TriggerCallback>:
 8002f54:	4770      	bx	lr
 8002f56:	bf00      	nop

08002f58 <HAL_TIM_IRQHandler>:
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002f58:	6803      	ldr	r3, [r0, #0]
 8002f5a:	691a      	ldr	r2, [r3, #16]
 8002f5c:	0791      	lsls	r1, r2, #30
{
 8002f5e:	b510      	push	{r4, lr}
 8002f60:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002f62:	d502      	bpl.n	8002f6a <HAL_TIM_IRQHandler+0x12>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8002f64:	68da      	ldr	r2, [r3, #12]
 8002f66:	0792      	lsls	r2, r2, #30
 8002f68:	d468      	bmi.n	800303c <HAL_TIM_IRQHandler+0xe4>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8002f6a:	691a      	ldr	r2, [r3, #16]
 8002f6c:	0752      	lsls	r2, r2, #29
 8002f6e:	d502      	bpl.n	8002f76 <HAL_TIM_IRQHandler+0x1e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8002f70:	68da      	ldr	r2, [r3, #12]
 8002f72:	0750      	lsls	r0, r2, #29
 8002f74:	d44f      	bmi.n	8003016 <HAL_TIM_IRQHandler+0xbe>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8002f76:	691a      	ldr	r2, [r3, #16]
 8002f78:	0711      	lsls	r1, r2, #28
 8002f7a:	d502      	bpl.n	8002f82 <HAL_TIM_IRQHandler+0x2a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8002f7c:	68da      	ldr	r2, [r3, #12]
 8002f7e:	0712      	lsls	r2, r2, #28
 8002f80:	d437      	bmi.n	8002ff2 <HAL_TIM_IRQHandler+0x9a>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8002f82:	691a      	ldr	r2, [r3, #16]
 8002f84:	06d0      	lsls	r0, r2, #27
 8002f86:	d502      	bpl.n	8002f8e <HAL_TIM_IRQHandler+0x36>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8002f88:	68da      	ldr	r2, [r3, #12]
 8002f8a:	06d1      	lsls	r1, r2, #27
 8002f8c:	d41e      	bmi.n	8002fcc <HAL_TIM_IRQHandler+0x74>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8002f8e:	691a      	ldr	r2, [r3, #16]
 8002f90:	07d2      	lsls	r2, r2, #31
 8002f92:	d502      	bpl.n	8002f9a <HAL_TIM_IRQHandler+0x42>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8002f94:	68da      	ldr	r2, [r3, #12]
 8002f96:	07d0      	lsls	r0, r2, #31
 8002f98:	d469      	bmi.n	800306e <HAL_TIM_IRQHandler+0x116>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8002f9a:	691a      	ldr	r2, [r3, #16]
 8002f9c:	0611      	lsls	r1, r2, #24
 8002f9e:	d502      	bpl.n	8002fa6 <HAL_TIM_IRQHandler+0x4e>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8002fa0:	68da      	ldr	r2, [r3, #12]
 8002fa2:	0612      	lsls	r2, r2, #24
 8002fa4:	d46b      	bmi.n	800307e <HAL_TIM_IRQHandler+0x126>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8002fa6:	691a      	ldr	r2, [r3, #16]
 8002fa8:	05d0      	lsls	r0, r2, #23
 8002faa:	d502      	bpl.n	8002fb2 <HAL_TIM_IRQHandler+0x5a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8002fac:	68da      	ldr	r2, [r3, #12]
 8002fae:	0611      	lsls	r1, r2, #24
 8002fb0:	d46d      	bmi.n	800308e <HAL_TIM_IRQHandler+0x136>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8002fb2:	691a      	ldr	r2, [r3, #16]
 8002fb4:	0652      	lsls	r2, r2, #25
 8002fb6:	d502      	bpl.n	8002fbe <HAL_TIM_IRQHandler+0x66>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8002fb8:	68da      	ldr	r2, [r3, #12]
 8002fba:	0650      	lsls	r0, r2, #25
 8002fbc:	d46f      	bmi.n	800309e <HAL_TIM_IRQHandler+0x146>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8002fbe:	691a      	ldr	r2, [r3, #16]
 8002fc0:	0691      	lsls	r1, r2, #26
 8002fc2:	d502      	bpl.n	8002fca <HAL_TIM_IRQHandler+0x72>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8002fc4:	68da      	ldr	r2, [r3, #12]
 8002fc6:	0692      	lsls	r2, r2, #26
 8002fc8:	d449      	bmi.n	800305e <HAL_TIM_IRQHandler+0x106>
}
 8002fca:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8002fcc:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8002fd0:	2208      	movs	r2, #8
        HAL_TIM_IC_CaptureCallback(htim);
 8002fd2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8002fd4:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002fd6:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8002fd8:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002fda:	f413 7f40 	tst.w	r3, #768	; 0x300
 8002fde:	d16f      	bne.n	80030c0 <HAL_TIM_IRQHandler+0x168>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002fe0:	f7ff ffb2 	bl	8002f48 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002fe4:	4620      	mov	r0, r4
 8002fe6:	f7ff ffb3 	bl	8002f50 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002fea:	2200      	movs	r2, #0
 8002fec:	6823      	ldr	r3, [r4, #0]
 8002fee:	7722      	strb	r2, [r4, #28]
 8002ff0:	e7cd      	b.n	8002f8e <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8002ff2:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8002ff6:	2204      	movs	r2, #4
        HAL_TIM_IC_CaptureCallback(htim);
 8002ff8:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8002ffa:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002ffc:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8002ffe:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8003000:	079b      	lsls	r3, r3, #30
 8003002:	d15a      	bne.n	80030ba <HAL_TIM_IRQHandler+0x162>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8003004:	f7ff ffa0 	bl	8002f48 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003008:	4620      	mov	r0, r4
 800300a:	f7ff ffa1 	bl	8002f50 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800300e:	2200      	movs	r2, #0
 8003010:	6823      	ldr	r3, [r4, #0]
 8003012:	7722      	strb	r2, [r4, #28]
 8003014:	e7b5      	b.n	8002f82 <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8003016:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800301a:	2202      	movs	r2, #2
        HAL_TIM_IC_CaptureCallback(htim);
 800301c:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800301e:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8003020:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8003022:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8003024:	f413 7f40 	tst.w	r3, #768	; 0x300
 8003028:	d144      	bne.n	80030b4 <HAL_TIM_IRQHandler+0x15c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800302a:	f7ff ff8d 	bl	8002f48 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800302e:	4620      	mov	r0, r4
 8003030:	f7ff ff8e 	bl	8002f50 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003034:	2200      	movs	r2, #0
 8003036:	6823      	ldr	r3, [r4, #0]
 8003038:	7722      	strb	r2, [r4, #28]
 800303a:	e79c      	b.n	8002f76 <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800303c:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8003040:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8003042:	6119      	str	r1, [r3, #16]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8003044:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8003046:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8003048:	0799      	lsls	r1, r3, #30
 800304a:	d130      	bne.n	80030ae <HAL_TIM_IRQHandler+0x156>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800304c:	f7ff ff7c 	bl	8002f48 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8003050:	4620      	mov	r0, r4
 8003052:	f7ff ff7d 	bl	8002f50 <HAL_TIM_PWM_PulseFinishedCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8003056:	2200      	movs	r2, #0
 8003058:	6823      	ldr	r3, [r4, #0]
 800305a:	7722      	strb	r2, [r4, #28]
 800305c:	e785      	b.n	8002f6a <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 800305e:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 8003062:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8003064:	611a      	str	r2, [r3, #16]
}
 8003066:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutCallback(htim);
 800306a:	f000 b8a5 	b.w	80031b8 <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 800306e:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 8003072:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8003074:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8003076:	f003 fced 	bl	8006a54 <HAL_TIM_PeriodElapsedCallback>
 800307a:	6823      	ldr	r3, [r4, #0]
 800307c:	e78d      	b.n	8002f9a <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800307e:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 8003082:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8003084:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8003086:	f000 f899 	bl	80031bc <HAL_TIMEx_BreakCallback>
 800308a:	6823      	ldr	r3, [r4, #0]
 800308c:	e78b      	b.n	8002fa6 <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800308e:	f46f 7280 	mvn.w	r2, #256	; 0x100
      HAL_TIMEx_Break2Callback(htim);
 8003092:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8003094:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8003096:	f000 f893 	bl	80031c0 <HAL_TIMEx_Break2Callback>
 800309a:	6823      	ldr	r3, [r4, #0]
 800309c:	e789      	b.n	8002fb2 <HAL_TIM_IRQHandler+0x5a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800309e:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 80030a2:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80030a4:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 80030a6:	f7ff ff55 	bl	8002f54 <HAL_TIM_TriggerCallback>
 80030aa:	6823      	ldr	r3, [r4, #0]
 80030ac:	e787      	b.n	8002fbe <HAL_TIM_IRQHandler+0x66>
          HAL_TIM_IC_CaptureCallback(htim);
 80030ae:	f7ff ff4d 	bl	8002f4c <HAL_TIM_IC_CaptureCallback>
 80030b2:	e7d0      	b.n	8003056 <HAL_TIM_IRQHandler+0xfe>
        HAL_TIM_IC_CaptureCallback(htim);
 80030b4:	f7ff ff4a 	bl	8002f4c <HAL_TIM_IC_CaptureCallback>
 80030b8:	e7bc      	b.n	8003034 <HAL_TIM_IRQHandler+0xdc>
        HAL_TIM_IC_CaptureCallback(htim);
 80030ba:	f7ff ff47 	bl	8002f4c <HAL_TIM_IC_CaptureCallback>
 80030be:	e7a6      	b.n	800300e <HAL_TIM_IRQHandler+0xb6>
        HAL_TIM_IC_CaptureCallback(htim);
 80030c0:	f7ff ff44 	bl	8002f4c <HAL_TIM_IC_CaptureCallback>
 80030c4:	e791      	b.n	8002fea <HAL_TIM_IRQHandler+0x92>
 80030c6:	bf00      	nop

080030c8 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 80030c8:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 80030cc:	2b01      	cmp	r3, #1
 80030ce:	d025      	beq.n	800311c <HAL_TIMEx_MasterConfigSynchronization+0x54>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 80030d0:	6802      	ldr	r2, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80030d2:	2302      	movs	r3, #2
{
 80030d4:	b470      	push	{r4, r5, r6}

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80030d6:	4d13      	ldr	r5, [pc, #76]	; (8003124 <HAL_TIMEx_MasterConfigSynchronization+0x5c>)
  htim->State = HAL_TIM_STATE_BUSY;
 80030d8:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80030dc:	42aa      	cmp	r2, r5
  tmpcr2 = htim->Instance->CR2;
 80030de:	6853      	ldr	r3, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 80030e0:	6894      	ldr	r4, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 80030e2:	d016      	beq.n	8003112 <HAL_TIMEx_MasterConfigSynchronization+0x4a>
 80030e4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80030e8:	42aa      	cmp	r2, r5
 80030ea:	d012      	beq.n	8003112 <HAL_TIMEx_MasterConfigSynchronization+0x4a>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80030ec:	680d      	ldr	r5, [r1, #0]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 80030ee:	f024 0480 	bic.w	r4, r4, #128	; 0x80
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80030f2:	6889      	ldr	r1, [r1, #8]
  tmpcr2 &= ~TIM_CR2_MMS;
 80030f4:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 80030f8:	2601      	movs	r6, #1
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 80030fa:	432b      	orrs	r3, r5
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80030fc:	4321      	orrs	r1, r4

  __HAL_UNLOCK(htim);
 80030fe:	2500      	movs	r5, #0
  htim->Instance->CR2 = tmpcr2;
 8003100:	6053      	str	r3, [r2, #4]
  htim->Instance->SMCR = tmpsmcr;
 8003102:	6091      	str	r1, [r2, #8]
  htim->State = HAL_TIM_STATE_READY;
 8003104:	f880 603d 	strb.w	r6, [r0, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 8003108:	f880 503c 	strb.w	r5, [r0, #60]	; 0x3c

  return HAL_OK;
}
 800310c:	4628      	mov	r0, r5
 800310e:	bc70      	pop	{r4, r5, r6}
 8003110:	4770      	bx	lr
    tmpcr2 &= ~TIM_CR2_MMS2;
 8003112:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8003116:	684d      	ldr	r5, [r1, #4]
 8003118:	432b      	orrs	r3, r5
 800311a:	e7e7      	b.n	80030ec <HAL_TIMEx_MasterConfigSynchronization+0x24>
  __HAL_LOCK(htim);
 800311c:	2302      	movs	r3, #2
}
 800311e:	4618      	mov	r0, r3
 8003120:	4770      	bx	lr
 8003122:	bf00      	nop
 8003124:	40010000 	.word	0x40010000

08003128 <HAL_TIMEx_ConfigBreakDeadTime>:
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Check input state */
  __HAL_LOCK(htim);
 8003128:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800312c:	2b01      	cmp	r3, #1
 800312e:	d03b      	beq.n	80031a8 <HAL_TIMEx_ConfigBreakDeadTime+0x80>
{
 8003130:	b470      	push	{r4, r5, r6}
  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8003132:	e9d1 5302 	ldrd	r5, r3, [r1, #8]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 8003136:	e9d1 2400 	ldrd	r2, r4, [r1]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 800313a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 800313e:	690e      	ldr	r6, [r1, #16]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 8003140:	432b      	orrs	r3, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 8003142:	694d      	ldr	r5, [r1, #20]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 8003144:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8003148:	4323      	orrs	r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 800314a:	6a8c      	ldr	r4, [r1, #40]	; 0x28
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 800314c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003150:	4313      	orrs	r3, r2
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 8003152:	698a      	ldr	r2, [r1, #24]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 8003154:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003158:	4333      	orrs	r3, r6

  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 800315a:	6806      	ldr	r6, [r0, #0]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 800315c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003160:	432b      	orrs	r3, r5
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8003162:	4d13      	ldr	r5, [pc, #76]	; (80031b0 <HAL_TIMEx_ConfigBreakDeadTime+0x88>)
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 8003164:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8003168:	42ae      	cmp	r6, r5
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 800316a:	ea43 0304 	orr.w	r3, r3, r4
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 800316e:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8003172:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 8003176:	d009      	beq.n	800318c <HAL_TIMEx_ConfigBreakDeadTime+0x64>
 8003178:	4a0e      	ldr	r2, [pc, #56]	; (80031b4 <HAL_TIMEx_ConfigBreakDeadTime+0x8c>)
 800317a:	4296      	cmp	r6, r2
 800317c:	d006      	beq.n	800318c <HAL_TIMEx_ConfigBreakDeadTime+0x64>
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;

  __HAL_UNLOCK(htim);
 800317e:	2200      	movs	r2, #0
  htim->Instance->BDTR = tmpbdtr;
 8003180:	6473      	str	r3, [r6, #68]	; 0x44
  __HAL_UNLOCK(htim);
 8003182:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c

  return HAL_OK;
}
 8003186:	4610      	mov	r0, r2
 8003188:	bc70      	pop	{r4, r5, r6}
 800318a:	4770      	bx	lr
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 800318c:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 800318e:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 8003192:	69cc      	ldr	r4, [r1, #28]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 8003194:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 8003198:	6a0a      	ldr	r2, [r1, #32]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 800319a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800319e:	4323      	orrs	r3, r4
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 80031a0:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80031a4:	4313      	orrs	r3, r2
 80031a6:	e7ea      	b.n	800317e <HAL_TIMEx_ConfigBreakDeadTime+0x56>
  __HAL_LOCK(htim);
 80031a8:	2302      	movs	r3, #2
}
 80031aa:	4618      	mov	r0, r3
 80031ac:	4770      	bx	lr
 80031ae:	bf00      	nop
 80031b0:	40010000 	.word	0x40010000
 80031b4:	40010400 	.word	0x40010400

080031b8 <HAL_TIMEx_CommutCallback>:
 80031b8:	4770      	bx	lr
 80031ba:	bf00      	nop

080031bc <HAL_TIMEx_BreakCallback>:
 80031bc:	4770      	bx	lr
 80031be:	bf00      	nop

080031c0 <HAL_TIMEx_Break2Callback>:
 80031c0:	4770      	bx	lr
 80031c2:	bf00      	nop

080031c4 <HAL_UART_Receive_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 80031c4:	6f83      	ldr	r3, [r0, #120]	; 0x78
 80031c6:	2b20      	cmp	r3, #32
 80031c8:	d137      	bne.n	800323a <HAL_UART_Receive_IT+0x76>
  {
    if ((pData == NULL) || (Size == 0U))
 80031ca:	2900      	cmp	r1, #0
 80031cc:	d033      	beq.n	8003236 <HAL_UART_Receive_IT+0x72>
 80031ce:	fab2 f382 	clz	r3, r2
 80031d2:	095b      	lsrs	r3, r3, #5
 80031d4:	2b00      	cmp	r3, #0
 80031d6:	d12e      	bne.n	8003236 <HAL_UART_Receive_IT+0x72>
{
 80031d8:	b430      	push	{r4, r5}
    {
      return HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 80031da:	f890 4070 	ldrb.w	r4, [r0, #112]	; 0x70
 80031de:	2c01      	cmp	r4, #1
 80031e0:	d042      	beq.n	8003268 <HAL_UART_Receive_IT+0xa4>
    huart->RxXferSize  = Size;
    huart->RxXferCount = Size;
    huart->RxISR       = NULL;

    /* Computation of UART mask to apply to RDR register */
    UART_MASK_COMPUTATION(huart);
 80031e2:	6884      	ldr	r4, [r0, #8]
    __HAL_LOCK(huart);
 80031e4:	2501      	movs	r5, #1
    huart->RxXferSize  = Size;
 80031e6:	f8a0 2058 	strh.w	r2, [r0, #88]	; 0x58
    UART_MASK_COMPUTATION(huart);
 80031ea:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    huart->RxXferCount = Size;
 80031ee:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
    huart->pRxBuffPtr  = pData;
 80031f2:	6541      	str	r1, [r0, #84]	; 0x54
    huart->RxISR       = NULL;
 80031f4:	6603      	str	r3, [r0, #96]	; 0x60
    __HAL_LOCK(huart);
 80031f6:	f880 5070 	strb.w	r5, [r0, #112]	; 0x70
 80031fa:	6802      	ldr	r2, [r0, #0]
    UART_MASK_COMPUTATION(huart);
 80031fc:	d01f      	beq.n	800323e <HAL_UART_Receive_IT+0x7a>
 80031fe:	2c00      	cmp	r4, #0
 8003200:	d12c      	bne.n	800325c <HAL_UART_Receive_IT+0x98>
 8003202:	6903      	ldr	r3, [r0, #16]
 8003204:	2b00      	cmp	r3, #0
 8003206:	d03d      	beq.n	8003284 <HAL_UART_Receive_IT+0xc0>
 8003208:	237f      	movs	r3, #127	; 0x7f
 800320a:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800320e:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003210:	2100      	movs	r1, #0
    {
      huart->RxISR = UART_RxISR_16BIT;
    }
    else
    {
      huart->RxISR = UART_RxISR_8BIT;
 8003212:	4c22      	ldr	r4, [pc, #136]	; (800329c <HAL_UART_Receive_IT+0xd8>)
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003214:	67c1      	str	r1, [r0, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003216:	6783      	str	r3, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003218:	6893      	ldr	r3, [r2, #8]
 800321a:	f043 0301 	orr.w	r3, r3, #1
 800321e:	6093      	str	r3, [r2, #8]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Parity Error interrupt and Data Register Not Empty interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8003220:	6811      	ldr	r1, [r2, #0]
    __HAL_UNLOCK(huart);
 8003222:	2300      	movs	r3, #0
 8003224:	6604      	str	r4, [r0, #96]	; 0x60
 8003226:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 800322a:	f441 7190 	orr.w	r1, r1, #288	; 0x120

    return HAL_OK;
 800322e:	4618      	mov	r0, r3
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8003230:	6011      	str	r1, [r2, #0]
  }
  else
  {
    return HAL_BUSY;
  }
}
 8003232:	bc30      	pop	{r4, r5}
 8003234:	4770      	bx	lr
      return HAL_ERROR;
 8003236:	2001      	movs	r0, #1
}
 8003238:	4770      	bx	lr
    return HAL_BUSY;
 800323a:	2002      	movs	r0, #2
 800323c:	4770      	bx	lr
    UART_MASK_COMPUTATION(huart);
 800323e:	6901      	ldr	r1, [r0, #16]
 8003240:	b9a1      	cbnz	r1, 800326c <HAL_UART_Receive_IT+0xa8>
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003242:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003244:	67c1      	str	r1, [r0, #124]	; 0x7c
 8003246:	f240 11ff 	movw	r1, #511	; 0x1ff
      huart->RxISR = UART_RxISR_16BIT;
 800324a:	4c15      	ldr	r4, [pc, #84]	; (80032a0 <HAL_UART_Receive_IT+0xdc>)
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800324c:	6783      	str	r3, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800324e:	6893      	ldr	r3, [r2, #8]
 8003250:	f8a0 105c 	strh.w	r1, [r0, #92]	; 0x5c
 8003254:	f043 0301 	orr.w	r3, r3, #1
 8003258:	6093      	str	r3, [r2, #8]
 800325a:	e7e1      	b.n	8003220 <HAL_UART_Receive_IT+0x5c>
    UART_MASK_COMPUTATION(huart);
 800325c:	f1b4 5f80 	cmp.w	r4, #268435456	; 0x10000000
 8003260:	d014      	beq.n	800328c <HAL_UART_Receive_IT+0xc8>
 8003262:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 8003266:	e7d2      	b.n	800320e <HAL_UART_Receive_IT+0x4a>
    return HAL_BUSY;
 8003268:	2002      	movs	r0, #2
 800326a:	e7e2      	b.n	8003232 <HAL_UART_Receive_IT+0x6e>
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800326c:	2522      	movs	r5, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800326e:	67c3      	str	r3, [r0, #124]	; 0x7c
 8003270:	21ff      	movs	r1, #255	; 0xff
      huart->RxISR = UART_RxISR_8BIT;
 8003272:	4c0a      	ldr	r4, [pc, #40]	; (800329c <HAL_UART_Receive_IT+0xd8>)
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003274:	6785      	str	r5, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003276:	6893      	ldr	r3, [r2, #8]
 8003278:	f8a0 105c 	strh.w	r1, [r0, #92]	; 0x5c
 800327c:	f043 0301 	orr.w	r3, r3, #1
 8003280:	6093      	str	r3, [r2, #8]
 8003282:	e7cd      	b.n	8003220 <HAL_UART_Receive_IT+0x5c>
    UART_MASK_COMPUTATION(huart);
 8003284:	23ff      	movs	r3, #255	; 0xff
 8003286:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800328a:	e7c0      	b.n	800320e <HAL_UART_Receive_IT+0x4a>
 800328c:	6903      	ldr	r3, [r0, #16]
 800328e:	2b00      	cmp	r3, #0
 8003290:	d0ba      	beq.n	8003208 <HAL_UART_Receive_IT+0x44>
 8003292:	233f      	movs	r3, #63	; 0x3f
 8003294:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 8003298:	e7b9      	b.n	800320e <HAL_UART_Receive_IT+0x4a>
 800329a:	bf00      	nop
 800329c:	080032a9 	.word	0x080032a9
 80032a0:	08003305 	.word	0x08003305

080032a4 <HAL_UART_TxCpltCallback>:
 80032a4:	4770      	bx	lr
 80032a6:	bf00      	nop

080032a8 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80032a8:	6f81      	ldr	r1, [r0, #120]	; 0x78
 80032aa:	6802      	ldr	r2, [r0, #0]
 80032ac:	2922      	cmp	r1, #34	; 0x22
{
 80032ae:	b538      	push	{r3, r4, r5, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80032b0:	d004      	beq.n	80032bc <UART_RxISR_8BIT+0x14>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80032b2:	6993      	ldr	r3, [r2, #24]
 80032b4:	f043 0308 	orr.w	r3, r3, #8
 80032b8:	6193      	str	r3, [r2, #24]
  }
}
 80032ba:	bd38      	pop	{r3, r4, r5, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80032bc:	6a52      	ldr	r2, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80032be:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
 80032c2:	6d41      	ldr	r1, [r0, #84]	; 0x54
 80032c4:	4022      	ands	r2, r4
 80032c6:	700a      	strb	r2, [r1, #0]
    huart->RxXferCount--;
 80032c8:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
    huart->pRxBuffPtr++;
 80032cc:	6d41      	ldr	r1, [r0, #84]	; 0x54
    huart->RxXferCount--;
 80032ce:	3a01      	subs	r2, #1
    huart->pRxBuffPtr++;
 80032d0:	3101      	adds	r1, #1
    huart->RxXferCount--;
 80032d2:	b292      	uxth	r2, r2
    huart->pRxBuffPtr++;
 80032d4:	6541      	str	r1, [r0, #84]	; 0x54
    huart->RxXferCount--;
 80032d6:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 80032da:	f8b0 205a 	ldrh.w	r2, [r0, #90]	; 0x5a
 80032de:	b292      	uxth	r2, r2
 80032e0:	2a00      	cmp	r2, #0
 80032e2:	d1ea      	bne.n	80032ba <UART_RxISR_8BIT+0x12>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80032e4:	6801      	ldr	r1, [r0, #0]
      huart->RxState = HAL_UART_STATE_READY;
 80032e6:	2520      	movs	r5, #32
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80032e8:	680c      	ldr	r4, [r1, #0]
 80032ea:	f424 7490 	bic.w	r4, r4, #288	; 0x120
 80032ee:	600c      	str	r4, [r1, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80032f0:	688c      	ldr	r4, [r1, #8]
 80032f2:	f024 0401 	bic.w	r4, r4, #1
 80032f6:	608c      	str	r4, [r1, #8]
      huart->RxISR = NULL;
 80032f8:	6602      	str	r2, [r0, #96]	; 0x60
      huart->RxState = HAL_UART_STATE_READY;
 80032fa:	6785      	str	r5, [r0, #120]	; 0x78
      HAL_UART_RxCpltCallback(huart);
 80032fc:	f003 fbd6 	bl	8006aac <HAL_UART_RxCpltCallback>
}
 8003300:	bd38      	pop	{r3, r4, r5, pc}
 8003302:	bf00      	nop

08003304 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8003304:	6f81      	ldr	r1, [r0, #120]	; 0x78
 8003306:	6802      	ldr	r2, [r0, #0]
 8003308:	2922      	cmp	r1, #34	; 0x22
{
 800330a:	b538      	push	{r3, r4, r5, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800330c:	d004      	beq.n	8003318 <UART_RxISR_16BIT+0x14>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800330e:	6993      	ldr	r3, [r2, #24]
 8003310:	f043 0308 	orr.w	r3, r3, #8
 8003314:	6193      	str	r3, [r2, #24]
  }
}
 8003316:	bd38      	pop	{r3, r4, r5, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8003318:	6a51      	ldr	r1, [r2, #36]	; 0x24
    *tmp = (uint16_t)(uhdata & uhMask);
 800331a:	f8b0 505c 	ldrh.w	r5, [r0, #92]	; 0x5c
 800331e:	6d44      	ldr	r4, [r0, #84]	; 0x54
 8003320:	4029      	ands	r1, r5
 8003322:	f824 1b02 	strh.w	r1, [r4], #2
    huart->RxXferCount--;
 8003326:	f8b0 105a 	ldrh.w	r1, [r0, #90]	; 0x5a
    huart->pRxBuffPtr += 2U;
 800332a:	6544      	str	r4, [r0, #84]	; 0x54
    huart->RxXferCount--;
 800332c:	3901      	subs	r1, #1
 800332e:	b289      	uxth	r1, r1
 8003330:	f8a0 105a 	strh.w	r1, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 8003334:	f8b0 105a 	ldrh.w	r1, [r0, #90]	; 0x5a
 8003338:	b289      	uxth	r1, r1
 800333a:	2900      	cmp	r1, #0
 800333c:	d1eb      	bne.n	8003316 <UART_RxISR_16BIT+0x12>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800333e:	6814      	ldr	r4, [r2, #0]
      huart->RxState = HAL_UART_STATE_READY;
 8003340:	2520      	movs	r5, #32
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8003342:	f424 7490 	bic.w	r4, r4, #288	; 0x120
 8003346:	6014      	str	r4, [r2, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003348:	6894      	ldr	r4, [r2, #8]
 800334a:	f024 0401 	bic.w	r4, r4, #1
 800334e:	6094      	str	r4, [r2, #8]
      huart->RxISR = NULL;
 8003350:	6601      	str	r1, [r0, #96]	; 0x60
      huart->RxState = HAL_UART_STATE_READY;
 8003352:	6785      	str	r5, [r0, #120]	; 0x78
      HAL_UART_RxCpltCallback(huart);
 8003354:	f003 fbaa 	bl	8006aac <HAL_UART_RxCpltCallback>
}
 8003358:	bd38      	pop	{r3, r4, r5, pc}
 800335a:	bf00      	nop

0800335c <HAL_UART_ErrorCallback>:
 800335c:	4770      	bx	lr
 800335e:	bf00      	nop

08003360 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8003360:	6803      	ldr	r3, [r0, #0]
 8003362:	69da      	ldr	r2, [r3, #28]
{
 8003364:	b570      	push	{r4, r5, r6, lr}
  if (errorflags == 0U)
 8003366:	0716      	lsls	r6, r2, #28
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8003368:	681d      	ldr	r5, [r3, #0]
{
 800336a:	4604      	mov	r4, r0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 800336c:	6899      	ldr	r1, [r3, #8]
  if (errorflags == 0U)
 800336e:	d047      	beq.n	8003400 <HAL_UART_IRQHandler+0xa0>
      && (((cr3its & USART_CR3_EIE) != 0U)
 8003370:	f011 0101 	ands.w	r1, r1, #1
 8003374:	d04b      	beq.n	800340e <HAL_UART_IRQHandler+0xae>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8003376:	07d0      	lsls	r0, r2, #31
 8003378:	d507      	bpl.n	800338a <HAL_UART_IRQHandler+0x2a>
 800337a:	05ee      	lsls	r6, r5, #23
 800337c:	d505      	bpl.n	800338a <HAL_UART_IRQHandler+0x2a>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800337e:	2001      	movs	r0, #1
 8003380:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8003382:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8003384:	f040 0001 	orr.w	r0, r0, #1
 8003388:	67e0      	str	r0, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800338a:	0790      	lsls	r0, r2, #30
 800338c:	d45d      	bmi.n	800344a <HAL_UART_IRQHandler+0xea>
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800338e:	0750      	lsls	r0, r2, #29
 8003390:	d501      	bpl.n	8003396 <HAL_UART_IRQHandler+0x36>
 8003392:	2900      	cmp	r1, #0
 8003394:	d163      	bne.n	800345e <HAL_UART_IRQHandler+0xfe>
    if (((isrflags & USART_ISR_ORE) != 0U)
 8003396:	0716      	lsls	r6, r2, #28
 8003398:	d503      	bpl.n	80033a2 <HAL_UART_IRQHandler+0x42>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 800339a:	06a8      	lsls	r0, r5, #26
 800339c:	d466      	bmi.n	800346c <HAL_UART_IRQHandler+0x10c>
 800339e:	2900      	cmp	r1, #0
 80033a0:	d164      	bne.n	800346c <HAL_UART_IRQHandler+0x10c>
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 80033a2:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 80033a4:	2900      	cmp	r1, #0
 80033a6:	d031      	beq.n	800340c <HAL_UART_IRQHandler+0xac>
      if (((isrflags & USART_ISR_RXNE) != 0U)
 80033a8:	0696      	lsls	r6, r2, #26
 80033aa:	d501      	bpl.n	80033b0 <HAL_UART_IRQHandler+0x50>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 80033ac:	06a8      	lsls	r0, r5, #26
 80033ae:	d468      	bmi.n	8003482 <HAL_UART_IRQHandler+0x122>
      errorcode = huart->ErrorCode;
 80033b0:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 80033b2:	6899      	ldr	r1, [r3, #8]
 80033b4:	0649      	lsls	r1, r1, #25
 80033b6:	d402      	bmi.n	80033be <HAL_UART_IRQHandler+0x5e>
 80033b8:	f015 0508 	ands.w	r5, r5, #8
 80033bc:	d068      	beq.n	8003490 <HAL_UART_IRQHandler+0x130>
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80033be:	681a      	ldr	r2, [r3, #0]
  huart->RxState = HAL_UART_STATE_READY;
 80033c0:	2020      	movs	r0, #32
  huart->RxISR = NULL;
 80033c2:	2100      	movs	r1, #0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80033c4:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 80033c8:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80033ca:	689a      	ldr	r2, [r3, #8]
 80033cc:	f022 0201 	bic.w	r2, r2, #1
 80033d0:	609a      	str	r2, [r3, #8]
  huart->RxState = HAL_UART_STATE_READY;
 80033d2:	67a0      	str	r0, [r4, #120]	; 0x78
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80033d4:	689a      	ldr	r2, [r3, #8]
  huart->RxISR = NULL;
 80033d6:	6621      	str	r1, [r4, #96]	; 0x60
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80033d8:	0652      	lsls	r2, r2, #25
 80033da:	d54e      	bpl.n	800347a <HAL_UART_IRQHandler+0x11a>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80033dc:	689a      	ldr	r2, [r3, #8]
          if (huart->hdmarx != NULL)
 80033de:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80033e0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80033e4:	609a      	str	r2, [r3, #8]
          if (huart->hdmarx != NULL)
 80033e6:	2900      	cmp	r1, #0
 80033e8:	d047      	beq.n	800347a <HAL_UART_IRQHandler+0x11a>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 80033ea:	4b2c      	ldr	r3, [pc, #176]	; (800349c <HAL_UART_IRQHandler+0x13c>)
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 80033ec:	4608      	mov	r0, r1
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 80033ee:	650b      	str	r3, [r1, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 80033f0:	f7fd fb9a 	bl	8000b28 <HAL_DMA_Abort_IT>
 80033f4:	b150      	cbz	r0, 800340c <HAL_UART_IRQHandler+0xac>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 80033f6:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
}
 80033f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 80033fc:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80033fe:	4718      	bx	r3
    if (((isrflags & USART_ISR_RXNE) != 0U)
 8003400:	0691      	lsls	r1, r2, #26
 8003402:	d507      	bpl.n	8003414 <HAL_UART_IRQHandler+0xb4>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8003404:	06ae      	lsls	r6, r5, #26
 8003406:	d505      	bpl.n	8003414 <HAL_UART_IRQHandler+0xb4>
      if (huart->RxISR != NULL)
 8003408:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800340a:	b9db      	cbnz	r3, 8003444 <HAL_UART_IRQHandler+0xe4>
}
 800340c:	bd70      	pop	{r4, r5, r6, pc}
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != 0U)))
 800340e:	f415 7f90 	tst.w	r5, #288	; 0x120
 8003412:	d1b0      	bne.n	8003376 <HAL_UART_IRQHandler+0x16>
  if (((isrflags & USART_ISR_TXE) != 0U)
 8003414:	0616      	lsls	r6, r2, #24
 8003416:	d40f      	bmi.n	8003438 <HAL_UART_IRQHandler+0xd8>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 8003418:	0651      	lsls	r1, r2, #25
 800341a:	d5f7      	bpl.n	800340c <HAL_UART_IRQHandler+0xac>
 800341c:	066a      	lsls	r2, r5, #25
 800341e:	d5f5      	bpl.n	800340c <HAL_UART_IRQHandler+0xac>
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8003420:	681a      	ldr	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8003422:	2520      	movs	r5, #32
  huart->TxISR = NULL;
 8003424:	2100      	movs	r1, #0
  HAL_UART_TxCpltCallback(huart);
 8003426:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8003428:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800342c:	601a      	str	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 800342e:	6765      	str	r5, [r4, #116]	; 0x74
  huart->TxISR = NULL;
 8003430:	6661      	str	r1, [r4, #100]	; 0x64
  HAL_UART_TxCpltCallback(huart);
 8003432:	f7ff ff37 	bl	80032a4 <HAL_UART_TxCpltCallback>
}
 8003436:	bd70      	pop	{r4, r5, r6, pc}
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 8003438:	0628      	lsls	r0, r5, #24
 800343a:	d5ed      	bpl.n	8003418 <HAL_UART_IRQHandler+0xb8>
    if (huart->TxISR != NULL)
 800343c:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800343e:	2b00      	cmp	r3, #0
 8003440:	d0e4      	beq.n	800340c <HAL_UART_IRQHandler+0xac>
      huart->TxISR(huart);
 8003442:	4620      	mov	r0, r4
}
 8003444:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      huart->TxISR(huart);
 8003448:	4718      	bx	r3
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800344a:	2900      	cmp	r1, #0
 800344c:	d0a3      	beq.n	8003396 <HAL_UART_IRQHandler+0x36>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 800344e:	2002      	movs	r0, #2
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8003450:	0756      	lsls	r6, r2, #29
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8003452:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8003454:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8003456:	f040 0004 	orr.w	r0, r0, #4
 800345a:	67e0      	str	r0, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800345c:	d59b      	bpl.n	8003396 <HAL_UART_IRQHandler+0x36>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 800345e:	2004      	movs	r0, #4
 8003460:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8003462:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8003464:	f040 0002 	orr.w	r0, r0, #2
 8003468:	67e0      	str	r0, [r4, #124]	; 0x7c
 800346a:	e794      	b.n	8003396 <HAL_UART_IRQHandler+0x36>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800346c:	2108      	movs	r1, #8
 800346e:	6219      	str	r1, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8003470:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8003472:	f041 0108 	orr.w	r1, r1, #8
 8003476:	67e1      	str	r1, [r4, #124]	; 0x7c
 8003478:	e793      	b.n	80033a2 <HAL_UART_IRQHandler+0x42>
            HAL_UART_ErrorCallback(huart);
 800347a:	4620      	mov	r0, r4
 800347c:	f7ff ff6e 	bl	800335c <HAL_UART_ErrorCallback>
}
 8003480:	bd70      	pop	{r4, r5, r6, pc}
        if (huart->RxISR != NULL)
 8003482:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8003484:	2a00      	cmp	r2, #0
 8003486:	d093      	beq.n	80033b0 <HAL_UART_IRQHandler+0x50>
          huart->RxISR(huart);
 8003488:	4620      	mov	r0, r4
 800348a:	4790      	blx	r2
 800348c:	6823      	ldr	r3, [r4, #0]
 800348e:	e78f      	b.n	80033b0 <HAL_UART_IRQHandler+0x50>
        HAL_UART_ErrorCallback(huart);
 8003490:	4620      	mov	r0, r4
 8003492:	f7ff ff63 	bl	800335c <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003496:	67e5      	str	r5, [r4, #124]	; 0x7c
}
 8003498:	bd70      	pop	{r4, r5, r6, pc}
 800349a:	bf00      	nop
 800349c:	080034a1 	.word	0x080034a1

080034a0 <UART_DMAAbortOnError>:
{
 80034a0:	b508      	push	{r3, lr}
  huart->RxXferCount = 0U;
 80034a2:	2200      	movs	r2, #0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80034a4:	6b83      	ldr	r3, [r0, #56]	; 0x38
  huart->RxXferCount = 0U;
 80034a6:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
  HAL_UART_ErrorCallback(huart);
 80034aa:	4618      	mov	r0, r3
  huart->TxXferCount = 0U;
 80034ac:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
  HAL_UART_ErrorCallback(huart);
 80034b0:	f7ff ff54 	bl	800335c <HAL_UART_ErrorCallback>
}
 80034b4:	bd08      	pop	{r3, pc}
 80034b6:	bf00      	nop

080034b8 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80034b8:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80034ba:	07da      	lsls	r2, r3, #31
{
 80034bc:	b410      	push	{r4}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80034be:	d506      	bpl.n	80034ce <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80034c0:	6801      	ldr	r1, [r0, #0]
 80034c2:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80034c4:	684a      	ldr	r2, [r1, #4]
 80034c6:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80034ca:	4322      	orrs	r2, r4
 80034cc:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80034ce:	079c      	lsls	r4, r3, #30
 80034d0:	d506      	bpl.n	80034e0 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80034d2:	6801      	ldr	r1, [r0, #0]
 80034d4:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80034d6:	684a      	ldr	r2, [r1, #4]
 80034d8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80034dc:	4322      	orrs	r2, r4
 80034de:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80034e0:	0759      	lsls	r1, r3, #29
 80034e2:	d506      	bpl.n	80034f2 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80034e4:	6801      	ldr	r1, [r0, #0]
 80034e6:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80034e8:	684a      	ldr	r2, [r1, #4]
 80034ea:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80034ee:	4322      	orrs	r2, r4
 80034f0:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80034f2:	071a      	lsls	r2, r3, #28
 80034f4:	d506      	bpl.n	8003504 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80034f6:	6801      	ldr	r1, [r0, #0]
 80034f8:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80034fa:	684a      	ldr	r2, [r1, #4]
 80034fc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003500:	4322      	orrs	r2, r4
 8003502:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8003504:	06dc      	lsls	r4, r3, #27
 8003506:	d506      	bpl.n	8003516 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8003508:	6801      	ldr	r1, [r0, #0]
 800350a:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800350c:	688a      	ldr	r2, [r1, #8]
 800350e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8003512:	4322      	orrs	r2, r4
 8003514:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8003516:	0699      	lsls	r1, r3, #26
 8003518:	d506      	bpl.n	8003528 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800351a:	6801      	ldr	r1, [r0, #0]
 800351c:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800351e:	688a      	ldr	r2, [r1, #8]
 8003520:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8003524:	4322      	orrs	r2, r4
 8003526:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8003528:	065a      	lsls	r2, r3, #25
 800352a:	d50a      	bpl.n	8003542 <UART_AdvFeatureConfig+0x8a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800352c:	6801      	ldr	r1, [r0, #0]
 800352e:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8003530:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8003532:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8003536:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800353a:	ea42 0204 	orr.w	r2, r2, r4
 800353e:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8003540:	d00b      	beq.n	800355a <UART_AdvFeatureConfig+0xa2>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8003542:	061b      	lsls	r3, r3, #24
 8003544:	d506      	bpl.n	8003554 <UART_AdvFeatureConfig+0x9c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8003546:	6802      	ldr	r2, [r0, #0]
 8003548:	6c81      	ldr	r1, [r0, #72]	; 0x48
 800354a:	6853      	ldr	r3, [r2, #4]
 800354c:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8003550:	430b      	orrs	r3, r1
 8003552:	6053      	str	r3, [r2, #4]
}
 8003554:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003558:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800355a:	684a      	ldr	r2, [r1, #4]
 800355c:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800355e:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8003562:	4322      	orrs	r2, r4
 8003564:	604a      	str	r2, [r1, #4]
 8003566:	e7ec      	b.n	8003542 <UART_AdvFeatureConfig+0x8a>

08003568 <HAL_UART_Init>:
  if (huart == NULL)
 8003568:	2800      	cmp	r0, #0
 800356a:	d04f      	beq.n	800360c <HAL_UART_Init+0xa4>
  if (huart->gState == HAL_UART_STATE_RESET)
 800356c:	6f43      	ldr	r3, [r0, #116]	; 0x74
{
 800356e:	b570      	push	{r4, r5, r6, lr}
 8003570:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 8003572:	2b00      	cmp	r3, #0
 8003574:	d045      	beq.n	8003602 <HAL_UART_Init+0x9a>
  __HAL_UART_DISABLE(huart);
 8003576:	6823      	ldr	r3, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8003578:	2124      	movs	r1, #36	; 0x24
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800357a:	6920      	ldr	r0, [r4, #16]
  huart->gState = HAL_UART_STATE_BUSY;
 800357c:	6761      	str	r1, [r4, #116]	; 0x74
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800357e:	68a2      	ldr	r2, [r4, #8]
  __HAL_UART_DISABLE(huart);
 8003580:	6819      	ldr	r1, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8003582:	4302      	orrs	r2, r0
 8003584:	6960      	ldr	r0, [r4, #20]
  __HAL_UART_DISABLE(huart);
 8003586:	f021 0101 	bic.w	r1, r1, #1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800358a:	4dbf      	ldr	r5, [pc, #764]	; (8003888 <HAL_UART_Init+0x320>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800358c:	4302      	orrs	r2, r0
 800358e:	69e0      	ldr	r0, [r4, #28]
  __HAL_UART_DISABLE(huart);
 8003590:	6019      	str	r1, [r3, #0]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8003592:	6819      	ldr	r1, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8003594:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8003596:	68e6      	ldr	r6, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8003598:	400d      	ands	r5, r1
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800359a:	69a1      	ldr	r1, [r4, #24]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800359c:	432a      	orrs	r2, r5
  tmpreg |= huart->Init.OneBitSampling;
 800359e:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80035a0:	601a      	str	r2, [r3, #0]
  tmpreg |= huart->Init.OneBitSampling;
 80035a2:	ea41 0205 	orr.w	r2, r1, r5
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80035a6:	6859      	ldr	r1, [r3, #4]
  UART_GETCLOCKSOURCE(huart, clocksource);
 80035a8:	4db8      	ldr	r5, [pc, #736]	; (800388c <HAL_UART_Init+0x324>)
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80035aa:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
  UART_GETCLOCKSOURCE(huart, clocksource);
 80035ae:	42ab      	cmp	r3, r5
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80035b0:	ea41 0106 	orr.w	r1, r1, r6
 80035b4:	6059      	str	r1, [r3, #4]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80035b6:	6899      	ldr	r1, [r3, #8]
 80035b8:	f421 6130 	bic.w	r1, r1, #2816	; 0xb00
 80035bc:	ea42 0201 	orr.w	r2, r2, r1
 80035c0:	609a      	str	r2, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 80035c2:	d025      	beq.n	8003610 <HAL_UART_Init+0xa8>
 80035c4:	4ab2      	ldr	r2, [pc, #712]	; (8003890 <HAL_UART_Init+0x328>)
 80035c6:	4293      	cmp	r3, r2
 80035c8:	d044      	beq.n	8003654 <HAL_UART_Init+0xec>
 80035ca:	4ab2      	ldr	r2, [pc, #712]	; (8003894 <HAL_UART_Init+0x32c>)
 80035cc:	4293      	cmp	r3, r2
 80035ce:	f000 80d5 	beq.w	800377c <HAL_UART_Init+0x214>
 80035d2:	4ab1      	ldr	r2, [pc, #708]	; (8003898 <HAL_UART_Init+0x330>)
 80035d4:	4293      	cmp	r3, r2
 80035d6:	d047      	beq.n	8003668 <HAL_UART_Init+0x100>
 80035d8:	4ab0      	ldr	r2, [pc, #704]	; (800389c <HAL_UART_Init+0x334>)
 80035da:	4293      	cmp	r3, r2
 80035dc:	f000 80e3 	beq.w	80037a6 <HAL_UART_Init+0x23e>
 80035e0:	4aaf      	ldr	r2, [pc, #700]	; (80038a0 <HAL_UART_Init+0x338>)
 80035e2:	4293      	cmp	r3, r2
 80035e4:	f000 816a 	beq.w	80038bc <HAL_UART_Init+0x354>
 80035e8:	4aae      	ldr	r2, [pc, #696]	; (80038a4 <HAL_UART_Init+0x33c>)
 80035ea:	4293      	cmp	r3, r2
 80035ec:	f000 8179 	beq.w	80038e2 <HAL_UART_Init+0x37a>
 80035f0:	4aad      	ldr	r2, [pc, #692]	; (80038a8 <HAL_UART_Init+0x340>)
 80035f2:	4293      	cmp	r3, r2
 80035f4:	f000 8137 	beq.w	8003866 <HAL_UART_Init+0x2fe>
  huart->RxISR = NULL;
 80035f8:	2300      	movs	r3, #0
    return HAL_ERROR;
 80035fa:	2001      	movs	r0, #1
  huart->TxISR = NULL;
 80035fc:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
}
 8003600:	bd70      	pop	{r4, r5, r6, pc}
    huart->Lock = HAL_UNLOCKED;
 8003602:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    HAL_UART_MspInit(huart);
 8003606:	f005 f99b 	bl	8008940 <HAL_UART_MspInit>
 800360a:	e7b4      	b.n	8003576 <HAL_UART_Init+0xe>
    return HAL_ERROR;
 800360c:	2001      	movs	r0, #1
}
 800360e:	4770      	bx	lr
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003610:	4ba6      	ldr	r3, [pc, #664]	; (80038ac <HAL_UART_Init+0x344>)
 8003612:	4aa7      	ldr	r2, [pc, #668]	; (80038b0 <HAL_UART_Init+0x348>)
 8003614:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003618:	f003 0303 	and.w	r3, r3, #3
 800361c:	5cd3      	ldrb	r3, [r2, r3]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800361e:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8003622:	d031      	beq.n	8003688 <HAL_UART_Init+0x120>
    switch (clocksource)
 8003624:	2b08      	cmp	r3, #8
 8003626:	d8e7      	bhi.n	80035f8 <HAL_UART_Init+0x90>
 8003628:	a201      	add	r2, pc, #4	; (adr r2, 8003630 <HAL_UART_Init+0xc8>)
 800362a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800362e:	bf00      	nop
 8003630:	0800376b 	.word	0x0800376b
 8003634:	080036c5 	.word	0x080036c5
 8003638:	08003797 	.word	0x08003797
 800363c:	080035f9 	.word	0x080035f9
 8003640:	080037bd 	.word	0x080037bd
 8003644:	080035f9 	.word	0x080035f9
 8003648:	080035f9 	.word	0x080035f9
 800364c:	080035f9 	.word	0x080035f9
 8003650:	080037cf 	.word	0x080037cf
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003654:	f502 32fa 	add.w	r2, r2, #128000	; 0x1f400
 8003658:	4b95      	ldr	r3, [pc, #596]	; (80038b0 <HAL_UART_Init+0x348>)
 800365a:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 800365e:	f002 020c 	and.w	r2, r2, #12
 8003662:	4413      	add	r3, r2
 8003664:	791b      	ldrb	r3, [r3, #4]
 8003666:	e7da      	b.n	800361e <HAL_UART_Init+0xb6>
 8003668:	4b90      	ldr	r3, [pc, #576]	; (80038ac <HAL_UART_Init+0x344>)
 800366a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800366e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8003672:	2b40      	cmp	r3, #64	; 0x40
 8003674:	f000 809f 	beq.w	80037b6 <HAL_UART_Init+0x24e>
 8003678:	d971      	bls.n	800375e <HAL_UART_Init+0x1f6>
 800367a:	2b80      	cmp	r3, #128	; 0x80
 800367c:	f000 8088 	beq.w	8003790 <HAL_UART_Init+0x228>
 8003680:	2bc0      	cmp	r3, #192	; 0xc0
 8003682:	f000 80b9 	beq.w	80037f8 <HAL_UART_Init+0x290>
 8003686:	e7b7      	b.n	80035f8 <HAL_UART_Init+0x90>
    switch (clocksource)
 8003688:	2b08      	cmp	r3, #8
 800368a:	d8b5      	bhi.n	80035f8 <HAL_UART_Init+0x90>
 800368c:	a201      	add	r2, pc, #4	; (adr r2, 8003694 <HAL_UART_Init+0x12c>)
 800368e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003692:	bf00      	nop
 8003694:	08003861 	.word	0x08003861
 8003698:	08003837 	.word	0x08003837
 800369c:	08003851 	.word	0x08003851
 80036a0:	080035f9 	.word	0x080035f9
 80036a4:	0800384b 	.word	0x0800384b
 80036a8:	080035f9 	.word	0x080035f9
 80036ac:	080035f9 	.word	0x080035f9
 80036b0:	080035f9 	.word	0x080035f9
 80036b4:	080037ff 	.word	0x080037ff
  UART_GETCLOCKSOURCE(huart, clocksource);
 80036b8:	2b00      	cmp	r3, #0
 80036ba:	d19d      	bne.n	80035f8 <HAL_UART_Init+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80036bc:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80036c0:	f000 80b9 	beq.w	8003836 <HAL_UART_Init+0x2ce>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 80036c4:	f7fe fe78 	bl	80023b8 <HAL_RCC_GetPCLK2Freq>
 80036c8:	6863      	ldr	r3, [r4, #4]
 80036ca:	eb00 0253 	add.w	r2, r0, r3, lsr #1
 80036ce:	fbb2 f2f3 	udiv	r2, r2, r3
 80036d2:	b292      	uxth	r2, r2
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80036d4:	f1a2 0110 	sub.w	r1, r2, #16
 80036d8:	f64f 73ef 	movw	r3, #65519	; 0xffef
 80036dc:	4299      	cmp	r1, r3
 80036de:	d88b      	bhi.n	80035f8 <HAL_UART_Init+0x90>
      huart->Instance->BRR = usartdiv;
 80036e0:	6823      	ldr	r3, [r4, #0]
  huart->RxISR = NULL;
 80036e2:	2100      	movs	r1, #0
      huart->Instance->BRR = usartdiv;
 80036e4:	60da      	str	r2, [r3, #12]
  huart->TxISR = NULL;
 80036e6:	e9c4 1118 	strd	r1, r1, [r4, #96]	; 0x60
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80036ea:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80036ec:	2a00      	cmp	r2, #0
 80036ee:	d176      	bne.n	80037de <HAL_UART_Init+0x276>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80036f0:	685a      	ldr	r2, [r3, #4]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80036f2:	2100      	movs	r1, #0
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80036f4:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80036f8:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80036fa:	689a      	ldr	r2, [r3, #8]
 80036fc:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8003700:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8003702:	681a      	ldr	r2, [r3, #0]
 8003704:	f042 0201 	orr.w	r2, r2, #1
 8003708:	601a      	str	r2, [r3, #0]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800370a:	67e1      	str	r1, [r4, #124]	; 0x7c
  tickstart = HAL_GetTick();
 800370c:	f7fc ff3a 	bl	8000584 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8003710:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 8003712:	4606      	mov	r6, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8003714:	681a      	ldr	r2, [r3, #0]
 8003716:	0712      	lsls	r2, r2, #28
 8003718:	d407      	bmi.n	800372a <HAL_UART_Init+0x1c2>
  huart->gState = HAL_UART_STATE_READY;
 800371a:	2220      	movs	r2, #32
  __HAL_UNLOCK(huart);
 800371c:	2300      	movs	r3, #0
  huart->gState = HAL_UART_STATE_READY;
 800371e:	6762      	str	r2, [r4, #116]	; 0x74
  return HAL_OK;
 8003720:	4618      	mov	r0, r3
  huart->RxState = HAL_UART_STATE_READY;
 8003722:	67a2      	str	r2, [r4, #120]	; 0x78
  __HAL_UNLOCK(huart);
 8003724:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8003728:	bd70      	pop	{r4, r5, r6, pc}
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800372a:	69dd      	ldr	r5, [r3, #28]
 800372c:	f415 1500 	ands.w	r5, r5, #2097152	; 0x200000
 8003730:	d1f3      	bne.n	800371a <HAL_UART_Init+0x1b2>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003732:	f7fc ff27 	bl	8000584 <HAL_GetTick>
 8003736:	1b80      	subs	r0, r0, r6
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8003738:	6823      	ldr	r3, [r4, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800373a:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
 800373e:	d3f4      	bcc.n	800372a <HAL_UART_Init+0x1c2>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8003740:	681a      	ldr	r2, [r3, #0]
        huart->gState = HAL_UART_STATE_READY;
 8003742:	2120      	movs	r1, #32
      return HAL_TIMEOUT;
 8003744:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8003746:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 800374a:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800374c:	689a      	ldr	r2, [r3, #8]
 800374e:	f022 0201 	bic.w	r2, r2, #1
 8003752:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 8003754:	6761      	str	r1, [r4, #116]	; 0x74
        __HAL_UNLOCK(huart);
 8003756:	f884 5070 	strb.w	r5, [r4, #112]	; 0x70
        huart->RxState = HAL_UART_STATE_READY;
 800375a:	67a1      	str	r1, [r4, #120]	; 0x78
}
 800375c:	bd70      	pop	{r4, r5, r6, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 800375e:	2b00      	cmp	r3, #0
 8003760:	f47f af4a 	bne.w	80035f8 <HAL_UART_Init+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003764:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8003768:	d07a      	beq.n	8003860 <HAL_UART_Init+0x2f8>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800376a:	f7fe fe15 	bl	8002398 <HAL_RCC_GetPCLK1Freq>
 800376e:	6863      	ldr	r3, [r4, #4]
 8003770:	eb00 0253 	add.w	r2, r0, r3, lsr #1
 8003774:	fbb2 f2f3 	udiv	r2, r2, r3
 8003778:	b292      	uxth	r2, r2
 800377a:	e7ab      	b.n	80036d4 <HAL_UART_Init+0x16c>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800377c:	4b4b      	ldr	r3, [pc, #300]	; (80038ac <HAL_UART_Init+0x344>)
 800377e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8003782:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8003786:	2b10      	cmp	r3, #16
 8003788:	d015      	beq.n	80037b6 <HAL_UART_Init+0x24e>
 800378a:	d9e8      	bls.n	800375e <HAL_UART_Init+0x1f6>
 800378c:	2b20      	cmp	r3, #32
 800378e:	d14f      	bne.n	8003830 <HAL_UART_Init+0x2c8>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003790:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8003794:	d05c      	beq.n	8003850 <HAL_UART_Init+0x2e8>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8003796:	6863      	ldr	r3, [r4, #4]
 8003798:	4a46      	ldr	r2, [pc, #280]	; (80038b4 <HAL_UART_Init+0x34c>)
 800379a:	eb02 0253 	add.w	r2, r2, r3, lsr #1
 800379e:	fbb2 f2f3 	udiv	r2, r2, r3
 80037a2:	b292      	uxth	r2, r2
 80037a4:	e796      	b.n	80036d4 <HAL_UART_Init+0x16c>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80037a6:	4b41      	ldr	r3, [pc, #260]	; (80038ac <HAL_UART_Init+0x344>)
 80037a8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80037ac:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80037b0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80037b4:	d118      	bne.n	80037e8 <HAL_UART_Init+0x280>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80037b6:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80037ba:	d046      	beq.n	800384a <HAL_UART_Init+0x2e2>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80037bc:	f7fe fdb2 	bl	8002324 <HAL_RCC_GetSysClockFreq>
 80037c0:	6863      	ldr	r3, [r4, #4]
 80037c2:	eb00 0253 	add.w	r2, r0, r3, lsr #1
 80037c6:	fbb2 f2f3 	udiv	r2, r2, r3
 80037ca:	b292      	uxth	r2, r2
 80037cc:	e782      	b.n	80036d4 <HAL_UART_Init+0x16c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 80037ce:	6863      	ldr	r3, [r4, #4]
 80037d0:	085a      	lsrs	r2, r3, #1
 80037d2:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
 80037d6:	fbb2 f2f3 	udiv	r2, r2, r3
 80037da:	b292      	uxth	r2, r2
 80037dc:	e77a      	b.n	80036d4 <HAL_UART_Init+0x16c>
    UART_AdvFeatureConfig(huart);
 80037de:	4620      	mov	r0, r4
 80037e0:	f7ff fe6a 	bl	80034b8 <UART_AdvFeatureConfig>
 80037e4:	6823      	ldr	r3, [r4, #0]
 80037e6:	e783      	b.n	80036f0 <HAL_UART_Init+0x188>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80037e8:	d9b9      	bls.n	800375e <HAL_UART_Init+0x1f6>
 80037ea:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80037ee:	d0cf      	beq.n	8003790 <HAL_UART_Init+0x228>
 80037f0:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80037f4:	f47f af00 	bne.w	80035f8 <HAL_UART_Init+0x90>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80037f8:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 80037fc:	d1e7      	bne.n	80037ce <HAL_UART_Init+0x266>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 80037fe:	6862      	ldr	r2, [r4, #4]
 8003800:	0853      	lsrs	r3, r2, #1
 8003802:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8003806:	fbb3 f3f2 	udiv	r3, r3, r2
 800380a:	b29b      	uxth	r3, r3
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800380c:	f1a3 0110 	sub.w	r1, r3, #16
 8003810:	f64f 72ef 	movw	r2, #65519	; 0xffef
 8003814:	4291      	cmp	r1, r2
 8003816:	f63f aeef 	bhi.w	80035f8 <HAL_UART_Init+0x90>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800381a:	f023 010f 	bic.w	r1, r3, #15
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800381e:	f3c3 0242 	ubfx	r2, r3, #1, #3
  huart->RxISR = NULL;
 8003822:	2000      	movs	r0, #0
      huart->Instance->BRR = brrtemp;
 8003824:	6823      	ldr	r3, [r4, #0]
 8003826:	430a      	orrs	r2, r1
 8003828:	60da      	str	r2, [r3, #12]
  huart->TxISR = NULL;
 800382a:	e9c4 0018 	strd	r0, r0, [r4, #96]	; 0x60
 800382e:	e75c      	b.n	80036ea <HAL_UART_Init+0x182>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003830:	2b30      	cmp	r3, #48	; 0x30
 8003832:	d0e1      	beq.n	80037f8 <HAL_UART_Init+0x290>
 8003834:	e6e0      	b.n	80035f8 <HAL_UART_Init+0x90>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8003836:	f7fe fdbf 	bl	80023b8 <HAL_RCC_GetPCLK2Freq>
 800383a:	6862      	ldr	r2, [r4, #4]
 800383c:	0853      	lsrs	r3, r2, #1
 800383e:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8003842:	fbb3 f3f2 	udiv	r3, r3, r2
 8003846:	b29b      	uxth	r3, r3
 8003848:	e7e0      	b.n	800380c <HAL_UART_Init+0x2a4>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800384a:	f7fe fd6b 	bl	8002324 <HAL_RCC_GetSysClockFreq>
 800384e:	e7f4      	b.n	800383a <HAL_UART_Init+0x2d2>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 8003850:	6862      	ldr	r2, [r4, #4]
 8003852:	4b19      	ldr	r3, [pc, #100]	; (80038b8 <HAL_UART_Init+0x350>)
 8003854:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 8003858:	fbb3 f3f2 	udiv	r3, r3, r2
 800385c:	b29b      	uxth	r3, r3
 800385e:	e7d5      	b.n	800380c <HAL_UART_Init+0x2a4>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 8003860:	f7fe fd9a 	bl	8002398 <HAL_RCC_GetPCLK1Freq>
 8003864:	e7e9      	b.n	800383a <HAL_UART_Init+0x2d2>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003866:	4b11      	ldr	r3, [pc, #68]	; (80038ac <HAL_UART_Init+0x344>)
 8003868:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800386c:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8003870:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8003874:	d09f      	beq.n	80037b6 <HAL_UART_Init+0x24e>
 8003876:	f67f af72 	bls.w	800375e <HAL_UART_Init+0x1f6>
 800387a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800387e:	d087      	beq.n	8003790 <HAL_UART_Init+0x228>
 8003880:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8003884:	d0b8      	beq.n	80037f8 <HAL_UART_Init+0x290>
 8003886:	e6b7      	b.n	80035f8 <HAL_UART_Init+0x90>
 8003888:	efff69f3 	.word	0xefff69f3
 800388c:	40011000 	.word	0x40011000
 8003890:	40004400 	.word	0x40004400
 8003894:	40004800 	.word	0x40004800
 8003898:	40004c00 	.word	0x40004c00
 800389c:	40005000 	.word	0x40005000
 80038a0:	40011400 	.word	0x40011400
 80038a4:	40007800 	.word	0x40007800
 80038a8:	40007c00 	.word	0x40007c00
 80038ac:	40023800 	.word	0x40023800
 80038b0:	08009230 	.word	0x08009230
 80038b4:	00f42400 	.word	0x00f42400
 80038b8:	01e84800 	.word	0x01e84800
 80038bc:	4b13      	ldr	r3, [pc, #76]	; (800390c <HAL_UART_Init+0x3a4>)
 80038be:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80038c2:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 80038c6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80038ca:	f43f af74 	beq.w	80037b6 <HAL_UART_Init+0x24e>
 80038ce:	f67f aef3 	bls.w	80036b8 <HAL_UART_Init+0x150>
 80038d2:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80038d6:	f43f af5b 	beq.w	8003790 <HAL_UART_Init+0x228>
 80038da:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 80038de:	d08b      	beq.n	80037f8 <HAL_UART_Init+0x290>
 80038e0:	e68a      	b.n	80035f8 <HAL_UART_Init+0x90>
 80038e2:	4b0a      	ldr	r3, [pc, #40]	; (800390c <HAL_UART_Init+0x3a4>)
 80038e4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80038e8:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 80038ec:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80038f0:	f43f af61 	beq.w	80037b6 <HAL_UART_Init+0x24e>
 80038f4:	f67f af33 	bls.w	800375e <HAL_UART_Init+0x1f6>
 80038f8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80038fc:	f43f af48 	beq.w	8003790 <HAL_UART_Init+0x228>
 8003900:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8003904:	f43f af78 	beq.w	80037f8 <HAL_UART_Init+0x290>
 8003908:	e676      	b.n	80035f8 <HAL_UART_Init+0x90>
 800390a:	bf00      	nop
 800390c:	40023800 	.word	0x40023800

08003910 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8003910:	b084      	sub	sp, #16
 8003912:	b430      	push	{r4, r5}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8003914:	9d08      	ldr	r5, [sp, #32]
{
 8003916:	ac03      	add	r4, sp, #12
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8003918:	2d01      	cmp	r5, #1
{
 800391a:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 800391e:	d131      	bne.n	8003984 <USB_CoreInit+0x74>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8003920:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8003922:	4b2d      	ldr	r3, [pc, #180]	; (80039d8 <USB_CoreInit+0xc8>)
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8003924:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
 8003928:	990f      	ldr	r1, [sp, #60]	; 0x3c
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 800392a:	6382      	str	r2, [r0, #56]	; 0x38
    if (cfg.use_external_vbus == 1U)
 800392c:	2901      	cmp	r1, #1
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800392e:	68c2      	ldr	r2, [r0, #12]
 8003930:	ea03 0302 	and.w	r3, r3, r2
 8003934:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8003936:	68c3      	ldr	r3, [r0, #12]
 8003938:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800393c:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 800393e:	d03d      	beq.n	80039bc <USB_CoreInit+0xac>
{
 8003940:	4b26      	ldr	r3, [pc, #152]	; (80039dc <USB_CoreInit+0xcc>)
 8003942:	e001      	b.n	8003948 <USB_CoreInit+0x38>
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 8003944:	3b01      	subs	r3, #1
 8003946:	d03e      	beq.n	80039c6 <USB_CoreInit+0xb6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8003948:	6902      	ldr	r2, [r0, #16]
 800394a:	2a00      	cmp	r2, #0
 800394c:	dafa      	bge.n	8003944 <USB_CoreInit+0x34>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800394e:	6903      	ldr	r3, [r0, #16]
 8003950:	4a22      	ldr	r2, [pc, #136]	; (80039dc <USB_CoreInit+0xcc>)
 8003952:	f043 0301 	orr.w	r3, r3, #1
 8003956:	6103      	str	r3, [r0, #16]
 8003958:	e001      	b.n	800395e <USB_CoreInit+0x4e>

  do
  {
    if (++count > 200000U)
 800395a:	3a01      	subs	r2, #1
 800395c:	d033      	beq.n	80039c6 <USB_CoreInit+0xb6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 800395e:	6903      	ldr	r3, [r0, #16]
 8003960:	f013 0301 	ands.w	r3, r3, #1
 8003964:	d1f9      	bne.n	800395a <USB_CoreInit+0x4a>
  if (cfg.dma_enable == 1U)
 8003966:	9a06      	ldr	r2, [sp, #24]
 8003968:	2a01      	cmp	r2, #1
 800396a:	d107      	bne.n	800397c <USB_CoreInit+0x6c>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 800396c:	6882      	ldr	r2, [r0, #8]
 800396e:	f042 0206 	orr.w	r2, r2, #6
 8003972:	6082      	str	r2, [r0, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8003974:	6882      	ldr	r2, [r0, #8]
 8003976:	f042 0220 	orr.w	r2, r2, #32
 800397a:	6082      	str	r2, [r0, #8]
}
 800397c:	4618      	mov	r0, r3
 800397e:	bc30      	pop	{r4, r5}
 8003980:	b004      	add	sp, #16
 8003982:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8003984:	68c2      	ldr	r2, [r0, #12]
 8003986:	4b15      	ldr	r3, [pc, #84]	; (80039dc <USB_CoreInit+0xcc>)
 8003988:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800398c:	60c2      	str	r2, [r0, #12]
 800398e:	e001      	b.n	8003994 <USB_CoreInit+0x84>
    if (++count > 200000U)
 8003990:	3b01      	subs	r3, #1
 8003992:	d01a      	beq.n	80039ca <USB_CoreInit+0xba>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8003994:	6902      	ldr	r2, [r0, #16]
 8003996:	2a00      	cmp	r2, #0
 8003998:	dafa      	bge.n	8003990 <USB_CoreInit+0x80>
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 800399a:	6903      	ldr	r3, [r0, #16]
 800399c:	4a0f      	ldr	r2, [pc, #60]	; (80039dc <USB_CoreInit+0xcc>)
 800399e:	f043 0301 	orr.w	r3, r3, #1
 80039a2:	6103      	str	r3, [r0, #16]
 80039a4:	e001      	b.n	80039aa <USB_CoreInit+0x9a>
    if (++count > 200000U)
 80039a6:	3a01      	subs	r2, #1
 80039a8:	d00f      	beq.n	80039ca <USB_CoreInit+0xba>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80039aa:	6903      	ldr	r3, [r0, #16]
 80039ac:	f013 0301 	ands.w	r3, r3, #1
 80039b0:	d1f9      	bne.n	80039a6 <USB_CoreInit+0x96>
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80039b2:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80039b4:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80039b8:	6382      	str	r2, [r0, #56]	; 0x38
 80039ba:	e7d4      	b.n	8003966 <USB_CoreInit+0x56>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 80039bc:	68c3      	ldr	r3, [r0, #12]
 80039be:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80039c2:	60c3      	str	r3, [r0, #12]
 80039c4:	e7bc      	b.n	8003940 <USB_CoreInit+0x30>
      return HAL_TIMEOUT;
 80039c6:	2303      	movs	r3, #3
 80039c8:	e7cd      	b.n	8003966 <USB_CoreInit+0x56>
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80039ca:	6b82      	ldr	r2, [r0, #56]	; 0x38
      return HAL_TIMEOUT;
 80039cc:	2303      	movs	r3, #3
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80039ce:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80039d2:	6382      	str	r2, [r0, #56]	; 0x38
 80039d4:	e7c7      	b.n	8003966 <USB_CoreInit+0x56>
 80039d6:	bf00      	nop
 80039d8:	ffbdffbf 	.word	0xffbdffbf
 80039dc:	00030d40 	.word	0x00030d40

080039e0 <USB_SetTurnaroundTime>:
  if (speed == USB_OTG_SPEED_FULL)
 80039e0:	2a03      	cmp	r2, #3
{
 80039e2:	4603      	mov	r3, r0
 80039e4:	b410      	push	{r4}
  if (speed == USB_OTG_SPEED_FULL)
 80039e6:	d00c      	beq.n	8003a02 <USB_SetTurnaroundTime+0x22>
 80039e8:	f44f 5410 	mov.w	r4, #9216	; 0x2400
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80039ec:	68d9      	ldr	r1, [r3, #12]
}
 80039ee:	2000      	movs	r0, #0
  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 80039f0:	f421 5170 	bic.w	r1, r1, #15360	; 0x3c00
 80039f4:	60d9      	str	r1, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 80039f6:	68da      	ldr	r2, [r3, #12]
 80039f8:	4322      	orrs	r2, r4
}
 80039fa:	f85d 4b04 	ldr.w	r4, [sp], #4
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 80039fe:	60da      	str	r2, [r3, #12]
}
 8003a00:	4770      	bx	lr
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 8003a02:	4a29      	ldr	r2, [pc, #164]	; (8003aa8 <USB_SetTurnaroundTime+0xc8>)
 8003a04:	4829      	ldr	r0, [pc, #164]	; (8003aac <USB_SetTurnaroundTime+0xcc>)
 8003a06:	440a      	add	r2, r1
 8003a08:	4282      	cmp	r2, r0
 8003a0a:	d93a      	bls.n	8003a82 <USB_SetTurnaroundTime+0xa2>
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 8003a0c:	4a28      	ldr	r2, [pc, #160]	; (8003ab0 <USB_SetTurnaroundTime+0xd0>)
 8003a0e:	4829      	ldr	r0, [pc, #164]	; (8003ab4 <USB_SetTurnaroundTime+0xd4>)
 8003a10:	440a      	add	r2, r1
 8003a12:	4282      	cmp	r2, r0
 8003a14:	d932      	bls.n	8003a7c <USB_SetTurnaroundTime+0x9c>
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 8003a16:	4a28      	ldr	r2, [pc, #160]	; (8003ab8 <USB_SetTurnaroundTime+0xd8>)
 8003a18:	4828      	ldr	r0, [pc, #160]	; (8003abc <USB_SetTurnaroundTime+0xdc>)
 8003a1a:	440a      	add	r2, r1
 8003a1c:	4282      	cmp	r2, r0
 8003a1e:	d933      	bls.n	8003a88 <USB_SetTurnaroundTime+0xa8>
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 8003a20:	4a27      	ldr	r2, [pc, #156]	; (8003ac0 <USB_SetTurnaroundTime+0xe0>)
 8003a22:	f500 30c3 	add.w	r0, r0, #99840	; 0x18600
 8003a26:	440a      	add	r2, r1
 8003a28:	30a0      	adds	r0, #160	; 0xa0
 8003a2a:	4282      	cmp	r2, r0
 8003a2c:	d92f      	bls.n	8003a8e <USB_SetTurnaroundTime+0xae>
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 8003a2e:	4a25      	ldr	r2, [pc, #148]	; (8003ac4 <USB_SetTurnaroundTime+0xe4>)
 8003a30:	4825      	ldr	r0, [pc, #148]	; (8003ac8 <USB_SetTurnaroundTime+0xe8>)
 8003a32:	440a      	add	r2, r1
 8003a34:	4282      	cmp	r2, r0
 8003a36:	d92d      	bls.n	8003a94 <USB_SetTurnaroundTime+0xb4>
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8003a38:	4a24      	ldr	r2, [pc, #144]	; (8003acc <USB_SetTurnaroundTime+0xec>)
 8003a3a:	f500 2092 	add.w	r0, r0, #299008	; 0x49000
 8003a3e:	440a      	add	r2, r1
 8003a40:	f500 7078 	add.w	r0, r0, #992	; 0x3e0
 8003a44:	4282      	cmp	r2, r0
 8003a46:	d928      	bls.n	8003a9a <USB_SetTurnaroundTime+0xba>
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 8003a48:	4a21      	ldr	r2, [pc, #132]	; (8003ad0 <USB_SetTurnaroundTime+0xf0>)
 8003a4a:	f500 20c3 	add.w	r0, r0, #399360	; 0x61800
 8003a4e:	440a      	add	r2, r1
 8003a50:	f500 7020 	add.w	r0, r0, #640	; 0x280
 8003a54:	4282      	cmp	r2, r0
 8003a56:	d9c7      	bls.n	80039e8 <USB_SetTurnaroundTime+0x8>
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8003a58:	4a1e      	ldr	r2, [pc, #120]	; (8003ad4 <USB_SetTurnaroundTime+0xf4>)
 8003a5a:	f500 10b7 	add.w	r0, r0, #1499136	; 0x16e000
 8003a5e:	440a      	add	r2, r1
 8003a60:	f500 7058 	add.w	r0, r0, #864	; 0x360
 8003a64:	4282      	cmp	r2, r0
 8003a66:	d91b      	bls.n	8003aa0 <USB_SetTurnaroundTime+0xc0>
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8003a68:	4a1b      	ldr	r2, [pc, #108]	; (8003ad8 <USB_SetTurnaroundTime+0xf8>)
 8003a6a:	4c1c      	ldr	r4, [pc, #112]	; (8003adc <USB_SetTurnaroundTime+0xfc>)
 8003a6c:	440a      	add	r2, r1
 8003a6e:	42a2      	cmp	r2, r4
 8003a70:	bf8c      	ite	hi
 8003a72:	f44f 54c0 	movhi.w	r4, #6144	; 0x1800
 8003a76:	f44f 54e0 	movls.w	r4, #7168	; 0x1c00
 8003a7a:	e7b7      	b.n	80039ec <USB_SetTurnaroundTime+0xc>
 8003a7c:	f44f 5460 	mov.w	r4, #14336	; 0x3800
 8003a80:	e7b4      	b.n	80039ec <USB_SetTurnaroundTime+0xc>
 8003a82:	f44f 5470 	mov.w	r4, #15360	; 0x3c00
 8003a86:	e7b1      	b.n	80039ec <USB_SetTurnaroundTime+0xc>
 8003a88:	f44f 5450 	mov.w	r4, #13312	; 0x3400
 8003a8c:	e7ae      	b.n	80039ec <USB_SetTurnaroundTime+0xc>
 8003a8e:	f44f 5440 	mov.w	r4, #12288	; 0x3000
 8003a92:	e7ab      	b.n	80039ec <USB_SetTurnaroundTime+0xc>
 8003a94:	f44f 5430 	mov.w	r4, #11264	; 0x2c00
 8003a98:	e7a8      	b.n	80039ec <USB_SetTurnaroundTime+0xc>
 8003a9a:	f44f 5420 	mov.w	r4, #10240	; 0x2800
 8003a9e:	e7a5      	b.n	80039ec <USB_SetTurnaroundTime+0xc>
 8003aa0:	f44f 5400 	mov.w	r4, #8192	; 0x2000
 8003aa4:	e7a2      	b.n	80039ec <USB_SetTurnaroundTime+0xc>
 8003aa6:	bf00      	nop
 8003aa8:	ff275340 	.word	0xff275340
 8003aac:	000c34ff 	.word	0x000c34ff
 8003ab0:	ff1b1e40 	.word	0xff1b1e40
 8003ab4:	000f423f 	.word	0x000f423f
 8003ab8:	ff0bdc00 	.word	0xff0bdc00
 8003abc:	00124f7f 	.word	0x00124f7f
 8003ac0:	fef98c80 	.word	0xfef98c80
 8003ac4:	fee5b660 	.word	0xfee5b660
 8003ac8:	0016e35f 	.word	0x0016e35f
 8003acc:	feced300 	.word	0xfeced300
 8003ad0:	feb35bc0 	.word	0xfeb35bc0
 8003ad4:	fe91ca00 	.word	0xfe91ca00
 8003ad8:	fe5954e0 	.word	0xfe5954e0
 8003adc:	00419cdf 	.word	0x00419cdf

08003ae0 <USB_EnableGlobalInt>:
{
 8003ae0:	4602      	mov	r2, r0
}
 8003ae2:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8003ae4:	6893      	ldr	r3, [r2, #8]
 8003ae6:	f043 0301 	orr.w	r3, r3, #1
 8003aea:	6093      	str	r3, [r2, #8]
}
 8003aec:	4770      	bx	lr
 8003aee:	bf00      	nop

08003af0 <USB_DisableGlobalInt>:
{
 8003af0:	4602      	mov	r2, r0
}
 8003af2:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8003af4:	6893      	ldr	r3, [r2, #8]
 8003af6:	f023 0301 	bic.w	r3, r3, #1
 8003afa:	6093      	str	r3, [r2, #8]
}
 8003afc:	4770      	bx	lr
 8003afe:	bf00      	nop

08003b00 <USB_SetCurrentMode>:
{
 8003b00:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8003b02:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 8003b04:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8003b06:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8003b0a:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 8003b0c:	d00b      	beq.n	8003b26 <USB_SetCurrentMode+0x26>
  else if (mode == USB_DEVICE_MODE)
 8003b0e:	b941      	cbnz	r1, 8003b22 <USB_SetCurrentMode+0x22>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8003b10:	68c3      	ldr	r3, [r0, #12]
 8003b12:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8003b16:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
 8003b18:	2032      	movs	r0, #50	; 0x32
 8003b1a:	f7fc fd39 	bl	8000590 <HAL_Delay>
  return HAL_OK;
 8003b1e:	2000      	movs	r0, #0
}
 8003b20:	bd08      	pop	{r3, pc}
    return HAL_ERROR;
 8003b22:	2001      	movs	r0, #1
}
 8003b24:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8003b26:	68c3      	ldr	r3, [r0, #12]
 8003b28:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8003b2c:	60c3      	str	r3, [r0, #12]
 8003b2e:	e7f3      	b.n	8003b18 <USB_SetCurrentMode+0x18>

08003b30 <USB_DevInit>:
{
 8003b30:	b084      	sub	sp, #16
 8003b32:	468c      	mov	ip, r1
 8003b34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003b38:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 8003b3a:	4604      	mov	r4, r0
 8003b3c:	af09      	add	r7, sp, #36	; 0x24
    USBx->DIEPTXF[i] = 0U;
 8003b3e:	2000      	movs	r0, #0
 8003b40:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8003b42:	f8c4 0104 	str.w	r0, [r4, #260]	; 0x104
 8003b46:	f8c4 0108 	str.w	r0, [r4, #264]	; 0x108
 8003b4a:	f8c4 010c 	str.w	r0, [r4, #268]	; 0x10c
 8003b4e:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
 8003b52:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 8003b56:	f8c4 0118 	str.w	r0, [r4, #280]	; 0x118
 8003b5a:	f8c4 011c 	str.w	r0, [r4, #284]	; 0x11c
 8003b5e:	f8c4 0120 	str.w	r0, [r4, #288]	; 0x120
 8003b62:	f8c4 0124 	str.w	r0, [r4, #292]	; 0x124
 8003b66:	f8c4 0128 	str.w	r0, [r4, #296]	; 0x128
 8003b6a:	f8c4 012c 	str.w	r0, [r4, #300]	; 0x12c
 8003b6e:	f8c4 0130 	str.w	r0, [r4, #304]	; 0x130
 8003b72:	f8c4 0134 	str.w	r0, [r4, #308]	; 0x134
 8003b76:	f8c4 0138 	str.w	r0, [r4, #312]	; 0x138
 8003b7a:	f8c4 013c 	str.w	r0, [r4, #316]	; 0x13c
{
 8003b7e:	e887 000e 	stmia.w	r7, {r1, r2, r3}
 8003b82:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8003b84:	990b      	ldr	r1, [sp, #44]	; 0x2c
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 8003b86:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  if (cfg.vbus_sensing_enable == 0U)
 8003b88:	2d00      	cmp	r5, #0
 8003b8a:	d157      	bne.n	8003c3c <USB_DevInit+0x10c>
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
 8003b8c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8003b90:	63a2      	str	r2, [r4, #56]	; 0x38
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
 8003b92:	6822      	ldr	r2, [r4, #0]
 8003b94:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003b98:	6022      	str	r2, [r4, #0]
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
 8003b9a:	6822      	ldr	r2, [r4, #0]
 8003b9c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003ba0:	6022      	str	r2, [r4, #0]
  USBx_PCGCCTL = 0U;
 8003ba2:	2200      	movs	r2, #0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8003ba4:	2b01      	cmp	r3, #1
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8003ba6:	f504 6700 	add.w	r7, r4, #2048	; 0x800
  USBx_PCGCCTL = 0U;
 8003baa:	f8c4 2e00 	str.w	r2, [r4, #3584]	; 0xe00
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8003bae:	f8d4 2800 	ldr.w	r2, [r4, #2048]	; 0x800
 8003bb2:	f8c4 2800 	str.w	r2, [r4, #2048]	; 0x800
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8003bb6:	f000 808e 	beq.w	8003cd6 <USB_DevInit+0x1a6>
  else if (cfg.phy_itface == USB_OTG_HS_EMBEDDED_PHY)
 8003bba:	2b03      	cmp	r3, #3
  USBx_DEVICE->DCFG |= speed;
 8003bbc:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
  else if (cfg.phy_itface == USB_OTG_HS_EMBEDDED_PHY)
 8003bc0:	d040      	beq.n	8003c44 <USB_DevInit+0x114>
  USBx_DEVICE->DCFG |= speed;
 8003bc2:	f043 0303 	orr.w	r3, r3, #3
 8003bc6:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8003bca:	f44f 6284 	mov.w	r2, #1056	; 0x420
 8003bce:	4b52      	ldr	r3, [pc, #328]	; (8003d18 <USB_DevInit+0x1e8>)
 8003bd0:	6122      	str	r2, [r4, #16]
 8003bd2:	e002      	b.n	8003bda <USB_DevInit+0xaa>
    if (++count > 200000U)
 8003bd4:	3b01      	subs	r3, #1
 8003bd6:	f000 8094 	beq.w	8003d02 <USB_DevInit+0x1d2>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8003bda:	6920      	ldr	r0, [r4, #16]
 8003bdc:	f010 0020 	ands.w	r0, r0, #32
 8003be0:	d1f8      	bne.n	8003bd4 <USB_DevInit+0xa4>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8003be2:	2210      	movs	r2, #16
 8003be4:	4b4c      	ldr	r3, [pc, #304]	; (8003d18 <USB_DevInit+0x1e8>)
 8003be6:	6122      	str	r2, [r4, #16]
 8003be8:	e002      	b.n	8003bf0 <USB_DevInit+0xc0>
    if (++count > 200000U)
 8003bea:	3b01      	subs	r3, #1
 8003bec:	f000 808b 	beq.w	8003d06 <USB_DevInit+0x1d6>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8003bf0:	6922      	ldr	r2, [r4, #16]
 8003bf2:	06d2      	lsls	r2, r2, #27
 8003bf4:	d4f9      	bmi.n	8003bea <USB_DevInit+0xba>
  USBx_DEVICE->DIEPMSK = 0U;
 8003bf6:	2200      	movs	r2, #0
 8003bf8:	613a      	str	r2, [r7, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8003bfa:	617a      	str	r2, [r7, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 8003bfc:	61fa      	str	r2, [r7, #28]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003bfe:	f1bc 0f00 	cmp.w	ip, #0
 8003c02:	d026      	beq.n	8003c52 <USB_DevInit+0x122>
 8003c04:	f504 6310 	add.w	r3, r4, #2304	; 0x900
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8003c08:	f04f 4990 	mov.w	r9, #1207959552	; 0x48000000
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8003c0c:	f04f 6a00 	mov.w	sl, #134217728	; 0x8000000
      USBx_INEP(i)->DIEPCTL = 0U;
 8003c10:	4696      	mov	lr, r2
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8003c12:	f64f 387f 	movw	r8, #64383	; 0xfb7f
 8003c16:	e009      	b.n	8003c2c <USB_DevInit+0xfc>
      USBx_INEP(i)->DIEPCTL = 0U;
 8003c18:	f8c3 e000 	str.w	lr, [r3]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003c1c:	3201      	adds	r2, #1
    USBx_INEP(i)->DIEPTSIZ = 0U;
 8003c1e:	f8c3 e010 	str.w	lr, [r3, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8003c22:	f8c3 8008 	str.w	r8, [r3, #8]
 8003c26:	3320      	adds	r3, #32
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003c28:	4562      	cmp	r2, ip
 8003c2a:	d036      	beq.n	8003c9a <USB_DevInit+0x16a>
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8003c2c:	6819      	ldr	r1, [r3, #0]
 8003c2e:	2900      	cmp	r1, #0
 8003c30:	daf2      	bge.n	8003c18 <USB_DevInit+0xe8>
      if (i == 0U)
 8003c32:	2a00      	cmp	r2, #0
 8003c34:	d06c      	beq.n	8003d10 <USB_DevInit+0x1e0>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8003c36:	f8c3 9000 	str.w	r9, [r3]
 8003c3a:	e7ef      	b.n	8003c1c <USB_DevInit+0xec>
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
 8003c3c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8003c40:	63a2      	str	r2, [r4, #56]	; 0x38
 8003c42:	e7ae      	b.n	8003ba2 <USB_DevInit+0x72>
    if (cfg.speed == USB_OTG_SPEED_HIGH)
 8003c44:	2900      	cmp	r1, #0
 8003c46:	d0be      	beq.n	8003bc6 <USB_DevInit+0x96>
  USBx_DEVICE->DCFG |= speed;
 8003c48:	f043 0301 	orr.w	r3, r3, #1
 8003c4c:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
 8003c50:	e7bb      	b.n	8003bca <USB_DevInit+0x9a>
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8003c52:	693b      	ldr	r3, [r7, #16]
  if (cfg.dma_enable == 1U)
 8003c54:	2e01      	cmp	r6, #1
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8003c56:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003c5a:	613b      	str	r3, [r7, #16]
  if (cfg.dma_enable == 1U)
 8003c5c:	d045      	beq.n	8003cea <USB_DevInit+0x1ba>
  USBx->GINTMSK = 0U;
 8003c5e:	2200      	movs	r2, #0
  USBx->GINTSTS = 0xBFFFFFFFU;
 8003c60:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
  USBx->GINTMSK = 0U;
 8003c64:	61a2      	str	r2, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 8003c66:	6163      	str	r3, [r4, #20]
  if (cfg.dma_enable == 0U)
 8003c68:	b91e      	cbnz	r6, 8003c72 <USB_DevInit+0x142>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8003c6a:	69a3      	ldr	r3, [r4, #24]
 8003c6c:	f043 0310 	orr.w	r3, r3, #16
 8003c70:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8003c72:	69a1      	ldr	r1, [r4, #24]
 8003c74:	4b29      	ldr	r3, [pc, #164]	; (8003d1c <USB_DevInit+0x1ec>)
  if (cfg.Sof_enable != 0U)
 8003c76:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8003c78:	430b      	orrs	r3, r1
 8003c7a:	61a3      	str	r3, [r4, #24]
  if (cfg.Sof_enable != 0U)
 8003c7c:	b11a      	cbz	r2, 8003c86 <USB_DevInit+0x156>
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8003c7e:	69a3      	ldr	r3, [r4, #24]
 8003c80:	f043 0308 	orr.w	r3, r3, #8
 8003c84:	61a3      	str	r3, [r4, #24]
  if (cfg.vbus_sensing_enable == 1U)
 8003c86:	2d01      	cmp	r5, #1
 8003c88:	d103      	bne.n	8003c92 <USB_DevInit+0x162>
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 8003c8a:	69a2      	ldr	r2, [r4, #24]
 8003c8c:	4b24      	ldr	r3, [pc, #144]	; (8003d20 <USB_DevInit+0x1f0>)
 8003c8e:	4313      	orrs	r3, r2
 8003c90:	61a3      	str	r3, [r4, #24]
}
 8003c92:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003c96:	b004      	add	sp, #16
 8003c98:	4770      	bx	lr
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003c9a:	2100      	movs	r1, #0
 8003c9c:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8003ca0:	f04f 4990 	mov.w	r9, #1207959552	; 0x48000000
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8003ca4:	f04f 6a00 	mov.w	sl, #134217728	; 0x8000000
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8003ca8:	468e      	mov	lr, r1
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8003caa:	f64f 387f 	movw	r8, #64383	; 0xfb7f
 8003cae:	e009      	b.n	8003cc4 <USB_DevInit+0x194>
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8003cb0:	f8c3 e000 	str.w	lr, [r3]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003cb4:	3101      	adds	r1, #1
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8003cb6:	f8c3 e010 	str.w	lr, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8003cba:	f8c3 8008 	str.w	r8, [r3, #8]
 8003cbe:	3320      	adds	r3, #32
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8003cc0:	4291      	cmp	r1, r2
 8003cc2:	d0c6      	beq.n	8003c52 <USB_DevInit+0x122>
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8003cc4:	f8d3 c000 	ldr.w	ip, [r3]
 8003cc8:	f1bc 0f00 	cmp.w	ip, #0
 8003ccc:	daf0      	bge.n	8003cb0 <USB_DevInit+0x180>
      if (i == 0U)
 8003cce:	b1e1      	cbz	r1, 8003d0a <USB_DevInit+0x1da>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8003cd0:	f8c3 9000 	str.w	r9, [r3]
 8003cd4:	e7ee      	b.n	8003cb4 <USB_DevInit+0x184>
  USBx_DEVICE->DCFG |= speed;
 8003cd6:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
    if (cfg.speed == USB_OTG_SPEED_HIGH)
 8003cda:	2900      	cmp	r1, #0
 8003cdc:	f43f af73 	beq.w	8003bc6 <USB_DevInit+0x96>
  USBx_DEVICE->DCFG |= speed;
 8003ce0:	f043 0301 	orr.w	r3, r3, #1
 8003ce4:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
 8003ce8:	e76f      	b.n	8003bca <USB_DevInit+0x9a>
    USBx_DEVICE->DTHRCTL = USB_OTG_DTHRCTL_TXTHRLEN_6 |
 8003cea:	4a0e      	ldr	r2, [pc, #56]	; (8003d24 <USB_DevInit+0x1f4>)
  USBx->GINTMSK = 0U;
 8003cec:	2100      	movs	r1, #0
    USBx_DEVICE->DTHRCTL |= USB_OTG_DTHRCTL_RXTHREN |
 8003cee:	4b0e      	ldr	r3, [pc, #56]	; (8003d28 <USB_DevInit+0x1f8>)
    USBx_DEVICE->DTHRCTL = USB_OTG_DTHRCTL_TXTHRLEN_6 |
 8003cf0:	633a      	str	r2, [r7, #48]	; 0x30
  USBx->GINTSTS = 0xBFFFFFFFU;
 8003cf2:	f06f 4280 	mvn.w	r2, #1073741824	; 0x40000000
    USBx_DEVICE->DTHRCTL |= USB_OTG_DTHRCTL_RXTHREN |
 8003cf6:	6b3e      	ldr	r6, [r7, #48]	; 0x30
 8003cf8:	4333      	orrs	r3, r6
 8003cfa:	633b      	str	r3, [r7, #48]	; 0x30
  USBx->GINTMSK = 0U;
 8003cfc:	61a1      	str	r1, [r4, #24]
  USBx->GINTSTS = 0xBFFFFFFFU;
 8003cfe:	6162      	str	r2, [r4, #20]
 8003d00:	e7b7      	b.n	8003c72 <USB_DevInit+0x142>
    ret = HAL_ERROR;
 8003d02:	2001      	movs	r0, #1
 8003d04:	e76d      	b.n	8003be2 <USB_DevInit+0xb2>
    ret = HAL_ERROR;
 8003d06:	2001      	movs	r0, #1
 8003d08:	e775      	b.n	8003bf6 <USB_DevInit+0xc6>
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8003d0a:	f8c3 a000 	str.w	sl, [r3]
 8003d0e:	e7d1      	b.n	8003cb4 <USB_DevInit+0x184>
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8003d10:	f8c3 a000 	str.w	sl, [r3]
 8003d14:	e782      	b.n	8003c1c <USB_DevInit+0xec>
 8003d16:	bf00      	nop
 8003d18:	00030d40 	.word	0x00030d40
 8003d1c:	803c3800 	.word	0x803c3800
 8003d20:	40000004 	.word	0x40000004
 8003d24:	00800100 	.word	0x00800100
 8003d28:	00010003 	.word	0x00010003

08003d2c <USB_FlushTxFifo>:
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8003d2c:	0189      	lsls	r1, r1, #6
 8003d2e:	4a07      	ldr	r2, [pc, #28]	; (8003d4c <USB_FlushTxFifo+0x20>)
 8003d30:	f041 0120 	orr.w	r1, r1, #32
 8003d34:	6101      	str	r1, [r0, #16]
 8003d36:	e001      	b.n	8003d3c <USB_FlushTxFifo+0x10>
    if (++count > 200000U)
 8003d38:	3a01      	subs	r2, #1
 8003d3a:	d005      	beq.n	8003d48 <USB_FlushTxFifo+0x1c>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8003d3c:	6903      	ldr	r3, [r0, #16]
 8003d3e:	f013 0320 	ands.w	r3, r3, #32
 8003d42:	d1f9      	bne.n	8003d38 <USB_FlushTxFifo+0xc>
  return HAL_OK;
 8003d44:	4618      	mov	r0, r3
 8003d46:	4770      	bx	lr
      return HAL_TIMEOUT;
 8003d48:	2003      	movs	r0, #3
}
 8003d4a:	4770      	bx	lr
 8003d4c:	00030d40 	.word	0x00030d40

08003d50 <USB_GetDevSpeed>:
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 8003d50:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8003d54:	f013 0006 	ands.w	r0, r3, #6
 8003d58:	d004      	beq.n	8003d64 <USB_GetDevSpeed+0x14>
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 8003d5a:	f013 0f02 	tst.w	r3, #2
    speed = USB_OTG_SPEED_FULL;
 8003d5e:	bf0c      	ite	eq
 8003d60:	2000      	moveq	r0, #0
 8003d62:	2003      	movne	r0, #3
}
 8003d64:	4770      	bx	lr
 8003d66:	bf00      	nop

08003d68 <USB_ActivateEndpoint>:
{
 8003d68:	b470      	push	{r4, r5, r6}
  uint32_t epnum = (uint32_t)ep->num;
 8003d6a:	780a      	ldrb	r2, [r1, #0]
 8003d6c:	2301      	movs	r3, #1
  if (ep->is_in == 1U)
 8003d6e:	784d      	ldrb	r5, [r1, #1]
 8003d70:	f500 6400 	add.w	r4, r0, #2048	; 0x800
 8003d74:	f002 060f 	and.w	r6, r2, #15
 8003d78:	eb00 1042 	add.w	r0, r0, r2, lsl #5
 8003d7c:	2d01      	cmp	r5, #1
 8003d7e:	fa03 f306 	lsl.w	r3, r3, r6
 8003d82:	d017      	beq.n	8003db4 <USB_ActivateEndpoint+0x4c>
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 8003d84:	69e2      	ldr	r2, [r4, #28]
 8003d86:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 8003d8a:	61e3      	str	r3, [r4, #28]
    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8003d8c:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8003d90:	041b      	lsls	r3, r3, #16
 8003d92:	d40c      	bmi.n	8003dae <USB_ActivateEndpoint+0x46>
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8003d94:	688a      	ldr	r2, [r1, #8]
 8003d96:	4b14      	ldr	r3, [pc, #80]	; (8003de8 <USB_ActivateEndpoint+0x80>)
 8003d98:	f3c2 020a 	ubfx	r2, r2, #0, #11
                                    ((uint32_t)ep->type << 18) |
 8003d9c:	78cc      	ldrb	r4, [r1, #3]
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8003d9e:	f8d0 1b00 	ldr.w	r1, [r0, #2816]	; 0xb00
 8003da2:	4313      	orrs	r3, r2
 8003da4:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
 8003da8:	430b      	orrs	r3, r1
 8003daa:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 8003dae:	2000      	movs	r0, #0
 8003db0:	bc70      	pop	{r4, r5, r6}
 8003db2:	4770      	bx	lr
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8003db4:	69e5      	ldr	r5, [r4, #28]
 8003db6:	432b      	orrs	r3, r5
 8003db8:	61e3      	str	r3, [r4, #28]
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8003dba:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8003dbe:	041c      	lsls	r4, r3, #16
 8003dc0:	d4f5      	bmi.n	8003dae <USB_ActivateEndpoint+0x46>
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8003dc2:	688c      	ldr	r4, [r1, #8]
 8003dc4:	4b08      	ldr	r3, [pc, #32]	; (8003de8 <USB_ActivateEndpoint+0x80>)
 8003dc6:	f3c4 040a 	ubfx	r4, r4, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 8003dca:	78cd      	ldrb	r5, [r1, #3]
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8003dcc:	f8d0 1900 	ldr.w	r1, [r0, #2304]	; 0x900
 8003dd0:	4323      	orrs	r3, r4
 8003dd2:	ea43 4385 	orr.w	r3, r3, r5, lsl #18
 8003dd6:	ea43 5282 	orr.w	r2, r3, r2, lsl #22
 8003dda:	430a      	orrs	r2, r1
}
 8003ddc:	bc70      	pop	{r4, r5, r6}
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8003dde:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
}
 8003de2:	2000      	movs	r0, #0
 8003de4:	4770      	bx	lr
 8003de6:	bf00      	nop
 8003de8:	10008000 	.word	0x10008000

08003dec <USB_DeactivateEndpoint>:
{
 8003dec:	b430      	push	{r4, r5}
  uint32_t epnum = (uint32_t)ep->num;
 8003dee:	780c      	ldrb	r4, [r1, #0]
 8003df0:	2301      	movs	r3, #1
  if (ep->is_in == 1U)
 8003df2:	7849      	ldrb	r1, [r1, #1]
 8003df4:	f500 6200 	add.w	r2, r0, #2048	; 0x800
 8003df8:	f004 050f 	and.w	r5, r4, #15
 8003dfc:	eb00 1044 	add.w	r0, r0, r4, lsl #5
 8003e00:	2901      	cmp	r1, #1
 8003e02:	fa03 f305 	lsl.w	r3, r3, r5
 8003e06:	d010      	beq.n	8003e2a <USB_DeactivateEndpoint+0x3e>
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8003e08:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
 8003e0a:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8003e0e:	490f      	ldr	r1, [pc, #60]	; (8003e4c <USB_DeactivateEndpoint+0x60>)
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8003e10:	401c      	ands	r4, r3
 8003e12:	63d4      	str	r4, [r2, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8003e14:	69d4      	ldr	r4, [r2, #28]
 8003e16:	4023      	ands	r3, r4
 8003e18:	61d3      	str	r3, [r2, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8003e1a:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 8003e1e:	4019      	ands	r1, r3
}
 8003e20:	bc30      	pop	{r4, r5}
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8003e22:	f8c0 1b00 	str.w	r1, [r0, #2816]	; 0xb00
}
 8003e26:	2000      	movs	r0, #0
 8003e28:	4770      	bx	lr
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8003e2a:	6bd4      	ldr	r4, [r2, #60]	; 0x3c
 8003e2c:	43db      	mvns	r3, r3
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8003e2e:	4908      	ldr	r1, [pc, #32]	; (8003e50 <USB_DeactivateEndpoint+0x64>)
    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8003e30:	401c      	ands	r4, r3
 8003e32:	63d4      	str	r4, [r2, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8003e34:	69d4      	ldr	r4, [r2, #28]
 8003e36:	4023      	ands	r3, r4
 8003e38:	61d3      	str	r3, [r2, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8003e3a:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8003e3e:	4019      	ands	r1, r3
}
 8003e40:	bc30      	pop	{r4, r5}
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8003e42:	f8c0 1900 	str.w	r1, [r0, #2304]	; 0x900
}
 8003e46:	2000      	movs	r0, #0
 8003e48:	4770      	bx	lr
 8003e4a:	bf00      	nop
 8003e4c:	eff37800 	.word	0xeff37800
 8003e50:	ec337800 	.word	0xec337800

08003e54 <USB_EPStartXfer>:
{
 8003e54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (ep->is_in == 1U)
 8003e58:	784f      	ldrb	r7, [r1, #1]
  uint32_t epnum = (uint32_t)ep->num;
 8003e5a:	f891 c000 	ldrb.w	ip, [r1]
  if (ep->is_in == 1U)
 8003e5e:	2f01      	cmp	r7, #1
 8003e60:	694b      	ldr	r3, [r1, #20]
 8003e62:	eb00 154c 	add.w	r5, r0, ip, lsl #5
 8003e66:	78ce      	ldrb	r6, [r1, #3]
 8003e68:	d055      	beq.n	8003f16 <USB_EPStartXfer+0xc2>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8003e6a:	f505 6730 	add.w	r7, r5, #2816	; 0xb00
 8003e6e:	f8df e1e4 	ldr.w	lr, [pc, #484]	; 8004054 <USB_EPStartXfer+0x200>
 8003e72:	f8d7 c010 	ldr.w	ip, [r7, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8003e76:	4c75      	ldr	r4, [pc, #468]	; (800404c <USB_EPStartXfer+0x1f8>)
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8003e78:	ea0c 0e0e 	and.w	lr, ip, lr
 8003e7c:	f8d1 c008 	ldr.w	ip, [r1, #8]
 8003e80:	f8c7 e010 	str.w	lr, [r7, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8003e84:	f8d7 e010 	ldr.w	lr, [r7, #16]
 8003e88:	ea0e 0404 	and.w	r4, lr, r4
 8003e8c:	613c      	str	r4, [r7, #16]
    if (ep->xfer_len == 0U)
 8003e8e:	b38b      	cbz	r3, 8003ef4 <USB_EPStartXfer+0xa0>
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8003e90:	eb0c 0403 	add.w	r4, ip, r3
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8003e94:	4b6e      	ldr	r3, [pc, #440]	; (8004050 <USB_EPStartXfer+0x1fc>)
 8003e96:	f8d7 8010 	ldr.w	r8, [r7, #16]
    if (dma == 1U)
 8003e9a:	2a01      	cmp	r2, #1
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8003e9c:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
 8003ea0:	fbb4 f4fc 	udiv	r4, r4, ip
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8003ea4:	ea03 4ec4 	and.w	lr, r3, r4, lsl #19
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 8003ea8:	b2a4      	uxth	r4, r4
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8003eaa:	ea4e 0e08 	orr.w	lr, lr, r8
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 8003eae:	fb0c f304 	mul.w	r3, ip, r4
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8003eb2:	f8c7 e010 	str.w	lr, [r7, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 8003eb6:	693c      	ldr	r4, [r7, #16]
 8003eb8:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8003ebc:	ea43 0304 	orr.w	r3, r3, r4
 8003ec0:	613b      	str	r3, [r7, #16]
    if (dma == 1U)
 8003ec2:	d023      	beq.n	8003f0c <USB_EPStartXfer+0xb8>
    if (ep->type == EP_TYPE_ISOC)
 8003ec4:	2e01      	cmp	r6, #1
 8003ec6:	d10c      	bne.n	8003ee2 <USB_EPStartXfer+0x8e>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8003ec8:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8003ecc:	f413 7f80 	tst.w	r3, #256	; 0x100
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 8003ed0:	f8d5 3b00 	ldr.w	r3, [r5, #2816]	; 0xb00
 8003ed4:	bf0c      	ite	eq
 8003ed6:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8003eda:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
 8003ede:	f8c5 3b00 	str.w	r3, [r5, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8003ee2:	f8d5 3b00 	ldr.w	r3, [r5, #2816]	; 0xb00
 8003ee6:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8003eea:	f8c5 3b00 	str.w	r3, [r5, #2816]	; 0xb00
}
 8003eee:	2000      	movs	r0, #0
 8003ef0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8003ef4:	693c      	ldr	r4, [r7, #16]
 8003ef6:	f3cc 0312 	ubfx	r3, ip, #0, #19
    if (dma == 1U)
 8003efa:	2a01      	cmp	r2, #1
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8003efc:	ea43 0304 	orr.w	r3, r3, r4
 8003f00:	613b      	str	r3, [r7, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8003f02:	693b      	ldr	r3, [r7, #16]
 8003f04:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003f08:	613b      	str	r3, [r7, #16]
    if (dma == 1U)
 8003f0a:	d1db      	bne.n	8003ec4 <USB_EPStartXfer+0x70>
      if ((uint32_t)ep->xfer_buff != 0U)
 8003f0c:	68cb      	ldr	r3, [r1, #12]
 8003f0e:	2b00      	cmp	r3, #0
 8003f10:	d0d8      	beq.n	8003ec4 <USB_EPStartXfer+0x70>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 8003f12:	617b      	str	r3, [r7, #20]
 8003f14:	e7d6      	b.n	8003ec4 <USB_EPStartXfer+0x70>
 8003f16:	f505 6410 	add.w	r4, r5, #2304	; 0x900
    if (ep->xfer_len == 0U)
 8003f1a:	b3fb      	cbz	r3, 8003f9c <USB_EPStartXfer+0x148>
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8003f1c:	f8d1 9008 	ldr.w	r9, [r1, #8]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8003f20:	f3c3 0e12 	ubfx	lr, r3, #0, #19
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8003f24:	f8d4 a010 	ldr.w	sl, [r4, #16]
      if (ep->type == EP_TYPE_ISOC)
 8003f28:	2e01      	cmp	r6, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8003f2a:	eb09 0803 	add.w	r8, r9, r3
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8003f2e:	f8df b124 	ldr.w	fp, [pc, #292]	; 8004054 <USB_EPStartXfer+0x200>
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8003f32:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8003f36:	ea0a 0b0b 	and.w	fp, sl, fp
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003f3a:	f8df a110 	ldr.w	sl, [pc, #272]	; 800404c <USB_EPStartXfer+0x1f8>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8003f3e:	f8c4 b010 	str.w	fp, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003f42:	f8d4 b010 	ldr.w	fp, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8003f46:	fbb8 f9f9 	udiv	r9, r8, r9
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003f4a:	ea0b 0a0a 	and.w	sl, fp, sl
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8003f4e:	f8df 8100 	ldr.w	r8, [pc, #256]	; 8004050 <USB_EPStartXfer+0x1fc>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003f52:	f8c4 a010 	str.w	sl, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 8003f56:	ea08 48c9 	and.w	r8, r8, r9, lsl #19
 8003f5a:	f8d4 9010 	ldr.w	r9, [r4, #16]
 8003f5e:	ea48 0809 	orr.w	r8, r8, r9
 8003f62:	f8c4 8010 	str.w	r8, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8003f66:	f8d4 8010 	ldr.w	r8, [r4, #16]
 8003f6a:	ea4e 0e08 	orr.w	lr, lr, r8
 8003f6e:	f8c4 e010 	str.w	lr, [r4, #16]
      if (ep->type == EP_TYPE_ISOC)
 8003f72:	d054      	beq.n	800401e <USB_EPStartXfer+0x1ca>
    if (dma == 1U)
 8003f74:	2a01      	cmp	r2, #1
 8003f76:	d064      	beq.n	8004042 <USB_EPStartXfer+0x1ee>
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8003f78:	f00c 0c0f 	and.w	ip, ip, #15
 8003f7c:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
 8003f80:	fa07 f70c 	lsl.w	r7, r7, ip
 8003f84:	431f      	orrs	r7, r3
 8003f86:	f8c0 7834 	str.w	r7, [r0, #2100]	; 0x834
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8003f8a:	f8d5 3900 	ldr.w	r3, [r5, #2304]	; 0x900
}
 8003f8e:	2000      	movs	r0, #0
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8003f90:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8003f94:	f8c5 3900 	str.w	r3, [r5, #2304]	; 0x900
}
 8003f98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003f9c:	f8d4 8010 	ldr.w	r8, [r4, #16]
    if (dma == 1U)
 8003fa0:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003fa2:	f8df e0a8 	ldr.w	lr, [pc, #168]	; 800404c <USB_EPStartXfer+0x1f8>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8003fa6:	4f2b      	ldr	r7, [pc, #172]	; (8004054 <USB_EPStartXfer+0x200>)
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8003fa8:	ea08 0e0e 	and.w	lr, r8, lr
 8003fac:	f8c4 e010 	str.w	lr, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8003fb0:	f8d4 e010 	ldr.w	lr, [r4, #16]
 8003fb4:	f44e 2e00 	orr.w	lr, lr, #524288	; 0x80000
 8003fb8:	f8c4 e010 	str.w	lr, [r4, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8003fbc:	f8d4 e010 	ldr.w	lr, [r4, #16]
 8003fc0:	ea0e 0707 	and.w	r7, lr, r7
 8003fc4:	6127      	str	r7, [r4, #16]
    if (dma == 1U)
 8003fc6:	d034      	beq.n	8004032 <USB_EPStartXfer+0x1de>
      if (ep->type != EP_TYPE_ISOC)
 8003fc8:	2e01      	cmp	r6, #1
 8003fca:	d1de      	bne.n	8003f8a <USB_EPStartXfer+0x136>
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8003fcc:	f8d0 4808 	ldr.w	r4, [r0, #2056]	; 0x808
 8003fd0:	f414 7f80 	tst.w	r4, #256	; 0x100
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8003fd4:	f8d5 4900 	ldr.w	r4, [r5, #2304]	; 0x900
 8003fd8:	bf0c      	ite	eq
 8003fda:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
        USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8003fde:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
 8003fe2:	f8c5 4900 	str.w	r4, [r5, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8003fe6:	f8d5 4900 	ldr.w	r4, [r5, #2304]	; 0x900
 8003fea:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 8003fee:	f8c5 4900 	str.w	r4, [r5, #2304]	; 0x900
  if (dma == 0U)
 8003ff2:	2a00      	cmp	r2, #0
 8003ff4:	f47f af7b 	bne.w	8003eee <USB_EPStartXfer+0x9a>
    count32b = ((uint32_t)len + 3U) / 4U;
 8003ff8:	b29b      	uxth	r3, r3
 8003ffa:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
 8003ffc:	089b      	lsrs	r3, r3, #2
 8003ffe:	f43f af76 	beq.w	8003eee <USB_EPStartXfer+0x9a>
      (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 8004002:	68ca      	ldr	r2, [r1, #12]
      USBx_DFIFO((uint32_t)ch_ep_num) = *((__packed uint32_t *)pSrc);
 8004004:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 8004008:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800400c:	eb00 3c0c 	add.w	ip, r0, ip, lsl #12
 8004010:	f852 1b04 	ldr.w	r1, [r2], #4
    for (i = 0U; i < count32b; i++)
 8004014:	429a      	cmp	r2, r3
      USBx_DFIFO((uint32_t)ch_ep_num) = *((__packed uint32_t *)pSrc);
 8004016:	f8cc 1000 	str.w	r1, [ip]
    for (i = 0U; i < count32b; i++)
 800401a:	d1f9      	bne.n	8004010 <USB_EPStartXfer+0x1bc>
 800401c:	e767      	b.n	8003eee <USB_EPStartXfer+0x9a>
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 800401e:	6927      	ldr	r7, [r4, #16]
    if (dma == 1U)
 8004020:	2a01      	cmp	r2, #1
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8004022:	f027 47c0 	bic.w	r7, r7, #1610612736	; 0x60000000
 8004026:	6127      	str	r7, [r4, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 8004028:	6927      	ldr	r7, [r4, #16]
 800402a:	f047 5700 	orr.w	r7, r7, #536870912	; 0x20000000
 800402e:	6127      	str	r7, [r4, #16]
    if (dma == 1U)
 8004030:	d1cc      	bne.n	8003fcc <USB_EPStartXfer+0x178>
      if ((uint32_t)ep->dma_addr != 0U)
 8004032:	690f      	ldr	r7, [r1, #16]
 8004034:	b107      	cbz	r7, 8004038 <USB_EPStartXfer+0x1e4>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8004036:	6167      	str	r7, [r4, #20]
    if (ep->type == EP_TYPE_ISOC)
 8004038:	2e01      	cmp	r6, #1
 800403a:	d1a6      	bne.n	8003f8a <USB_EPStartXfer+0x136>
 800403c:	f891 c000 	ldrb.w	ip, [r1]
 8004040:	e7c4      	b.n	8003fcc <USB_EPStartXfer+0x178>
      if ((uint32_t)ep->dma_addr != 0U)
 8004042:	690f      	ldr	r7, [r1, #16]
 8004044:	2f00      	cmp	r7, #0
 8004046:	d1f6      	bne.n	8004036 <USB_EPStartXfer+0x1e2>
 8004048:	e79f      	b.n	8003f8a <USB_EPStartXfer+0x136>
 800404a:	bf00      	nop
 800404c:	e007ffff 	.word	0xe007ffff
 8004050:	1ff80000 	.word	0x1ff80000
 8004054:	fff80000 	.word	0xfff80000

08004058 <USB_EP0StartXfer>:
  if (ep->is_in == 1U)
 8004058:	784b      	ldrb	r3, [r1, #1]
{
 800405a:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (ep->is_in == 1U)
 800405c:	2b01      	cmp	r3, #1
  uint32_t epnum = (uint32_t)ep->num;
 800405e:	780d      	ldrb	r5, [r1, #0]
 8004060:	694f      	ldr	r7, [r1, #20]
 8004062:	eb00 1445 	add.w	r4, r0, r5, lsl #5
  if (ep->is_in == 1U)
 8004066:	d025      	beq.n	80040b4 <USB_EP0StartXfer+0x5c>
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8004068:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
 800406c:	4e3e      	ldr	r6, [pc, #248]	; (8004168 <USB_EP0StartXfer+0x110>)
 800406e:	6918      	ldr	r0, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8004070:	4d3e      	ldr	r5, [pc, #248]	; (800416c <USB_EP0StartXfer+0x114>)
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8004072:	4006      	ands	r6, r0
 8004074:	6888      	ldr	r0, [r1, #8]
 8004076:	611e      	str	r6, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8004078:	691e      	ldr	r6, [r3, #16]
 800407a:	4035      	ands	r5, r6
 800407c:	611d      	str	r5, [r3, #16]
    if (ep->xfer_len > 0U)
 800407e:	b107      	cbz	r7, 8004082 <USB_EP0StartXfer+0x2a>
      ep->xfer_len = ep->maxpacket;
 8004080:	6148      	str	r0, [r1, #20]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8004082:	691d      	ldr	r5, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
 8004084:	f3c0 0012 	ubfx	r0, r0, #0, #19
    if (dma == 1U)
 8004088:	2a01      	cmp	r2, #1
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 800408a:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 800408e:	611d      	str	r5, [r3, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
 8004090:	691d      	ldr	r5, [r3, #16]
 8004092:	ea40 0005 	orr.w	r0, r0, r5
 8004096:	6118      	str	r0, [r3, #16]
    if (dma == 1U)
 8004098:	d007      	beq.n	80040aa <USB_EP0StartXfer+0x52>
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800409a:	f8d4 3b00 	ldr.w	r3, [r4, #2816]	; 0xb00
}
 800409e:	2000      	movs	r0, #0
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 80040a0:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 80040a4:	f8c4 3b00 	str.w	r3, [r4, #2816]	; 0xb00
}
 80040a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if ((uint32_t)ep->xfer_buff != 0U)
 80040aa:	68ca      	ldr	r2, [r1, #12]
 80040ac:	2a00      	cmp	r2, #0
 80040ae:	d0f4      	beq.n	800409a <USB_EP0StartXfer+0x42>
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 80040b0:	615a      	str	r2, [r3, #20]
 80040b2:	e7f2      	b.n	800409a <USB_EP0StartXfer+0x42>
 80040b4:	f504 6310 	add.w	r3, r4, #2304	; 0x900
    if (ep->xfer_len == 0U)
 80040b8:	b39f      	cbz	r7, 8004122 <USB_EP0StartXfer+0xca>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80040ba:	f8d3 e010 	ldr.w	lr, [r3, #16]
 80040be:	f8df c0a8 	ldr.w	ip, [pc, #168]	; 8004168 <USB_EP0StartXfer+0x110>
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80040c2:	4e2a      	ldr	r6, [pc, #168]	; (800416c <USB_EP0StartXfer+0x114>)
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80040c4:	ea0e 0c0c 	and.w	ip, lr, ip
      if (ep->xfer_len > ep->maxpacket)
 80040c8:	f8d1 e008 	ldr.w	lr, [r1, #8]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80040cc:	f8c3 c010 	str.w	ip, [r3, #16]
      if (ep->xfer_len > ep->maxpacket)
 80040d0:	45be      	cmp	lr, r7
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80040d2:	f8d3 c010 	ldr.w	ip, [r3, #16]
 80040d6:	ea0c 0606 	and.w	r6, ip, r6
 80040da:	611e      	str	r6, [r3, #16]
      if (ep->xfer_len > ep->maxpacket)
 80040dc:	d236      	bcs.n	800414c <USB_EP0StartXfer+0xf4>
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80040de:	691f      	ldr	r7, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80040e0:	f3ce 0612 	ubfx	r6, lr, #0, #19
        ep->xfer_len = ep->maxpacket;
 80040e4:	f8c1 e014 	str.w	lr, [r1, #20]
    if (dma == 1U)
 80040e8:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80040ea:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
 80040ee:	611f      	str	r7, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80040f0:	691f      	ldr	r7, [r3, #16]
 80040f2:	ea46 0607 	orr.w	r6, r6, r7
 80040f6:	611e      	str	r6, [r3, #16]
    if (dma == 1U)
 80040f8:	d023      	beq.n	8004142 <USB_EP0StartXfer+0xea>
      if (ep->xfer_len > 0U)
 80040fa:	f1be 0f00 	cmp.w	lr, #0
 80040fe:	d008      	beq.n	8004112 <USB_EP0StartXfer+0xba>
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8004100:	f005 020f 	and.w	r2, r5, #15
 8004104:	2501      	movs	r5, #1
 8004106:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
 800410a:	4095      	lsls	r5, r2
 800410c:	431d      	orrs	r5, r3
 800410e:	f8c0 5834 	str.w	r5, [r0, #2100]	; 0x834
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8004112:	f8d4 3900 	ldr.w	r3, [r4, #2304]	; 0x900
}
 8004116:	2000      	movs	r0, #0
    USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8004118:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800411c:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
}
 8004120:	bdf0      	pop	{r4, r5, r6, r7, pc}
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8004122:	691e      	ldr	r6, [r3, #16]
    if (dma == 1U)
 8004124:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8004126:	4d11      	ldr	r5, [pc, #68]	; (800416c <USB_EP0StartXfer+0x114>)
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8004128:	480f      	ldr	r0, [pc, #60]	; (8004168 <USB_EP0StartXfer+0x110>)
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800412a:	ea05 0506 	and.w	r5, r5, r6
 800412e:	611d      	str	r5, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8004130:	691d      	ldr	r5, [r3, #16]
 8004132:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
 8004136:	611d      	str	r5, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8004138:	691d      	ldr	r5, [r3, #16]
 800413a:	ea00 0005 	and.w	r0, r0, r5
 800413e:	6118      	str	r0, [r3, #16]
    if (dma == 1U)
 8004140:	d1e7      	bne.n	8004112 <USB_EP0StartXfer+0xba>
      if ((uint32_t)ep->dma_addr != 0U)
 8004142:	690a      	ldr	r2, [r1, #16]
 8004144:	2a00      	cmp	r2, #0
 8004146:	d0e4      	beq.n	8004112 <USB_EP0StartXfer+0xba>
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8004148:	615a      	str	r2, [r3, #20]
 800414a:	e7e2      	b.n	8004112 <USB_EP0StartXfer+0xba>
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 800414c:	691e      	ldr	r6, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800414e:	f3c7 0712 	ubfx	r7, r7, #0, #19
    if (dma == 1U)
 8004152:	2a01      	cmp	r2, #1
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8004154:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 8004158:	611e      	str	r6, [r3, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 800415a:	691e      	ldr	r6, [r3, #16]
 800415c:	ea47 0706 	orr.w	r7, r7, r6
 8004160:	611f      	str	r7, [r3, #16]
    if (dma == 1U)
 8004162:	d1cd      	bne.n	8004100 <USB_EP0StartXfer+0xa8>
 8004164:	e7ed      	b.n	8004142 <USB_EP0StartXfer+0xea>
 8004166:	bf00      	nop
 8004168:	fff80000 	.word	0xfff80000
 800416c:	e007ffff 	.word	0xe007ffff

08004170 <USB_WritePacket>:
{
 8004170:	b410      	push	{r4}
 8004172:	f89d 4004 	ldrb.w	r4, [sp, #4]
  if (dma == 0U)
 8004176:	b96c      	cbnz	r4, 8004194 <USB_WritePacket+0x24>
    count32b = ((uint32_t)len + 3U) / 4U;
 8004178:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
 800417a:	089b      	lsrs	r3, r3, #2
 800417c:	d00a      	beq.n	8004194 <USB_WritePacket+0x24>
      USBx_DFIFO((uint32_t)ch_ep_num) = *((__packed uint32_t *)pSrc);
 800417e:	eb00 3002 	add.w	r0, r0, r2, lsl #12
 8004182:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8004186:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 800418a:	f851 2b04 	ldr.w	r2, [r1], #4
    for (i = 0U; i < count32b; i++)
 800418e:	428b      	cmp	r3, r1
      USBx_DFIFO((uint32_t)ch_ep_num) = *((__packed uint32_t *)pSrc);
 8004190:	6002      	str	r2, [r0, #0]
    for (i = 0U; i < count32b; i++)
 8004192:	d1fa      	bne.n	800418a <USB_WritePacket+0x1a>
}
 8004194:	2000      	movs	r0, #0
 8004196:	f85d 4b04 	ldr.w	r4, [sp], #4
 800419a:	4770      	bx	lr

0800419c <USB_ReadPacket>:
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 800419c:	3203      	adds	r2, #3
  for (i = 0U; i < count32b; i++)
 800419e:	0892      	lsrs	r2, r2, #2
 80041a0:	d00d      	beq.n	80041be <USB_ReadPacket+0x22>
 80041a2:	eb01 0282 	add.w	r2, r1, r2, lsl #2
{
 80041a6:	b410      	push	{r4}
 80041a8:	f500 5480 	add.w	r4, r0, #4096	; 0x1000
  uint32_t *pDest = (uint32_t *)dest;
 80041ac:	4608      	mov	r0, r1
    *(__packed uint32_t *)pDest = USBx_DFIFO(0U);
 80041ae:	6823      	ldr	r3, [r4, #0]
 80041b0:	f840 3b04 	str.w	r3, [r0], #4
  for (i = 0U; i < count32b; i++)
 80041b4:	4282      	cmp	r2, r0
 80041b6:	d1fa      	bne.n	80041ae <USB_ReadPacket+0x12>
}
 80041b8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80041bc:	4770      	bx	lr
  uint32_t *pDest = (uint32_t *)dest;
 80041be:	4608      	mov	r0, r1
}
 80041c0:	4770      	bx	lr
 80041c2:	bf00      	nop

080041c4 <USB_EPSetStall>:
  uint32_t epnum = (uint32_t)ep->num;
 80041c4:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1U)
 80041c6:	784a      	ldrb	r2, [r1, #1]
 80041c8:	eb00 1043 	add.w	r0, r0, r3, lsl #5
 80041cc:	3300      	adds	r3, #0
 80041ce:	bf18      	it	ne
 80041d0:	2301      	movne	r3, #1
 80041d2:	2a01      	cmp	r2, #1
 80041d4:	d012      	beq.n	80041fc <USB_EPSetStall+0x38>
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 80041d6:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
 80041da:	2a00      	cmp	r2, #0
 80041dc:	db06      	blt.n	80041ec <USB_EPSetStall+0x28>
 80041de:	b12b      	cbz	r3, 80041ec <USB_EPSetStall+0x28>
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 80041e0:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80041e4:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80041e8:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 80041ec:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80041f0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80041f4:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 80041f8:	2000      	movs	r0, #0
 80041fa:	4770      	bx	lr
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 80041fc:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 8004200:	2a00      	cmp	r2, #0
 8004202:	db06      	blt.n	8004212 <USB_EPSetStall+0x4e>
 8004204:	b12b      	cbz	r3, 8004212 <USB_EPSetStall+0x4e>
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8004206:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800420a:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 800420e:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8004212:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8004216:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800421a:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 800421e:	2000      	movs	r0, #0
 8004220:	4770      	bx	lr
 8004222:	bf00      	nop

08004224 <USB_EPClearStall>:
{
 8004224:	78cb      	ldrb	r3, [r1, #3]
 8004226:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1U)
 8004228:	7849      	ldrb	r1, [r1, #1]
 800422a:	3b02      	subs	r3, #2
 800422c:	eb00 1042 	add.w	r0, r0, r2, lsl #5
 8004230:	2901      	cmp	r1, #1
 8004232:	b2db      	uxtb	r3, r3
 8004234:	d011      	beq.n	800425a <USB_EPClearStall+0x36>
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8004236:	f8d0 2b00 	ldr.w	r2, [r0, #2816]	; 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 800423a:	2b01      	cmp	r3, #1
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800423c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8004240:	f8c0 2b00 	str.w	r2, [r0, #2816]	; 0xb00
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8004244:	d901      	bls.n	800424a <USB_EPClearStall+0x26>
}
 8004246:	2000      	movs	r0, #0
 8004248:	4770      	bx	lr
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800424a:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800424e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004252:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 8004256:	2000      	movs	r0, #0
 8004258:	4770      	bx	lr
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800425a:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 800425e:	2b01      	cmp	r3, #1
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8004260:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8004264:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8004268:	d8ed      	bhi.n	8004246 <USB_EPClearStall+0x22>
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 800426a:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 800426e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004272:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
}
 8004276:	2000      	movs	r0, #0
 8004278:	4770      	bx	lr
 800427a:	bf00      	nop

0800427c <USB_SetDevAddress>:
{
 800427c:	4603      	mov	r3, r0
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 800427e:	0109      	lsls	r1, r1, #4
}
 8004280:	2000      	movs	r0, #0
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8004282:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8004286:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 800428a:	f422 62fe 	bic.w	r2, r2, #2032	; 0x7f0
 800428e:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8004292:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
 8004296:	4311      	orrs	r1, r2
 8004298:	f8c3 1800 	str.w	r1, [r3, #2048]	; 0x800
}
 800429c:	4770      	bx	lr
 800429e:	bf00      	nop

080042a0 <USB_DevConnect>:
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 80042a0:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  HAL_Delay(3U);
 80042a4:	2003      	movs	r0, #3
{
 80042a6:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 80042a8:	6853      	ldr	r3, [r2, #4]
 80042aa:	f023 0302 	bic.w	r3, r3, #2
 80042ae:	6053      	str	r3, [r2, #4]
  HAL_Delay(3U);
 80042b0:	f7fc f96e 	bl	8000590 <HAL_Delay>
}
 80042b4:	2000      	movs	r0, #0
 80042b6:	bd08      	pop	{r3, pc}

080042b8 <USB_DevDisconnect>:
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80042b8:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  HAL_Delay(3U);
 80042bc:	2003      	movs	r0, #3
{
 80042be:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80042c0:	6853      	ldr	r3, [r2, #4]
 80042c2:	f043 0302 	orr.w	r3, r3, #2
 80042c6:	6053      	str	r3, [r2, #4]
  HAL_Delay(3U);
 80042c8:	f7fc f962 	bl	8000590 <HAL_Delay>
}
 80042cc:	2000      	movs	r0, #0
 80042ce:	bd08      	pop	{r3, pc}

080042d0 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 80042d0:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 80042d2:	6980      	ldr	r0, [r0, #24]
}
 80042d4:	4010      	ands	r0, r2
 80042d6:	4770      	bx	lr

080042d8 <USB_ReadDevAllOutEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 80042d8:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 80042dc:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 80042e0:	69c0      	ldr	r0, [r0, #28]
 80042e2:	4018      	ands	r0, r3
}
 80042e4:	0c00      	lsrs	r0, r0, #16
 80042e6:	4770      	bx	lr

080042e8 <USB_ReadDevAllInEpInterrupt>:
  tmpreg  = USBx_DEVICE->DAINT;
 80042e8:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 80042ec:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg &= USBx_DEVICE->DAINTMSK;
 80042f0:	69c0      	ldr	r0, [r0, #28]
 80042f2:	4018      	ands	r0, r3
}
 80042f4:	b280      	uxth	r0, r0
 80042f6:	4770      	bx	lr

080042f8 <USB_ReadDevOutEPInterrupt>:
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 80042f8:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  tmpreg &= USBx_DEVICE->DOEPMSK;
 80042fc:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8004300:	f8d1 2b08 	ldr.w	r2, [r1, #2824]	; 0xb08
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8004304:	6940      	ldr	r0, [r0, #20]
}
 8004306:	4010      	ands	r0, r2
 8004308:	4770      	bx	lr
 800430a:	bf00      	nop

0800430c <USB_ReadDevInEPInterrupt>:
  msk = USBx_DEVICE->DIEPMSK;
 800430c:	f500 6200 	add.w	r2, r0, #2048	; 0x800
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8004310:	eb00 1041 	add.w	r0, r0, r1, lsl #5
{
 8004314:	b410      	push	{r4}
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8004316:	f001 040f 	and.w	r4, r1, #15
  msk = USBx_DEVICE->DIEPMSK;
 800431a:	6911      	ldr	r1, [r2, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
 800431c:	6b53      	ldr	r3, [r2, #52]	; 0x34
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 800431e:	f500 6010 	add.w	r0, r0, #2304	; 0x900
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8004322:	40e3      	lsrs	r3, r4
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8004324:	6880      	ldr	r0, [r0, #8]
}
 8004326:	f85d 4b04 	ldr.w	r4, [sp], #4
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 800432a:	01db      	lsls	r3, r3, #7
 800432c:	b2db      	uxtb	r3, r3
 800432e:	430b      	orrs	r3, r1
}
 8004330:	4018      	ands	r0, r3
 8004332:	4770      	bx	lr

08004334 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 8004334:	6940      	ldr	r0, [r0, #20]
}
 8004336:	f000 0001 	and.w	r0, r0, #1
 800433a:	4770      	bx	lr

0800433c <USB_ActivateSetup>:
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 800433c:	f8d0 1900 	ldr.w	r1, [r0, #2304]	; 0x900
  if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8004340:	f500 6300 	add.w	r3, r0, #2048	; 0x800
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8004344:	4a0a      	ldr	r2, [pc, #40]	; (8004370 <USB_ActivateSetup+0x34>)
 8004346:	400a      	ands	r2, r1
 8004348:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
  if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 800434c:	689a      	ldr	r2, [r3, #8]
 800434e:	f002 0206 	and.w	r2, r2, #6
 8004352:	2a04      	cmp	r2, #4
 8004354:	d105      	bne.n	8004362 <USB_ActivateSetup+0x26>
    USBx_INEP(0U)->DIEPCTL |= 3U;
 8004356:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 800435a:	f042 0203 	orr.w	r2, r2, #3
 800435e:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8004362:	685a      	ldr	r2, [r3, #4]
}
 8004364:	2000      	movs	r0, #0
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8004366:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800436a:	605a      	str	r2, [r3, #4]
}
 800436c:	4770      	bx	lr
 800436e:	bf00      	nop
 8004370:	fffff800 	.word	0xfffff800

08004374 <USB_EP0_OutStart>:
{
 8004374:	b430      	push	{r4, r5}
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8004376:	4c12      	ldr	r4, [pc, #72]	; (80043c0 <USB_EP0_OutStart+0x4c>)
 8004378:	f500 6330 	add.w	r3, r0, #2816	; 0xb00
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 800437c:	6c05      	ldr	r5, [r0, #64]	; 0x40
  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 800437e:	42a5      	cmp	r5, r4
 8004380:	d903      	bls.n	800438a <USB_EP0_OutStart+0x16>
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8004382:	f8d0 4b00 	ldr.w	r4, [r0, #2816]	; 0xb00
 8004386:	2c00      	cmp	r4, #0
 8004388:	db16      	blt.n	80043b8 <USB_EP0_OutStart+0x44>
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 800438a:	2400      	movs	r4, #0
  if (dma == 1U)
 800438c:	2901      	cmp	r1, #1
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 800438e:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8004390:	691c      	ldr	r4, [r3, #16]
 8004392:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 8004396:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8004398:	691c      	ldr	r4, [r3, #16]
 800439a:	f044 0418 	orr.w	r4, r4, #24
 800439e:	611c      	str	r4, [r3, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 80043a0:	691c      	ldr	r4, [r3, #16]
 80043a2:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
 80043a6:	611c      	str	r4, [r3, #16]
  if (dma == 1U)
 80043a8:	d106      	bne.n	80043b8 <USB_EP0_OutStart+0x44>
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 80043aa:	615a      	str	r2, [r3, #20]
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 80043ac:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 80043b0:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 80043b4:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 80043b8:	2000      	movs	r0, #0
 80043ba:	bc30      	pop	{r4, r5}
 80043bc:	4770      	bx	lr
 80043be:	bf00      	nop
 80043c0:	4f54300a 	.word	0x4f54300a

080043c4 <USBD_MIDI_DataIn>:
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_MIDI_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum)
{
  USBD_MIDI_HandleTypeDef   *hmidi = (USBD_MIDI_HandleTypeDef*) pdev->pClassData;
 80043c4:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290
  
  if(pdev->pClassData != NULL)
 80043c8:	b11b      	cbz	r3, 80043d2 <USBD_MIDI_DataIn+0xe>
  {
    
    hmidi->TxState = 0;
 80043ca:	2000      	movs	r0, #0
 80043cc:	f8c3 0214 	str.w	r0, [r3, #532]	; 0x214

    return USBD_OK;
 80043d0:	4770      	bx	lr
  }
  else
  {
    return USBD_FAIL;
 80043d2:	2002      	movs	r0, #2
  }
}
 80043d4:	4770      	bx	lr
 80043d6:	bf00      	nop

080043d8 <USBD_MIDI_EP0_RxReady>:
  */
static uint8_t  USBD_MIDI_EP0_RxReady (USBD_HandleTypeDef *pdev)
{ 
  USBD_MIDI_HandleTypeDef   *hmidi = (USBD_MIDI_HandleTypeDef*) pdev->pClassData;
  
  if((pdev->pUserData != NULL) && (hmidi->CmdOpCode != 0xFF))
 80043d8:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 80043dc:	b183      	cbz	r3, 8004400 <USBD_MIDI_EP0_RxReady+0x28>
{ 
 80043de:	b510      	push	{r4, lr}
  USBD_MIDI_HandleTypeDef   *hmidi = (USBD_MIDI_HandleTypeDef*) pdev->pClassData;
 80043e0:	f8d0 4290 	ldr.w	r4, [r0, #656]	; 0x290
  if((pdev->pUserData != NULL) && (hmidi->CmdOpCode != 0xFF))
 80043e4:	f894 0200 	ldrb.w	r0, [r4, #512]	; 0x200
 80043e8:	28ff      	cmp	r0, #255	; 0xff
 80043ea:	d007      	beq.n	80043fc <USBD_MIDI_EP0_RxReady+0x24>
  {
    ((USBD_MIDI_ItfTypeDef *)pdev->pUserData)->Control(hmidi->CmdOpCode,
 80043ec:	689b      	ldr	r3, [r3, #8]
 80043ee:	4621      	mov	r1, r4
 80043f0:	f894 2201 	ldrb.w	r2, [r4, #513]	; 0x201
 80043f4:	4798      	blx	r3
                                                      (uint8_t *)hmidi->data,
                                                      hmidi->CmdLength);
      hmidi->CmdOpCode = 0xFF;
 80043f6:	23ff      	movs	r3, #255	; 0xff
 80043f8:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
      
  }
  return USBD_OK;
}
 80043fc:	2000      	movs	r0, #0
 80043fe:	bd10      	pop	{r4, pc}
 8004400:	2000      	movs	r0, #0
 8004402:	4770      	bx	lr

08004404 <USBD_MIDI_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_MIDI_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MIDI_CfgFSDesc);
 8004404:	2365      	movs	r3, #101	; 0x65
 8004406:	8003      	strh	r3, [r0, #0]
  return USBD_MIDI_CfgFSDesc;
}
 8004408:	4800      	ldr	r0, [pc, #0]	; (800440c <USBD_MIDI_GetFSCfgDesc+0x8>)
 800440a:	4770      	bx	lr
 800440c:	20000008 	.word	0x20000008

08004410 <USBD_MIDI_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_MIDI_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MIDI_CfgHSDesc);
 8004410:	2365      	movs	r3, #101	; 0x65
 8004412:	8003      	strh	r3, [r0, #0]
  return USBD_MIDI_CfgHSDesc;
}
 8004414:	4800      	ldr	r0, [pc, #0]	; (8004418 <USBD_MIDI_GetHSCfgDesc+0x8>)
 8004416:	4770      	bx	lr
 8004418:	20000070 	.word	0x20000070

0800441c <USBD_MIDI_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_MIDI_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_MIDI_OtherSpeedCfgDesc);
 800441c:	2365      	movs	r3, #101	; 0x65
 800441e:	8003      	strh	r3, [r0, #0]
  return USBD_MIDI_OtherSpeedCfgDesc;
}
 8004420:	4800      	ldr	r0, [pc, #0]	; (8004424 <USBD_MIDI_GetOtherSpeedCfgDesc+0x8>)
 8004422:	4770      	bx	lr
 8004424:	200000d8 	.word	0x200000d8

08004428 <USBD_MIDI_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_MIDI_GetDeviceQualifierDescriptor (uint16_t *length)
{
  *length = sizeof (USBD_MIDI_DeviceQualifierDesc);
 8004428:	230a      	movs	r3, #10
 800442a:	8003      	strh	r3, [r0, #0]
  return USBD_MIDI_DeviceQualifierDesc;
}
 800442c:	4800      	ldr	r0, [pc, #0]	; (8004430 <USBD_MIDI_GetDeviceQualifierDescriptor+0x8>)
 800442e:	4770      	bx	lr
 8004430:	20000140 	.word	0x20000140

08004434 <USBD_MIDI_DataOut>:
{      
 8004434:	b538      	push	{r3, r4, r5, lr}
 8004436:	4604      	mov	r4, r0
  USBD_MIDI_HandleTypeDef   *hmidi = (USBD_MIDI_HandleTypeDef*) pdev->pClassData;
 8004438:	f8d0 5290 	ldr.w	r5, [r0, #656]	; 0x290
  hmidi->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 800443c:	f004 fc44 	bl	8008cc8 <USBD_LL_GetRxDataSize>
  if(pdev->pClassData != NULL)
 8004440:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  hmidi->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 8004444:	f8c5 020c 	str.w	r0, [r5, #524]	; 0x20c
  if(pdev->pClassData != NULL)
 8004448:	b14b      	cbz	r3, 800445e <USBD_MIDI_DataOut+0x2a>
    ((USBD_MIDI_ItfTypeDef *)pdev->pUserData)->Receive(hmidi->RxBuffer, &hmidi->RxLength);
 800444a:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 800444e:	f505 7103 	add.w	r1, r5, #524	; 0x20c
 8004452:	f8d5 0204 	ldr.w	r0, [r5, #516]	; 0x204
 8004456:	68db      	ldr	r3, [r3, #12]
 8004458:	4798      	blx	r3
    return USBD_OK;
 800445a:	2000      	movs	r0, #0
}
 800445c:	bd38      	pop	{r3, r4, r5, pc}
    return USBD_FAIL;
 800445e:	2002      	movs	r0, #2
}
 8004460:	bd38      	pop	{r3, r4, r5, pc}
 8004462:	bf00      	nop

08004464 <USBD_MIDI_Setup>:
{
 8004464:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004468:	780b      	ldrb	r3, [r1, #0]
{
 800446a:	460c      	mov	r4, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800446c:	f013 0260 	ands.w	r2, r3, #96	; 0x60
 8004470:	d00e      	beq.n	8004490 <USBD_MIDI_Setup+0x2c>
 8004472:	2a20      	cmp	r2, #32
 8004474:	d109      	bne.n	800448a <USBD_MIDI_Setup+0x26>
    if (req->wLength)
 8004476:	88ce      	ldrh	r6, [r1, #6]
 8004478:	4605      	mov	r5, r0
 800447a:	784f      	ldrb	r7, [r1, #1]
 800447c:	b996      	cbnz	r6, 80044a4 <USBD_MIDI_Setup+0x40>
      ((USBD_MIDI_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 800447e:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 8004482:	4632      	mov	r2, r6
 8004484:	4638      	mov	r0, r7
 8004486:	689b      	ldr	r3, [r3, #8]
 8004488:	4798      	blx	r3
}
 800448a:	2000      	movs	r0, #0
 800448c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    switch (req->bRequest)
 8004490:	784b      	ldrb	r3, [r1, #1]
 8004492:	2b0a      	cmp	r3, #10
 8004494:	d1f9      	bne.n	800448a <USBD_MIDI_Setup+0x26>
      USBD_CtlSendData (pdev,
 8004496:	2201      	movs	r2, #1
 8004498:	490f      	ldr	r1, [pc, #60]	; (80044d8 <USBD_MIDI_Setup+0x74>)
 800449a:	f000 fcc1 	bl	8004e20 <USBD_CtlSendData>
}
 800449e:	2000      	movs	r0, #0
 80044a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (req->bmRequest & 0x80)
 80044a4:	061b      	lsls	r3, r3, #24
  USBD_MIDI_HandleTypeDef   *hmidi = (USBD_MIDI_HandleTypeDef*) pdev->pClassData;
 80044a6:	f8d0 8290 	ldr.w	r8, [r0, #656]	; 0x290
      if (req->bmRequest & 0x80)
 80044aa:	d50c      	bpl.n	80044c6 <USBD_MIDI_Setup+0x62>
        ((USBD_MIDI_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 80044ac:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
 80044b0:	4632      	mov	r2, r6
 80044b2:	4641      	mov	r1, r8
 80044b4:	4638      	mov	r0, r7
 80044b6:	689b      	ldr	r3, [r3, #8]
 80044b8:	4798      	blx	r3
          USBD_CtlSendData (pdev, 
 80044ba:	88e2      	ldrh	r2, [r4, #6]
 80044bc:	4641      	mov	r1, r8
 80044be:	4628      	mov	r0, r5
 80044c0:	f000 fcae 	bl	8004e20 <USBD_CtlSendData>
 80044c4:	e7e1      	b.n	800448a <USBD_MIDI_Setup+0x26>
        hmidi->CmdOpCode = req->bRequest;
 80044c6:	f888 7200 	strb.w	r7, [r8, #512]	; 0x200
        USBD_CtlPrepareRx (pdev, 
 80044ca:	4632      	mov	r2, r6
        hmidi->CmdLength = req->wLength;
 80044cc:	f888 6201 	strb.w	r6, [r8, #513]	; 0x201
        USBD_CtlPrepareRx (pdev, 
 80044d0:	4641      	mov	r1, r8
 80044d2:	f000 fcbb 	bl	8004e4c <USBD_CtlPrepareRx>
 80044d6:	e7d8      	b.n	800448a <USBD_MIDI_Setup+0x26>
 80044d8:	20000278 	.word	0x20000278

080044dc <USBD_MIDI_DeInit>:
{
 80044dc:	b510      	push	{r4, lr}
 80044de:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev,
 80044e0:	2181      	movs	r1, #129	; 0x81
 80044e2:	f004 fb89 	bl	8008bf8 <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 80044e6:	2101      	movs	r1, #1
 80044e8:	4620      	mov	r0, r4
 80044ea:	f004 fb85 	bl	8008bf8 <USBD_LL_CloseEP>
  USBD_LL_CloseEP(pdev,
 80044ee:	4620      	mov	r0, r4
 80044f0:	2182      	movs	r1, #130	; 0x82
 80044f2:	f004 fb81 	bl	8008bf8 <USBD_LL_CloseEP>
  if(pdev->pClassData != NULL)
 80044f6:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
 80044fa:	b153      	cbz	r3, 8004512 <USBD_MIDI_DeInit+0x36>
    ((USBD_MIDI_ItfTypeDef *)pdev->pUserData)->DeInit();
 80044fc:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
 8004500:	685b      	ldr	r3, [r3, #4]
 8004502:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 8004504:	f8d4 0290 	ldr.w	r0, [r4, #656]	; 0x290
 8004508:	f004 fdbc 	bl	8009084 <free>
    pdev->pClassData = NULL;
 800450c:	2300      	movs	r3, #0
 800450e:	f8c4 3290 	str.w	r3, [r4, #656]	; 0x290
}
 8004512:	2000      	movs	r0, #0
 8004514:	bd10      	pop	{r4, pc}
 8004516:	bf00      	nop

08004518 <USBD_MIDI_Init>:
{
 8004518:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 800451a:	7c03      	ldrb	r3, [r0, #16]
{
 800451c:	4604      	mov	r4, r0
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 800451e:	bb73      	cbnz	r3, 800457e <USBD_MIDI_Init+0x66>
    USBD_LL_OpenEP(pdev,
 8004520:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004524:	2202      	movs	r2, #2
 8004526:	2181      	movs	r1, #129	; 0x81
 8004528:	f004 fb54 	bl	8008bd4 <USBD_LL_OpenEP>
    USBD_LL_OpenEP(pdev,
 800452c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004530:	2202      	movs	r2, #2
 8004532:	2101      	movs	r1, #1
 8004534:	4620      	mov	r0, r4
 8004536:	f004 fb4d 	bl	8008bd4 <USBD_LL_OpenEP>
  USBD_LL_OpenEP(pdev,
 800453a:	2308      	movs	r3, #8
 800453c:	2203      	movs	r2, #3
 800453e:	2182      	movs	r1, #130	; 0x82
 8004540:	4620      	mov	r0, r4
 8004542:	f004 fb47 	bl	8008bd4 <USBD_LL_OpenEP>
  pdev->pClassData = USBD_malloc(sizeof (USBD_MIDI_HandleTypeDef));
 8004546:	f44f 7007 	mov.w	r0, #540	; 0x21c
 800454a:	f004 fd93 	bl	8009074 <malloc>
 800454e:	4605      	mov	r5, r0
 8004550:	f8c4 0290 	str.w	r0, [r4, #656]	; 0x290
  if(pdev->pClassData == NULL)
 8004554:	b330      	cbz	r0, 80045a4 <USBD_MIDI_Init+0x8c>
    ((USBD_MIDI_ItfTypeDef *)pdev->pUserData)->Init();
 8004556:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    hmidi->TxState =0;
 800455a:	2600      	movs	r6, #0
    ((USBD_MIDI_ItfTypeDef *)pdev->pUserData)->Init();
 800455c:	681b      	ldr	r3, [r3, #0]
 800455e:	4798      	blx	r3
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8004560:	7c27      	ldrb	r7, [r4, #16]
    hmidi->TxState =0;
 8004562:	f8c5 6214 	str.w	r6, [r5, #532]	; 0x214
      USBD_LL_PrepareReceive(pdev,
 8004566:	4620      	mov	r0, r4
    hmidi->RxState =0;
 8004568:	f8c5 6218 	str.w	r6, [r5, #536]	; 0x218
      USBD_LL_PrepareReceive(pdev,
 800456c:	f8d5 2204 	ldr.w	r2, [r5, #516]	; 0x204
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8004570:	b18f      	cbz	r7, 8004596 <USBD_MIDI_Init+0x7e>
      USBD_LL_PrepareReceive(pdev,
 8004572:	2340      	movs	r3, #64	; 0x40
 8004574:	2101      	movs	r1, #1
 8004576:	f004 fb99 	bl	8008cac <USBD_LL_PrepareReceive>
  uint8_t ret = 0;
 800457a:	4630      	mov	r0, r6
}
 800457c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    USBD_LL_OpenEP(pdev,
 800457e:	2340      	movs	r3, #64	; 0x40
 8004580:	2202      	movs	r2, #2
 8004582:	2181      	movs	r1, #129	; 0x81
 8004584:	f004 fb26 	bl	8008bd4 <USBD_LL_OpenEP>
    USBD_LL_OpenEP(pdev,
 8004588:	2340      	movs	r3, #64	; 0x40
 800458a:	2202      	movs	r2, #2
 800458c:	2101      	movs	r1, #1
 800458e:	4620      	mov	r0, r4
 8004590:	f004 fb20 	bl	8008bd4 <USBD_LL_OpenEP>
 8004594:	e7d1      	b.n	800453a <USBD_MIDI_Init+0x22>
      USBD_LL_PrepareReceive(pdev,
 8004596:	f44f 7300 	mov.w	r3, #512	; 0x200
 800459a:	2101      	movs	r1, #1
 800459c:	f004 fb86 	bl	8008cac <USBD_LL_PrepareReceive>
  uint8_t ret = 0;
 80045a0:	4638      	mov	r0, r7
}
 80045a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret = 1; 
 80045a4:	2001      	movs	r0, #1
}
 80045a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080045a8 <USBD_MIDI_RegisterInterface>:
uint8_t  USBD_MIDI_RegisterInterface  (USBD_HandleTypeDef   *pdev,
                                      USBD_MIDI_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;
  
  if(fops != NULL)
 80045a8:	b119      	cbz	r1, 80045b2 <USBD_MIDI_RegisterInterface+0xa>
  {
    pdev->pUserData= fops;
 80045aa:	f8c0 1294 	str.w	r1, [r0, #660]	; 0x294
    ret = USBD_OK;    
 80045ae:	2000      	movs	r0, #0
 80045b0:	4770      	bx	lr
  uint8_t  ret = USBD_FAIL;
 80045b2:	2002      	movs	r0, #2
  }
  
  return ret;
}
 80045b4:	4770      	bx	lr
 80045b6:	bf00      	nop

080045b8 <USBD_MIDI_SetTxBuffer>:
  */
uint8_t  USBD_MIDI_SetTxBuffer  (USBD_HandleTypeDef   *pdev,
                                uint8_t  *pbuff,
                                uint16_t length)
{
  USBD_MIDI_HandleTypeDef   *hmidi = (USBD_MIDI_HandleTypeDef*) pdev->pClassData;
 80045b8:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290
  
  hmidi->TxBuffer = pbuff;
  hmidi->TxLength = length;
  
  return USBD_OK;  
}
 80045bc:	2000      	movs	r0, #0
  hmidi->TxBuffer = pbuff;
 80045be:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
  hmidi->TxLength = length;
 80045c2:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
}
 80045c6:	4770      	bx	lr

080045c8 <USBD_MIDI_SetRxBuffer>:
uint8_t  USBD_MIDI_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                   uint8_t  *pbuff)
{
  USBD_MIDI_HandleTypeDef   *hmidi = (USBD_MIDI_HandleTypeDef*) pdev->pClassData;
  
  hmidi->RxBuffer = pbuff;
 80045c8:	f8d0 3290 	ldr.w	r3, [r0, #656]	; 0x290
  
  return USBD_OK;
}
 80045cc:	2000      	movs	r0, #0
  hmidi->RxBuffer = pbuff;
 80045ce:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
}
 80045d2:	4770      	bx	lr

080045d4 <USBD_MIDI_TransmitPacket>:
  * @param  epnum: endpoint number
  * @retval status
  */
uint8_t  USBD_MIDI_TransmitPacket(USBD_HandleTypeDef *pdev)
{      
  USBD_MIDI_HandleTypeDef   *hmidi = (USBD_MIDI_HandleTypeDef*) pdev->pClassData;
 80045d4:	f8d0 1290 	ldr.w	r1, [r0, #656]	; 0x290
  
  if(pdev->pClassData != NULL)
 80045d8:	b189      	cbz	r1, 80045fe <USBD_MIDI_TransmitPacket+0x2a>
{      
 80045da:	b538      	push	{r3, r4, r5, lr}
  {
    if(hmidi->TxState == 0)
 80045dc:	f8d1 4214 	ldr.w	r4, [r1, #532]	; 0x214
 80045e0:	b10c      	cbz	r4, 80045e6 <USBD_MIDI_TransmitPacket+0x12>
      
      return USBD_OK;
    }
    else
    {
      return USBD_BUSY;
 80045e2:	2001      	movs	r0, #1
  }
  else
  {
    return USBD_FAIL;
  }
}
 80045e4:	bd38      	pop	{r3, r4, r5, pc}
      hmidi->TxState = 1;
 80045e6:	2501      	movs	r5, #1
      USBD_LL_Transmit(pdev,
 80045e8:	f8b1 3210 	ldrh.w	r3, [r1, #528]	; 0x210
 80045ec:	f8d1 2208 	ldr.w	r2, [r1, #520]	; 0x208
      hmidi->TxState = 1;
 80045f0:	f8c1 5214 	str.w	r5, [r1, #532]	; 0x214
      USBD_LL_Transmit(pdev,
 80045f4:	2181      	movs	r1, #129	; 0x81
 80045f6:	f004 fb4b 	bl	8008c90 <USBD_LL_Transmit>
      return USBD_OK;
 80045fa:	4620      	mov	r0, r4
}
 80045fc:	bd38      	pop	{r3, r4, r5, pc}
    return USBD_FAIL;
 80045fe:	2002      	movs	r0, #2
}
 8004600:	4770      	bx	lr
 8004602:	bf00      	nop

08004604 <USBD_MIDI_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_MIDI_ReceivePacket(USBD_HandleTypeDef *pdev)
{      
  USBD_MIDI_HandleTypeDef   *hmidi = (USBD_MIDI_HandleTypeDef*) pdev->pClassData;
 8004604:	f8d0 2290 	ldr.w	r2, [r0, #656]	; 0x290
  
  /* Suspend or Resume USB Out process */
  if(pdev->pClassData != NULL)
 8004608:	b18a      	cbz	r2, 800462e <USBD_MIDI_ReceivePacket+0x2a>
 800460a:	f8d2 2204 	ldr.w	r2, [r2, #516]	; 0x204
{      
 800460e:	b510      	push	{r4, lr}
  {
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8004610:	7c04      	ldrb	r4, [r0, #16]
 8004612:	b12c      	cbz	r4, 8004620 <USBD_MIDI_ReceivePacket+0x1c>
                             MIDI_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8004614:	2340      	movs	r3, #64	; 0x40
 8004616:	2101      	movs	r1, #1
 8004618:	f004 fb48 	bl	8008cac <USBD_LL_PrepareReceive>
                             MIDI_OUT_EP,
                             hmidi->RxBuffer,
                             MIDI_DATA_FS_OUT_PACKET_SIZE);
    }
    return USBD_OK;
 800461c:	2000      	movs	r0, #0
  }
  else
  {
    return USBD_FAIL;
  }
}
 800461e:	bd10      	pop	{r4, pc}
      USBD_LL_PrepareReceive(pdev,
 8004620:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004624:	2101      	movs	r1, #1
 8004626:	f004 fb41 	bl	8008cac <USBD_LL_PrepareReceive>
    return USBD_OK;
 800462a:	4620      	mov	r0, r4
}
 800462c:	bd10      	pop	{r4, pc}
    return USBD_FAIL;
 800462e:	2002      	movs	r0, #2
}
 8004630:	4770      	bx	lr
 8004632:	bf00      	nop

08004634 <USBD_Init>:
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 8004634:	b188      	cbz	r0, 800465a <USBD_Init+0x26>
{
 8004636:	b508      	push	{r3, lr}
#endif
    return USBD_FAIL;
  }

  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 8004638:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 800463c:	b113      	cbz	r3, 8004644 <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 800463e:	2300      	movs	r3, #0
 8004640:	f8c0 328c 	str.w	r3, [r0, #652]	; 0x28c
  }

  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8004644:	b109      	cbz	r1, 800464a <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 8004646:	f8c0 1288 	str.w	r1, [r0, #648]	; 0x288
  }

  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 800464a:	2101      	movs	r1, #1
  pdev->id = id;
 800464c:	7002      	strb	r2, [r0, #0]
  pdev->dev_state  = USBD_STATE_DEFAULT;
 800464e:	f880 1274 	strb.w	r1, [r0, #628]	; 0x274
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8004652:	f004 fa7f 	bl	8008b54 <USBD_LL_Init>

  return USBD_OK;
 8004656:	2000      	movs	r0, #0
}
 8004658:	bd08      	pop	{r3, pc}
    return USBD_FAIL;
 800465a:	2002      	movs	r0, #2
}
 800465c:	4770      	bx	lr
 800465e:	bf00      	nop

08004660 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 8004660:	b119      	cbz	r1, 800466a <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8004662:	f8c0 128c 	str.w	r1, [r0, #652]	; 0x28c
    status = USBD_OK;
 8004666:	2000      	movs	r0, #0
 8004668:	4770      	bx	lr
  else
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    status = USBD_FAIL;
 800466a:	2002      	movs	r0, #2
  }

  return status;
}
 800466c:	4770      	bx	lr
 800466e:	bf00      	nop

08004670 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8004670:	b508      	push	{r3, lr}

  /* Start the low level driver  */
  USBD_LL_Start(pdev);
 8004672:	f004 faa1 	bl	8008bb8 <USBD_LL_Start>

  return USBD_OK;
}
 8004676:	2000      	movs	r0, #0
 8004678:	bd08      	pop	{r3, pc}
 800467a:	bf00      	nop

0800467c <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 800467c:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;

  if(pdev->pClass != NULL)
 800467e:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8004682:	b11b      	cbz	r3, 800468c <USBD_SetClassConfig+0x10>
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0U)
 8004684:	681b      	ldr	r3, [r3, #0]
 8004686:	4798      	blx	r3
 8004688:	b900      	cbnz	r0, 800468c <USBD_SetClassConfig+0x10>
      ret = USBD_OK;
    }
  }

  return ret;
}
 800468a:	bd08      	pop	{r3, pc}
  USBD_StatusTypeDef   ret = USBD_FAIL;
 800468c:	2002      	movs	r0, #2
}
 800468e:	bd08      	pop	{r3, pc}

08004690 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8004690:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);
 8004692:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8004696:	685b      	ldr	r3, [r3, #4]
 8004698:	4798      	blx	r3
  return USBD_OK;
}
 800469a:	2000      	movs	r0, #0
 800469c:	bd08      	pop	{r3, pc}
 800469e:	bf00      	nop

080046a0 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80046a0:	b538      	push	{r3, r4, r5, lr}
  USBD_ParseSetupRequest(&pdev->request, psetup);
 80046a2:	f500 7520 	add.w	r5, r0, #640	; 0x280
{
 80046a6:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
 80046a8:	4628      	mov	r0, r5
 80046aa:	f000 fb7f 	bl	8004dac <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;

  pdev->ep0_data_len = pdev->request.wLength;

  switch (pdev->request.bmRequest & 0x1FU)
 80046ae:	f894 1280 	ldrb.w	r1, [r4, #640]	; 0x280
  pdev->ep0_state = USBD_EP0_SETUP;
 80046b2:	2001      	movs	r0, #1
  pdev->ep0_data_len = pdev->request.wLength;
 80046b4:	f8b4 2286 	ldrh.w	r2, [r4, #646]	; 0x286
  switch (pdev->request.bmRequest & 0x1FU)
 80046b8:	f001 031f 	and.w	r3, r1, #31
  pdev->ep0_state = USBD_EP0_SETUP;
 80046bc:	f8c4 026c 	str.w	r0, [r4, #620]	; 0x26c
  switch (pdev->request.bmRequest & 0x1FU)
 80046c0:	4283      	cmp	r3, r0
  pdev->ep0_data_len = pdev->request.wLength;
 80046c2:	f8c4 2270 	str.w	r2, [r4, #624]	; 0x270
  switch (pdev->request.bmRequest & 0x1FU)
 80046c6:	d015      	beq.n	80046f4 <USBD_LL_SetupStage+0x54>
 80046c8:	d30e      	bcc.n	80046e8 <USBD_LL_SetupStage+0x48>
 80046ca:	2b02      	cmp	r3, #2
 80046cc:	d006      	beq.n	80046dc <USBD_LL_SetupStage+0x3c>
  case USB_REQ_RECIPIENT_ENDPOINT:
    USBD_StdEPReq(pdev, &pdev->request);
    break;

  default:
    USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 80046ce:	f001 0180 	and.w	r1, r1, #128	; 0x80
 80046d2:	4620      	mov	r0, r4
 80046d4:	f004 fa9e 	bl	8008c14 <USBD_LL_StallEP>
    break;
  }

  return USBD_OK;
}
 80046d8:	2000      	movs	r0, #0
 80046da:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdEPReq(pdev, &pdev->request);
 80046dc:	4629      	mov	r1, r5
 80046de:	4620      	mov	r0, r4
 80046e0:	f000 facc 	bl	8004c7c <USBD_StdEPReq>
}
 80046e4:	2000      	movs	r0, #0
 80046e6:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdDevReq (pdev, &pdev->request);
 80046e8:	4629      	mov	r1, r5
 80046ea:	4620      	mov	r0, r4
 80046ec:	f000 f900 	bl	80048f0 <USBD_StdDevReq>
}
 80046f0:	2000      	movs	r0, #0
 80046f2:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 80046f4:	4629      	mov	r1, r5
 80046f6:	4620      	mov	r0, r4
 80046f8:	f000 fa94 	bl	8004c24 <USBD_StdItfReq>
}
 80046fc:	2000      	movs	r0, #0
 80046fe:	bd38      	pop	{r3, r4, r5, pc}

08004700 <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 8004700:	b570      	push	{r4, r5, r6, lr}
 8004702:	4605      	mov	r5, r0
  USBD_EndpointTypeDef    *pep;

  if(epnum == 0U)
 8004704:	b941      	cbnz	r1, 8004718 <USBD_LL_DataOutStage+0x18>
  {
    pep = &pdev->ep_out[0];

    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8004706:	f8d0 326c 	ldr.w	r3, [r0, #620]	; 0x26c
 800470a:	2b03      	cmp	r3, #3
 800470c:	d00f      	beq.n	800472e <USBD_LL_DataOutStage+0x2e>
        USBD_CtlSendStatus(pdev);
      }
    }
    else
    {
      if (pdev->ep0_state == USBD_EP0_STATUS_OUT)
 800470e:	2b05      	cmp	r3, #5
 8004710:	460c      	mov	r4, r1
 8004712:	d02e      	beq.n	8004772 <USBD_LL_DataOutStage+0x72>
  {
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
 8004714:	2000      	movs	r0, #0
}
 8004716:	bd70      	pop	{r4, r5, r6, pc}
  else if((pdev->pClass->DataOut != NULL) &&
 8004718:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 800471c:	699b      	ldr	r3, [r3, #24]
 800471e:	b1c3      	cbz	r3, 8004752 <USBD_LL_DataOutStage+0x52>
 8004720:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8004724:	2a03      	cmp	r2, #3
 8004726:	d114      	bne.n	8004752 <USBD_LL_DataOutStage+0x52>
    pdev->pClass->DataOut(pdev, epnum);
 8004728:	4798      	blx	r3
  return USBD_OK;
 800472a:	2000      	movs	r0, #0
}
 800472c:	bd70      	pop	{r4, r5, r6, pc}
 800472e:	4616      	mov	r6, r2
      if(pep->rem_length > pep->maxpacket)
 8004730:	f8d0 314c 	ldr.w	r3, [r0, #332]	; 0x14c
 8004734:	f8d0 2150 	ldr.w	r2, [r0, #336]	; 0x150
 8004738:	4293      	cmp	r3, r2
 800473a:	d90c      	bls.n	8004756 <USBD_LL_DataOutStage+0x56>
        pep->rem_length -=  pep->maxpacket;
 800473c:	1a9b      	subs	r3, r3, r2
        USBD_CtlContinueRx (pdev,
 800473e:	4631      	mov	r1, r6
 8004740:	429a      	cmp	r2, r3
        pep->rem_length -=  pep->maxpacket;
 8004742:	f8c0 314c 	str.w	r3, [r0, #332]	; 0x14c
        USBD_CtlContinueRx (pdev,
 8004746:	bf8c      	ite	hi
 8004748:	b29a      	uxthhi	r2, r3
 800474a:	b292      	uxthls	r2, r2
 800474c:	f000 fb8e 	bl	8004e6c <USBD_CtlContinueRx>
 8004750:	e7e0      	b.n	8004714 <USBD_LL_DataOutStage+0x14>
    return USBD_FAIL;
 8004752:	2002      	movs	r0, #2
}
 8004754:	bd70      	pop	{r4, r5, r6, pc}
        if((pdev->pClass->EP0_RxReady != NULL)&&
 8004756:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 800475a:	691b      	ldr	r3, [r3, #16]
 800475c:	b123      	cbz	r3, 8004768 <USBD_LL_DataOutStage+0x68>
 800475e:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 8004762:	2a03      	cmp	r2, #3
 8004764:	d100      	bne.n	8004768 <USBD_LL_DataOutStage+0x68>
          pdev->pClass->EP0_RxReady(pdev);
 8004766:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8004768:	4628      	mov	r0, r5
 800476a:	f000 fb87 	bl	8004e7c <USBD_CtlSendStatus>
  return USBD_OK;
 800476e:	2000      	movs	r0, #0
}
 8004770:	bd70      	pop	{r4, r5, r6, pc}
        pdev->ep0_state = USBD_EP0_IDLE;
 8004772:	f8c5 126c 	str.w	r1, [r5, #620]	; 0x26c
        USBD_LL_StallEP(pdev, 0U);
 8004776:	f004 fa4d 	bl	8008c14 <USBD_LL_StallEP>
  return USBD_OK;
 800477a:	4620      	mov	r0, r4
}
 800477c:	bd70      	pop	{r4, r5, r6, pc}
 800477e:	bf00      	nop

08004780 <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev, uint8_t epnum,
                                       uint8_t *pdata)
{
 8004780:	b570      	push	{r4, r5, r6, lr}
 8004782:	4604      	mov	r4, r0
  USBD_EndpointTypeDef *pep;

  if(epnum == 0U)
 8004784:	b961      	cbnz	r1, 80047a0 <USBD_LL_DataInStage+0x20>
  {
    pep = &pdev->ep_in[0];

    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8004786:	f8d0 526c 	ldr.w	r5, [r0, #620]	; 0x26c
 800478a:	2d02      	cmp	r5, #2
 800478c:	d016      	beq.n	80047bc <USBD_LL_DataInStage+0x3c>
        }
      }
    }
    else
    {
      if ((pdev->ep0_state == USBD_EP0_STATUS_IN) ||
 800478e:	f035 0304 	bics.w	r3, r5, #4
 8004792:	d034      	beq.n	80047fe <USBD_LL_DataInStage+0x7e>
      {
        USBD_LL_StallEP(pdev, 0x80U);
      }
    }

    if (pdev->dev_test_mode == 1U)
 8004794:	f894 3278 	ldrb.w	r3, [r4, #632]	; 0x278
    {
      USBD_RunTestMode(pdev);
      pdev->dev_test_mode = 0U;
 8004798:	2000      	movs	r0, #0
    if (pdev->dev_test_mode == 1U)
 800479a:	2b01      	cmp	r3, #1
 800479c:	d00b      	beq.n	80047b6 <USBD_LL_DataInStage+0x36>
    /* should never be in this condition */
    return USBD_FAIL;
  }

  return USBD_OK;
}
 800479e:	bd70      	pop	{r4, r5, r6, pc}
  else if((pdev->pClass->DataIn != NULL) &&
 80047a0:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 80047a4:	695b      	ldr	r3, [r3, #20]
 80047a6:	b343      	cbz	r3, 80047fa <USBD_LL_DataInStage+0x7a>
 80047a8:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 80047ac:	2a03      	cmp	r2, #3
 80047ae:	d124      	bne.n	80047fa <USBD_LL_DataInStage+0x7a>
    pdev->pClass->DataIn(pdev, epnum);
 80047b0:	4798      	blx	r3
  return USBD_OK;
 80047b2:	2000      	movs	r0, #0
}
 80047b4:	bd70      	pop	{r4, r5, r6, pc}
      pdev->dev_test_mode = 0U;
 80047b6:	f884 0278 	strb.w	r0, [r4, #632]	; 0x278
}
 80047ba:	bd70      	pop	{r4, r5, r6, pc}
      if(pep->rem_length > pep->maxpacket)
 80047bc:	e9d0 5308 	ldrd	r5, r3, [r0, #32]
 80047c0:	460e      	mov	r6, r1
 80047c2:	429d      	cmp	r5, r3
 80047c4:	d81f      	bhi.n	8004806 <USBD_LL_DataInStage+0x86>
        if((pep->total_length % pep->maxpacket == 0U) &&
 80047c6:	69c5      	ldr	r5, [r0, #28]
 80047c8:	fbb5 f2f3 	udiv	r2, r5, r3
 80047cc:	fb03 5212 	mls	r2, r3, r2, r5
 80047d0:	b90a      	cbnz	r2, 80047d6 <USBD_LL_DataInStage+0x56>
 80047d2:	42ab      	cmp	r3, r5
 80047d4:	d924      	bls.n	8004820 <USBD_LL_DataInStage+0xa0>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 80047d6:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 80047da:	68db      	ldr	r3, [r3, #12]
 80047dc:	b12b      	cbz	r3, 80047ea <USBD_LL_DataInStage+0x6a>
 80047de:	f894 2274 	ldrb.w	r2, [r4, #628]	; 0x274
 80047e2:	2a03      	cmp	r2, #3
 80047e4:	d101      	bne.n	80047ea <USBD_LL_DataInStage+0x6a>
            pdev->pClass->EP0_TxSent(pdev);
 80047e6:	4620      	mov	r0, r4
 80047e8:	4798      	blx	r3
          USBD_LL_StallEP(pdev, 0x80U);
 80047ea:	2180      	movs	r1, #128	; 0x80
 80047ec:	4620      	mov	r0, r4
 80047ee:	f004 fa11 	bl	8008c14 <USBD_LL_StallEP>
          USBD_CtlReceiveStatus(pdev);
 80047f2:	4620      	mov	r0, r4
 80047f4:	f000 fb4e 	bl	8004e94 <USBD_CtlReceiveStatus>
 80047f8:	e7cc      	b.n	8004794 <USBD_LL_DataInStage+0x14>
    return USBD_FAIL;
 80047fa:	2002      	movs	r0, #2
}
 80047fc:	bd70      	pop	{r4, r5, r6, pc}
        USBD_LL_StallEP(pdev, 0x80U);
 80047fe:	2180      	movs	r1, #128	; 0x80
 8004800:	f004 fa08 	bl	8008c14 <USBD_LL_StallEP>
 8004804:	e7c6      	b.n	8004794 <USBD_LL_DataInStage+0x14>
        pep->rem_length -= pep->maxpacket;
 8004806:	1aeb      	subs	r3, r5, r3
        USBD_CtlContinueSendData (pdev, pdata, (uint16_t)pep->rem_length);
 8004808:	4611      	mov	r1, r2
        pep->rem_length -= pep->maxpacket;
 800480a:	6203      	str	r3, [r0, #32]
        USBD_CtlContinueSendData (pdev, pdata, (uint16_t)pep->rem_length);
 800480c:	b29a      	uxth	r2, r3
 800480e:	f000 fb15 	bl	8004e3c <USBD_CtlContinueSendData>
          USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8004812:	4633      	mov	r3, r6
 8004814:	4632      	mov	r2, r6
 8004816:	4631      	mov	r1, r6
 8004818:	4620      	mov	r0, r4
 800481a:	f004 fa47 	bl	8008cac <USBD_LL_PrepareReceive>
 800481e:	e7b9      	b.n	8004794 <USBD_LL_DataInStage+0x14>
           (pep->total_length >= pep->maxpacket) &&
 8004820:	f8d0 3270 	ldr.w	r3, [r0, #624]	; 0x270
 8004824:	429d      	cmp	r5, r3
 8004826:	d2d6      	bcs.n	80047d6 <USBD_LL_DataInStage+0x56>
          USBD_CtlContinueSendData(pdev, NULL, 0U);
 8004828:	460a      	mov	r2, r1
 800482a:	f000 fb07 	bl	8004e3c <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 800482e:	f8c4 6270 	str.w	r6, [r4, #624]	; 0x270
 8004832:	e7ee      	b.n	8004812 <USBD_LL_DataInStage+0x92>

08004834 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 8004834:	b570      	push	{r4, r5, r6, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004836:	2200      	movs	r2, #0
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8004838:	2640      	movs	r6, #64	; 0x40
{
 800483a:	4604      	mov	r4, r0
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800483c:	2501      	movs	r5, #1
  USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 800483e:	4611      	mov	r1, r2
 8004840:	4633      	mov	r3, r6
 8004842:	f004 f9c7 	bl	8008bd4 <USBD_LL_OpenEP>

  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004846:	4633      	mov	r3, r6
 8004848:	2180      	movs	r1, #128	; 0x80
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 800484a:	f8c4 5144 	str.w	r5, [r4, #324]	; 0x144
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800484e:	f8c4 6150 	str.w	r6, [r4, #336]	; 0x150
  USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 8004852:	4620      	mov	r0, r4
 8004854:	2200      	movs	r2, #0
 8004856:	f004 f9bd 	bl	8008bd4 <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->ep0_state = USBD_EP0_IDLE;
 800485a:	2100      	movs	r1, #0
  pdev->dev_config= 0U;
  pdev->dev_remote_wakeup = 0U;

  if (pdev->pClassData)
 800485c:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8004860:	61a5      	str	r5, [r4, #24]
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8004862:	6266      	str	r6, [r4, #36]	; 0x24
  pdev->dev_state = USBD_STATE_DEFAULT;
 8004864:	f884 5274 	strb.w	r5, [r4, #628]	; 0x274
  pdev->ep0_state = USBD_EP0_IDLE;
 8004868:	f8c4 126c 	str.w	r1, [r4, #620]	; 0x26c
  pdev->dev_config= 0U;
 800486c:	6061      	str	r1, [r4, #4]
  pdev->dev_remote_wakeup = 0U;
 800486e:	f8c4 127c 	str.w	r1, [r4, #636]	; 0x27c
  if (pdev->pClassData)
 8004872:	b123      	cbz	r3, 800487e <USBD_LL_Reset+0x4a>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 8004874:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 8004878:	4620      	mov	r0, r4
 800487a:	685b      	ldr	r3, [r3, #4]
 800487c:	4798      	blx	r3
  }

  return USBD_OK;
}
 800487e:	2000      	movs	r0, #0
 8004880:	bd70      	pop	{r4, r5, r6, pc}
 8004882:	bf00      	nop

08004884 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8004884:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8004886:	2000      	movs	r0, #0
 8004888:	4770      	bx	lr
 800488a:	bf00      	nop

0800488c <USBD_LL_Suspend>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
 800488c:	4603      	mov	r3, r0
  pdev->dev_old_state =  pdev->dev_state;
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 800488e:	2104      	movs	r1, #4
  return USBD_OK;
}
 8004890:	2000      	movs	r0, #0
  pdev->dev_old_state =  pdev->dev_state;
 8004892:	f893 2274 	ldrb.w	r2, [r3, #628]	; 0x274
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8004896:	f883 1274 	strb.w	r1, [r3, #628]	; 0x274
  pdev->dev_old_state =  pdev->dev_state;
 800489a:	f883 2275 	strb.w	r2, [r3, #629]	; 0x275
}
 800489e:	4770      	bx	lr

080048a0 <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
 80048a0:	4603      	mov	r3, r0
  pdev->dev_state = pdev->dev_old_state;
  return USBD_OK;
}
 80048a2:	2000      	movs	r0, #0
  pdev->dev_state = pdev->dev_old_state;
 80048a4:	f893 2275 	ldrb.w	r2, [r3, #629]	; 0x275
 80048a8:	f883 2274 	strb.w	r2, [r3, #628]	; 0x274
}
 80048ac:	4770      	bx	lr
 80048ae:	bf00      	nop

080048b0 <USBD_LL_SOF>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 80048b0:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 80048b4:	2a03      	cmp	r2, #3
 80048b6:	d001      	beq.n	80048bc <USBD_LL_SOF+0xc>
    {
      pdev->pClass->SOF(pdev);
    }
  }
  return USBD_OK;
}
 80048b8:	2000      	movs	r0, #0
 80048ba:	4770      	bx	lr
{
 80048bc:	b508      	push	{r3, lr}
    if(pdev->pClass->SOF != NULL)
 80048be:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 80048c2:	69db      	ldr	r3, [r3, #28]
 80048c4:	b103      	cbz	r3, 80048c8 <USBD_LL_SOF+0x18>
      pdev->pClass->SOF(pdev);
 80048c6:	4798      	blx	r3
}
 80048c8:	2000      	movs	r0, #0
 80048ca:	bd08      	pop	{r3, pc}

080048cc <USBD_LL_IsoINIncomplete>:
  /* Prevent unused arguments compilation warning */
  UNUSED(pdev);
  UNUSED(epnum);

  return USBD_OK;
}
 80048cc:	2000      	movs	r0, #0
 80048ce:	4770      	bx	lr

080048d0 <USBD_LL_IsoOUTIncomplete>:
 80048d0:	2000      	movs	r0, #0
 80048d2:	4770      	bx	lr

080048d4 <USBD_LL_DevConnected>:
 80048d4:	2000      	movs	r0, #0
 80048d6:	4770      	bx	lr

080048d8 <USBD_LL_DevDisconnected>:
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 80048d8:	f8d0 228c 	ldr.w	r2, [r0, #652]	; 0x28c
  pdev->dev_state = USBD_STATE_DEFAULT;
 80048dc:	2101      	movs	r1, #1
{
 80048de:	b508      	push	{r3, lr}
  pdev->dev_state = USBD_STATE_DEFAULT;
 80048e0:	f880 1274 	strb.w	r1, [r0, #628]	; 0x274
  pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 80048e4:	7901      	ldrb	r1, [r0, #4]
 80048e6:	6853      	ldr	r3, [r2, #4]
 80048e8:	4798      	blx	r3

  return USBD_OK;
}
 80048ea:	2000      	movs	r0, #0
 80048ec:	bd08      	pop	{r3, pc}
 80048ee:	bf00      	nop

080048f0 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80048f0:	b530      	push	{r4, r5, lr}
  USBD_StatusTypeDef ret = USBD_OK;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80048f2:	780b      	ldrb	r3, [r1, #0]
{
 80048f4:	b083      	sub	sp, #12
 80048f6:	460d      	mov	r5, r1
 80048f8:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80048fa:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80048fe:	2b20      	cmp	r3, #32
 8004900:	d028      	beq.n	8004954 <USBD_StdDevReq+0x64>
 8004902:	2b40      	cmp	r3, #64	; 0x40
 8004904:	d026      	beq.n	8004954 <USBD_StdDevReq+0x64>
 8004906:	b153      	cbz	r3, 800491e <USBD_StdDevReq+0x2e>
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80U);
 8004908:	2180      	movs	r1, #128	; 0x80
 800490a:	4620      	mov	r0, r4
 800490c:	f004 f982 	bl	8008c14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 8004910:	4620      	mov	r0, r4
 8004912:	2100      	movs	r1, #0
 8004914:	f004 f97e 	bl	8008c14 <USBD_LL_StallEP>
}
 8004918:	2000      	movs	r0, #0
 800491a:	b003      	add	sp, #12
 800491c:	bd30      	pop	{r4, r5, pc}
    switch (req->bRequest)
 800491e:	784b      	ldrb	r3, [r1, #1]
 8004920:	2b09      	cmp	r3, #9
 8004922:	d8f1      	bhi.n	8004908 <USBD_StdDevReq+0x18>
 8004924:	a201      	add	r2, pc, #4	; (adr r2, 800492c <USBD_StdDevReq+0x3c>)
 8004926:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800492a:	bf00      	nop
 800492c:	080049a9 	.word	0x080049a9
 8004930:	080049d5 	.word	0x080049d5
 8004934:	08004909 	.word	0x08004909
 8004938:	080049f1 	.word	0x080049f1
 800493c:	08004909 	.word	0x08004909
 8004940:	080049fd 	.word	0x080049fd
 8004944:	08004a3b 	.word	0x08004a3b
 8004948:	08004909 	.word	0x08004909
 800494c:	08004a89 	.word	0x08004a89
 8004950:	08004967 	.word	0x08004967
    pdev->pClass->Setup(pdev, req);
 8004954:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 8004958:	4629      	mov	r1, r5
 800495a:	4620      	mov	r0, r4
 800495c:	689b      	ldr	r3, [r3, #8]
 800495e:	4798      	blx	r3
}
 8004960:	2000      	movs	r0, #0
 8004962:	b003      	add	sp, #12
 8004964:	bd30      	pop	{r4, r5, pc}
  cfgidx = (uint8_t)(req->wValue);
 8004966:	7889      	ldrb	r1, [r1, #2]
 8004968:	4dad      	ldr	r5, [pc, #692]	; (8004c20 <USBD_StdDevReq+0x330>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 800496a:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);
 800496c:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 800496e:	d8cb      	bhi.n	8004908 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 8004970:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8004974:	2b02      	cmp	r3, #2
 8004976:	f000 8128 	beq.w	8004bca <USBD_StdDevReq+0x2da>
 800497a:	2b03      	cmp	r3, #3
 800497c:	f040 8119 	bne.w	8004bb2 <USBD_StdDevReq+0x2c2>
      if (cfgidx == 0U)
 8004980:	2900      	cmp	r1, #0
 8004982:	f000 813e 	beq.w	8004c02 <USBD_StdDevReq+0x312>
      else if (cfgidx != pdev->dev_config)
 8004986:	6841      	ldr	r1, [r0, #4]
 8004988:	2901      	cmp	r1, #1
 800498a:	d009      	beq.n	80049a0 <USBD_StdDevReq+0xb0>
        USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 800498c:	b2c9      	uxtb	r1, r1
 800498e:	f7ff fe7f 	bl	8004690 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8004992:	7829      	ldrb	r1, [r5, #0]
        if(USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8004994:	4620      	mov	r0, r4
        pdev->dev_config = cfgidx;
 8004996:	6061      	str	r1, [r4, #4]
        if(USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8004998:	f7ff fe70 	bl	800467c <USBD_SetClassConfig>
 800499c:	2802      	cmp	r0, #2
 800499e:	d0b3      	beq.n	8004908 <USBD_StdDevReq+0x18>
    USBD_CtlSendStatus(pdev);
 80049a0:	4620      	mov	r0, r4
 80049a2:	f000 fa6b 	bl	8004e7c <USBD_CtlSendStatus>
 80049a6:	e7b7      	b.n	8004918 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 80049a8:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 80049ac:	2203      	movs	r2, #3
 80049ae:	3b01      	subs	r3, #1
 80049b0:	2b02      	cmp	r3, #2
 80049b2:	d8a9      	bhi.n	8004908 <USBD_StdDevReq+0x18>
    if(req->wLength != 0x2U)
 80049b4:	88cb      	ldrh	r3, [r1, #6]
 80049b6:	2b02      	cmp	r3, #2
 80049b8:	d1a6      	bne.n	8004908 <USBD_StdDevReq+0x18>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80049ba:	2101      	movs	r1, #1
    if (pdev->dev_remote_wakeup)
 80049bc:	f8d0 327c 	ldr.w	r3, [r0, #636]	; 0x27c
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80049c0:	60c1      	str	r1, [r0, #12]
    if (pdev->dev_remote_wakeup)
 80049c2:	b103      	cbz	r3, 80049c6 <USBD_StdDevReq+0xd6>
      pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 80049c4:	60c2      	str	r2, [r0, #12]
    USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config_status, 2U);
 80049c6:	2202      	movs	r2, #2
 80049c8:	f104 010c 	add.w	r1, r4, #12
 80049cc:	4620      	mov	r0, r4
 80049ce:	f000 fa27 	bl	8004e20 <USBD_CtlSendData>
 80049d2:	e7a1      	b.n	8004918 <USBD_StdDevReq+0x28>
  switch (pdev->dev_state)
 80049d4:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 80049d8:	3b01      	subs	r3, #1
 80049da:	2b02      	cmp	r3, #2
 80049dc:	d894      	bhi.n	8004908 <USBD_StdDevReq+0x18>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80049de:	884b      	ldrh	r3, [r1, #2]
 80049e0:	2b01      	cmp	r3, #1
 80049e2:	d199      	bne.n	8004918 <USBD_StdDevReq+0x28>
      pdev->dev_remote_wakeup = 0U;
 80049e4:	2300      	movs	r3, #0
 80049e6:	f8c0 327c 	str.w	r3, [r0, #636]	; 0x27c
      USBD_CtlSendStatus(pdev);
 80049ea:	f000 fa47 	bl	8004e7c <USBD_CtlSendStatus>
 80049ee:	e793      	b.n	8004918 <USBD_StdDevReq+0x28>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 80049f0:	884b      	ldrh	r3, [r1, #2]
 80049f2:	2b01      	cmp	r3, #1
 80049f4:	d190      	bne.n	8004918 <USBD_StdDevReq+0x28>
    pdev->dev_remote_wakeup = 1U;
 80049f6:	f8c0 327c 	str.w	r3, [r0, #636]	; 0x27c
 80049fa:	e7d1      	b.n	80049a0 <USBD_StdDevReq+0xb0>
  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 80049fc:	888b      	ldrh	r3, [r1, #4]
 80049fe:	2b00      	cmp	r3, #0
 8004a00:	d182      	bne.n	8004908 <USBD_StdDevReq+0x18>
 8004a02:	88cb      	ldrh	r3, [r1, #6]
 8004a04:	2b00      	cmp	r3, #0
 8004a06:	f47f af7f 	bne.w	8004908 <USBD_StdDevReq+0x18>
 8004a0a:	884d      	ldrh	r5, [r1, #2]
 8004a0c:	2d7f      	cmp	r5, #127	; 0x7f
 8004a0e:	f63f af7b 	bhi.w	8004908 <USBD_StdDevReq+0x18>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8004a12:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8004a16:	2b03      	cmp	r3, #3
 8004a18:	f43f af76 	beq.w	8004908 <USBD_StdDevReq+0x18>
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8004a1c:	b2e9      	uxtb	r1, r5
      pdev->dev_address = dev_addr;
 8004a1e:	f880 1276 	strb.w	r1, [r0, #630]	; 0x276
      USBD_LL_SetUSBAddress(pdev, dev_addr);
 8004a22:	f004 f927 	bl	8008c74 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);
 8004a26:	4620      	mov	r0, r4
 8004a28:	f000 fa28 	bl	8004e7c <USBD_CtlSendStatus>
      if (dev_addr != 0U)
 8004a2c:	2d00      	cmp	r5, #0
 8004a2e:	f000 80f2 	beq.w	8004c16 <USBD_StdDevReq+0x326>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8004a32:	2302      	movs	r3, #2
 8004a34:	f884 3274 	strb.w	r3, [r4, #628]	; 0x274
 8004a38:	e76e      	b.n	8004918 <USBD_StdDevReq+0x28>
      USBD_GetDescriptor (pdev, req);
 8004a3a:	884a      	ldrh	r2, [r1, #2]
  switch (req->wValue >> 8)
 8004a3c:	0a13      	lsrs	r3, r2, #8
 8004a3e:	3b01      	subs	r3, #1
 8004a40:	2b0e      	cmp	r3, #14
 8004a42:	f63f af61 	bhi.w	8004908 <USBD_StdDevReq+0x18>
 8004a46:	a101      	add	r1, pc, #4	; (adr r1, 8004a4c <USBD_StdDevReq+0x15c>)
 8004a48:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8004a4c:	08004b31 	.word	0x08004b31
 8004a50:	08004b19 	.word	0x08004b19
 8004a54:	08004b41 	.word	0x08004b41
 8004a58:	08004909 	.word	0x08004909
 8004a5c:	08004909 	.word	0x08004909
 8004a60:	08004ae9 	.word	0x08004ae9
 8004a64:	08004aff 	.word	0x08004aff
 8004a68:	08004909 	.word	0x08004909
 8004a6c:	08004909 	.word	0x08004909
 8004a70:	08004909 	.word	0x08004909
 8004a74:	08004909 	.word	0x08004909
 8004a78:	08004909 	.word	0x08004909
 8004a7c:	08004909 	.word	0x08004909
 8004a80:	08004909 	.word	0x08004909
 8004a84:	08004aaf 	.word	0x08004aaf
  if (req->wLength != 1U)
 8004a88:	88ca      	ldrh	r2, [r1, #6]
 8004a8a:	2a01      	cmp	r2, #1
 8004a8c:	f47f af3c 	bne.w	8004908 <USBD_StdDevReq+0x18>
    switch (pdev->dev_state)
 8004a90:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8004a94:	2b00      	cmp	r3, #0
 8004a96:	f43f af37 	beq.w	8004908 <USBD_StdDevReq+0x18>
 8004a9a:	2b02      	cmp	r3, #2
 8004a9c:	f240 80a3 	bls.w	8004be6 <USBD_StdDevReq+0x2f6>
 8004aa0:	2b03      	cmp	r3, #3
 8004aa2:	f47f af31 	bne.w	8004908 <USBD_StdDevReq+0x18>
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_config, 1U);
 8004aa6:	1d01      	adds	r1, r0, #4
 8004aa8:	f000 f9ba 	bl	8004e20 <USBD_CtlSendData>
 8004aac:	e734      	b.n	8004918 <USBD_StdDevReq+0x28>
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
 8004aae:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8004ab2:	f10d 0106 	add.w	r1, sp, #6
 8004ab6:	7c00      	ldrb	r0, [r0, #16]
 8004ab8:	69db      	ldr	r3, [r3, #28]
 8004aba:	4798      	blx	r3
  if((len != 0U) && (req->wLength != 0U))
 8004abc:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8004ac0:	88ea      	ldrh	r2, [r5, #6]
 8004ac2:	b16b      	cbz	r3, 8004ae0 <USBD_StdDevReq+0x1f0>
 8004ac4:	2a00      	cmp	r2, #0
 8004ac6:	f43f af6b 	beq.w	80049a0 <USBD_StdDevReq+0xb0>
    len = MIN(len, req->wLength);
 8004aca:	4293      	cmp	r3, r2
    USBD_CtlSendData (pdev, pbuf, len);
 8004acc:	4601      	mov	r1, r0
 8004ace:	4620      	mov	r0, r4
    len = MIN(len, req->wLength);
 8004ad0:	bf28      	it	cs
 8004ad2:	4613      	movcs	r3, r2
    USBD_CtlSendData (pdev, pbuf, len);
 8004ad4:	461a      	mov	r2, r3
    len = MIN(len, req->wLength);
 8004ad6:	f8ad 3006 	strh.w	r3, [sp, #6]
    USBD_CtlSendData (pdev, pbuf, len);
 8004ada:	f000 f9a1 	bl	8004e20 <USBD_CtlSendData>
 8004ade:	88ea      	ldrh	r2, [r5, #6]
  if(req->wLength == 0U)
 8004ae0:	2a00      	cmp	r2, #0
 8004ae2:	f47f af19 	bne.w	8004918 <USBD_StdDevReq+0x28>
 8004ae6:	e75b      	b.n	80049a0 <USBD_StdDevReq+0xb0>
    if(pdev->dev_speed == USBD_SPEED_HIGH)
 8004ae8:	7c03      	ldrb	r3, [r0, #16]
 8004aea:	2b00      	cmp	r3, #0
 8004aec:	f47f af0c 	bne.w	8004908 <USBD_StdDevReq+0x18>
      pbuf = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8004af0:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8004af4:	f10d 0006 	add.w	r0, sp, #6
 8004af8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004afa:	4798      	blx	r3
 8004afc:	e7de      	b.n	8004abc <USBD_StdDevReq+0x1cc>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )
 8004afe:	7c03      	ldrb	r3, [r0, #16]
 8004b00:	2b00      	cmp	r3, #0
 8004b02:	f47f af01 	bne.w	8004908 <USBD_StdDevReq+0x18>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8004b06:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8004b0a:	f10d 0006 	add.w	r0, sp, #6
 8004b0e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004b10:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8004b12:	2307      	movs	r3, #7
 8004b14:	7043      	strb	r3, [r0, #1]
 8004b16:	e7d1      	b.n	8004abc <USBD_StdDevReq+0x1cc>
    if(pdev->dev_speed == USBD_SPEED_HIGH )
 8004b18:	7c02      	ldrb	r2, [r0, #16]
 8004b1a:	f8d0 328c 	ldr.w	r3, [r0, #652]	; 0x28c
 8004b1e:	2a00      	cmp	r2, #0
 8004b20:	d168      	bne.n	8004bf4 <USBD_StdDevReq+0x304>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 8004b22:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004b24:	f10d 0006 	add.w	r0, sp, #6
 8004b28:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8004b2a:	2302      	movs	r3, #2
 8004b2c:	7043      	strb	r3, [r0, #1]
 8004b2e:	e7c5      	b.n	8004abc <USBD_StdDevReq+0x1cc>
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8004b30:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8004b34:	f10d 0106 	add.w	r1, sp, #6
 8004b38:	7c00      	ldrb	r0, [r0, #16]
 8004b3a:	681b      	ldr	r3, [r3, #0]
 8004b3c:	4798      	blx	r3
 8004b3e:	e7bd      	b.n	8004abc <USBD_StdDevReq+0x1cc>
    switch ((uint8_t)(req->wValue))
 8004b40:	b2d2      	uxtb	r2, r2
 8004b42:	2a05      	cmp	r2, #5
 8004b44:	f63f aee0 	bhi.w	8004908 <USBD_StdDevReq+0x18>
 8004b48:	e8df f002 	tbb	[pc, r2]
 8004b4c:	131b232b 	.word	0x131b232b
 8004b50:	030b      	.short	0x030b
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8004b52:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8004b56:	f10d 0106 	add.w	r1, sp, #6
 8004b5a:	7c00      	ldrb	r0, [r0, #16]
 8004b5c:	699b      	ldr	r3, [r3, #24]
 8004b5e:	4798      	blx	r3
 8004b60:	e7ac      	b.n	8004abc <USBD_StdDevReq+0x1cc>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8004b62:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8004b66:	f10d 0106 	add.w	r1, sp, #6
 8004b6a:	7c00      	ldrb	r0, [r0, #16]
 8004b6c:	695b      	ldr	r3, [r3, #20]
 8004b6e:	4798      	blx	r3
 8004b70:	e7a4      	b.n	8004abc <USBD_StdDevReq+0x1cc>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8004b72:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8004b76:	f10d 0106 	add.w	r1, sp, #6
 8004b7a:	7c00      	ldrb	r0, [r0, #16]
 8004b7c:	691b      	ldr	r3, [r3, #16]
 8004b7e:	4798      	blx	r3
 8004b80:	e79c      	b.n	8004abc <USBD_StdDevReq+0x1cc>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8004b82:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8004b86:	f10d 0106 	add.w	r1, sp, #6
 8004b8a:	7c00      	ldrb	r0, [r0, #16]
 8004b8c:	68db      	ldr	r3, [r3, #12]
 8004b8e:	4798      	blx	r3
 8004b90:	e794      	b.n	8004abc <USBD_StdDevReq+0x1cc>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8004b92:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8004b96:	f10d 0106 	add.w	r1, sp, #6
 8004b9a:	7c00      	ldrb	r0, [r0, #16]
 8004b9c:	689b      	ldr	r3, [r3, #8]
 8004b9e:	4798      	blx	r3
 8004ba0:	e78c      	b.n	8004abc <USBD_StdDevReq+0x1cc>
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8004ba2:	f8d0 3288 	ldr.w	r3, [r0, #648]	; 0x288
 8004ba6:	f10d 0106 	add.w	r1, sp, #6
 8004baa:	7c00      	ldrb	r0, [r0, #16]
 8004bac:	685b      	ldr	r3, [r3, #4]
 8004bae:	4798      	blx	r3
 8004bb0:	e784      	b.n	8004abc <USBD_StdDevReq+0x1cc>
  USBD_LL_StallEP(pdev , 0x80U);
 8004bb2:	2180      	movs	r1, #128	; 0x80
 8004bb4:	f004 f82e 	bl	8008c14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 8004bb8:	2100      	movs	r1, #0
 8004bba:	4620      	mov	r0, r4
 8004bbc:	f004 f82a 	bl	8008c14 <USBD_LL_StallEP>
      USBD_ClrClassConfig(pdev, cfgidx);
 8004bc0:	7829      	ldrb	r1, [r5, #0]
 8004bc2:	4620      	mov	r0, r4
 8004bc4:	f7ff fd64 	bl	8004690 <USBD_ClrClassConfig>
 8004bc8:	e6a6      	b.n	8004918 <USBD_StdDevReq+0x28>
      if (cfgidx)
 8004bca:	2900      	cmp	r1, #0
 8004bcc:	f43f aee8 	beq.w	80049a0 <USBD_StdDevReq+0xb0>
        pdev->dev_config = cfgidx;
 8004bd0:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8004bd2:	2303      	movs	r3, #3
        pdev->dev_config = cfgidx;
 8004bd4:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8004bd6:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
        if(USBD_SetClassConfig(pdev, cfgidx) == USBD_FAIL)
 8004bda:	f7ff fd4f 	bl	800467c <USBD_SetClassConfig>
 8004bde:	2802      	cmp	r0, #2
 8004be0:	f47f aede 	bne.w	80049a0 <USBD_StdDevReq+0xb0>
 8004be4:	e690      	b.n	8004908 <USBD_StdDevReq+0x18>
      pdev->dev_default_config = 0U;
 8004be6:	2300      	movs	r3, #0
 8004be8:	4601      	mov	r1, r0
 8004bea:	f841 3f08 	str.w	r3, [r1, #8]!
      USBD_CtlSendData (pdev, (uint8_t *)(void *)&pdev->dev_default_config, 1U);
 8004bee:	f000 f917 	bl	8004e20 <USBD_CtlSendData>
 8004bf2:	e691      	b.n	8004918 <USBD_StdDevReq+0x28>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8004bf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004bf6:	f10d 0006 	add.w	r0, sp, #6
 8004bfa:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8004bfc:	2302      	movs	r3, #2
 8004bfe:	7043      	strb	r3, [r0, #1]
 8004c00:	e75c      	b.n	8004abc <USBD_StdDevReq+0x1cc>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8004c02:	2302      	movs	r3, #2
        pdev->dev_config = cfgidx;
 8004c04:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8004c06:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
        USBD_ClrClassConfig(pdev, cfgidx);
 8004c0a:	f7ff fd41 	bl	8004690 <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
 8004c0e:	4620      	mov	r0, r4
 8004c10:	f000 f934 	bl	8004e7c <USBD_CtlSendStatus>
 8004c14:	e680      	b.n	8004918 <USBD_StdDevReq+0x28>
        pdev->dev_state = USBD_STATE_DEFAULT;
 8004c16:	2301      	movs	r3, #1
 8004c18:	f884 3274 	strb.w	r3, [r4, #628]	; 0x274
 8004c1c:	e67c      	b.n	8004918 <USBD_StdDevReq+0x28>
 8004c1e:	bf00      	nop
 8004c20:	20000279 	.word	0x20000279

08004c24 <USBD_StdItfReq>:
{
 8004c24:	b538      	push	{r3, r4, r5, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004c26:	780b      	ldrb	r3, [r1, #0]
{
 8004c28:	460d      	mov	r5, r1
 8004c2a:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004c2c:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8004c30:	2b20      	cmp	r3, #32
 8004c32:	d00c      	beq.n	8004c4e <USBD_StdItfReq+0x2a>
 8004c34:	2b40      	cmp	r3, #64	; 0x40
 8004c36:	d00a      	beq.n	8004c4e <USBD_StdItfReq+0x2a>
 8004c38:	b14b      	cbz	r3, 8004c4e <USBD_StdItfReq+0x2a>
  USBD_LL_StallEP(pdev , 0x80U);
 8004c3a:	2180      	movs	r1, #128	; 0x80
 8004c3c:	4620      	mov	r0, r4
 8004c3e:	f003 ffe9 	bl	8008c14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 8004c42:	4620      	mov	r0, r4
 8004c44:	2100      	movs	r1, #0
 8004c46:	f003 ffe5 	bl	8008c14 <USBD_LL_StallEP>
}
 8004c4a:	2000      	movs	r0, #0
 8004c4c:	bd38      	pop	{r3, r4, r5, pc}
    switch (pdev->dev_state)
 8004c4e:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 8004c52:	3b01      	subs	r3, #1
 8004c54:	2b02      	cmp	r3, #2
 8004c56:	d8f0      	bhi.n	8004c3a <USBD_StdItfReq+0x16>
      if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8004c58:	792b      	ldrb	r3, [r5, #4]
 8004c5a:	2b01      	cmp	r3, #1
 8004c5c:	d8ed      	bhi.n	8004c3a <USBD_StdItfReq+0x16>
        ret = (USBD_StatusTypeDef)pdev->pClass->Setup (pdev, req);
 8004c5e:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 8004c62:	4629      	mov	r1, r5
 8004c64:	4620      	mov	r0, r4
 8004c66:	689b      	ldr	r3, [r3, #8]
 8004c68:	4798      	blx	r3
        if ((req->wLength == 0U) && (ret == USBD_OK))
 8004c6a:	88eb      	ldrh	r3, [r5, #6]
 8004c6c:	2b00      	cmp	r3, #0
 8004c6e:	d1ec      	bne.n	8004c4a <USBD_StdItfReq+0x26>
 8004c70:	2800      	cmp	r0, #0
 8004c72:	d1ea      	bne.n	8004c4a <USBD_StdItfReq+0x26>
          USBD_CtlSendStatus(pdev);
 8004c74:	4620      	mov	r0, r4
 8004c76:	f000 f901 	bl	8004e7c <USBD_CtlSendStatus>
 8004c7a:	e7e6      	b.n	8004c4a <USBD_StdItfReq+0x26>

08004c7c <USBD_StdEPReq>:
{
 8004c7c:	b570      	push	{r4, r5, r6, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004c7e:	780b      	ldrb	r3, [r1, #0]
{
 8004c80:	4604      	mov	r4, r0
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8004c82:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8004c86:	2b20      	cmp	r3, #32
 8004c88:	d00c      	beq.n	8004ca4 <USBD_StdEPReq+0x28>
 8004c8a:	2b40      	cmp	r3, #64	; 0x40
 8004c8c:	d00a      	beq.n	8004ca4 <USBD_StdEPReq+0x28>
 8004c8e:	b183      	cbz	r3, 8004cb2 <USBD_StdEPReq+0x36>
  USBD_LL_StallEP(pdev , 0x80U);
 8004c90:	2180      	movs	r1, #128	; 0x80
 8004c92:	4620      	mov	r0, r4
 8004c94:	f003 ffbe 	bl	8008c14 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0U);
 8004c98:	4620      	mov	r0, r4
 8004c9a:	2100      	movs	r1, #0
 8004c9c:	f003 ffba 	bl	8008c14 <USBD_LL_StallEP>
}
 8004ca0:	2000      	movs	r0, #0
 8004ca2:	bd70      	pop	{r4, r5, r6, pc}
    pdev->pClass->Setup (pdev, req);
 8004ca4:	f8d4 328c 	ldr.w	r3, [r4, #652]	; 0x28c
 8004ca8:	4620      	mov	r0, r4
 8004caa:	689b      	ldr	r3, [r3, #8]
 8004cac:	4798      	blx	r3
}
 8004cae:	2000      	movs	r0, #0
 8004cb0:	bd70      	pop	{r4, r5, r6, pc}
    switch (req->bRequest)
 8004cb2:	784b      	ldrb	r3, [r1, #1]
  ep_addr  = LOBYTE(req->wIndex);
 8004cb4:	888a      	ldrh	r2, [r1, #4]
    switch (req->bRequest)
 8004cb6:	2b01      	cmp	r3, #1
  ep_addr  = LOBYTE(req->wIndex);
 8004cb8:	b2d5      	uxtb	r5, r2
    switch (req->bRequest)
 8004cba:	d037      	beq.n	8004d2c <USBD_StdEPReq+0xb0>
 8004cbc:	d314      	bcc.n	8004ce8 <USBD_StdEPReq+0x6c>
 8004cbe:	2b03      	cmp	r3, #3
 8004cc0:	d1e6      	bne.n	8004c90 <USBD_StdEPReq+0x14>
      switch (pdev->dev_state)
 8004cc2:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8004cc6:	2b02      	cmp	r3, #2
 8004cc8:	d03f      	beq.n	8004d4a <USBD_StdEPReq+0xce>
 8004cca:	2b03      	cmp	r3, #3
 8004ccc:	d1e0      	bne.n	8004c90 <USBD_StdEPReq+0x14>
        if (req->wValue == USB_FEATURE_EP_HALT)
 8004cce:	884b      	ldrh	r3, [r1, #2]
 8004cd0:	b933      	cbnz	r3, 8004ce0 <USBD_StdEPReq+0x64>
          if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8004cd2:	066a      	lsls	r2, r5, #25
 8004cd4:	d004      	beq.n	8004ce0 <USBD_StdEPReq+0x64>
 8004cd6:	88cb      	ldrh	r3, [r1, #6]
 8004cd8:	b913      	cbnz	r3, 8004ce0 <USBD_StdEPReq+0x64>
            USBD_LL_StallEP(pdev, ep_addr);
 8004cda:	4629      	mov	r1, r5
 8004cdc:	f003 ff9a 	bl	8008c14 <USBD_LL_StallEP>
        USBD_CtlSendStatus(pdev);
 8004ce0:	4620      	mov	r0, r4
 8004ce2:	f000 f8cb 	bl	8004e7c <USBD_CtlSendStatus>
        break;
 8004ce6:	e7db      	b.n	8004ca0 <USBD_StdEPReq+0x24>
      switch (pdev->dev_state)
 8004ce8:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8004cec:	2b02      	cmp	r3, #2
 8004cee:	d036      	beq.n	8004d5e <USBD_StdEPReq+0xe2>
 8004cf0:	2b03      	cmp	r3, #3
 8004cf2:	d1cd      	bne.n	8004c90 <USBD_StdEPReq+0x14>
 8004cf4:	f005 030f 	and.w	r3, r5, #15
        if((ep_addr & 0x80U) == 0x80U)
 8004cf8:	0612      	lsls	r2, r2, #24
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8004cfa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004cfe:	eb00 0383 	add.w	r3, r0, r3, lsl #2
        if((ep_addr & 0x80U) == 0x80U)
 8004d02:	d43e      	bmi.n	8004d82 <USBD_StdEPReq+0x106>
          if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8004d04:	f8d3 3144 	ldr.w	r3, [r3, #324]	; 0x144
 8004d08:	2b00      	cmp	r3, #0
 8004d0a:	d0c1      	beq.n	8004c90 <USBD_StdEPReq+0x14>
 8004d0c:	f005 037f 	and.w	r3, r5, #127	; 0x7f
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 8004d10:	2614      	movs	r6, #20
 8004d12:	fb06 0603 	mla	r6, r6, r3, r0
 8004d16:	f506 76a0 	add.w	r6, r6, #320	; 0x140
          if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8004d1a:	2b00      	cmp	r3, #0
 8004d1c:	d13c      	bne.n	8004d98 <USBD_StdEPReq+0x11c>
            pep->status = 0x0001U;
 8004d1e:	6033      	str	r3, [r6, #0]
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8004d20:	4631      	mov	r1, r6
 8004d22:	4620      	mov	r0, r4
 8004d24:	2202      	movs	r2, #2
 8004d26:	f000 f87b 	bl	8004e20 <USBD_CtlSendData>
          break;
 8004d2a:	e7b9      	b.n	8004ca0 <USBD_StdEPReq+0x24>
      switch (pdev->dev_state)
 8004d2c:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
 8004d30:	2b02      	cmp	r3, #2
 8004d32:	d00a      	beq.n	8004d4a <USBD_StdEPReq+0xce>
 8004d34:	2b03      	cmp	r3, #3
 8004d36:	d1ab      	bne.n	8004c90 <USBD_StdEPReq+0x14>
        if (req->wValue == USB_FEATURE_EP_HALT)
 8004d38:	884b      	ldrh	r3, [r1, #2]
 8004d3a:	2b00      	cmp	r3, #0
 8004d3c:	d1b0      	bne.n	8004ca0 <USBD_StdEPReq+0x24>
          if ((ep_addr & 0x7FU) != 0x00U)
 8004d3e:	066e      	lsls	r6, r5, #25
 8004d40:	d0ce      	beq.n	8004ce0 <USBD_StdEPReq+0x64>
            USBD_LL_ClearStallEP(pdev, ep_addr);
 8004d42:	4629      	mov	r1, r5
 8004d44:	f003 ff74 	bl	8008c30 <USBD_LL_ClearStallEP>
 8004d48:	e7ca      	b.n	8004ce0 <USBD_StdEPReq+0x64>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8004d4a:	066b      	lsls	r3, r5, #25
 8004d4c:	d0a0      	beq.n	8004c90 <USBD_StdEPReq+0x14>
          USBD_LL_StallEP(pdev, ep_addr);
 8004d4e:	4629      	mov	r1, r5
 8004d50:	f003 ff60 	bl	8008c14 <USBD_LL_StallEP>
          USBD_LL_StallEP(pdev, 0x80U);
 8004d54:	4620      	mov	r0, r4
 8004d56:	2180      	movs	r1, #128	; 0x80
 8004d58:	f003 ff5c 	bl	8008c14 <USBD_LL_StallEP>
 8004d5c:	e7a0      	b.n	8004ca0 <USBD_StdEPReq+0x24>
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8004d5e:	0668      	lsls	r0, r5, #25
 8004d60:	d196      	bne.n	8004c90 <USBD_StdEPReq+0x14>
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 8004d62:	0611      	lsls	r1, r2, #24
          pep->status = 0x0000U;
 8004d64:	f04f 0500 	mov.w	r5, #0
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8004d68:	4620      	mov	r0, r4
 8004d6a:	f04f 0202 	mov.w	r2, #2
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 8004d6e:	bf4c      	ite	mi
 8004d70:	f104 0314 	addmi.w	r3, r4, #20
 8004d74:	f504 73a0 	addpl.w	r3, r4, #320	; 0x140
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8004d78:	4619      	mov	r1, r3
          pep->status = 0x0000U;
 8004d7a:	601d      	str	r5, [r3, #0]
          USBD_CtlSendData (pdev, (uint8_t *)(void *)&pep->status, 2U);
 8004d7c:	f000 f850 	bl	8004e20 <USBD_CtlSendData>
          break;
 8004d80:	e78e      	b.n	8004ca0 <USBD_StdEPReq+0x24>
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8004d82:	699b      	ldr	r3, [r3, #24]
 8004d84:	2b00      	cmp	r3, #0
 8004d86:	d083      	beq.n	8004c90 <USBD_StdEPReq+0x14>
 8004d88:	f005 037f 	and.w	r3, r5, #127	; 0x7f
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU]:\
 8004d8c:	1c5e      	adds	r6, r3, #1
 8004d8e:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 8004d92:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8004d96:	e7c0      	b.n	8004d1a <USBD_StdEPReq+0x9e>
          else if(USBD_LL_IsStallEP(pdev, ep_addr))
 8004d98:	4629      	mov	r1, r5
 8004d9a:	4620      	mov	r0, r4
 8004d9c:	f003 ff56 	bl	8008c4c <USBD_LL_IsStallEP>
 8004da0:	b108      	cbz	r0, 8004da6 <USBD_StdEPReq+0x12a>
            pep->status = 0x0001U;
 8004da2:	2301      	movs	r3, #1
 8004da4:	e7bb      	b.n	8004d1e <USBD_StdEPReq+0xa2>
            pep->status = 0x0000U;
 8004da6:	6030      	str	r0, [r6, #0]
 8004da8:	e7ba      	b.n	8004d20 <USBD_StdEPReq+0xa4>
 8004daa:	bf00      	nop

08004dac <USBD_ParseSetupRequest>:
  req->bmRequest     = *(uint8_t *)  (pdata);
 8004dac:	780b      	ldrb	r3, [r1, #0]
 8004dae:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8004db0:	784b      	ldrb	r3, [r1, #1]
 8004db2:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8004db4:	78ca      	ldrb	r2, [r1, #3]
 8004db6:	788b      	ldrb	r3, [r1, #2]
 8004db8:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8004dbc:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8004dbe:	794a      	ldrb	r2, [r1, #5]
 8004dc0:	790b      	ldrb	r3, [r1, #4]
 8004dc2:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8004dc6:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8004dc8:	79ca      	ldrb	r2, [r1, #7]
 8004dca:	798b      	ldrb	r3, [r1, #6]
 8004dcc:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8004dd0:	80c3      	strh	r3, [r0, #6]
}
 8004dd2:	4770      	bx	lr

08004dd4 <USBD_GetString>:
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0U;

  if (desc != NULL)
 8004dd4:	b300      	cbz	r0, 8004e18 <USBD_GetString+0x44>
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0U;

    while (*buf != '\0')
 8004dd6:	7803      	ldrb	r3, [r0, #0]
{
 8004dd8:	b430      	push	{r4, r5}
    while (*buf != '\0')
 8004dda:	b1f3      	cbz	r3, 8004e1a <USBD_GetString+0x46>
 8004ddc:	4604      	mov	r4, r0
    uint8_t  len = 0U;
 8004dde:	2300      	movs	r3, #0
    {
        len++;
 8004de0:	3301      	adds	r3, #1
    while (*buf != '\0')
 8004de2:	f814 5f01 	ldrb.w	r5, [r4, #1]!
        len++;
 8004de6:	b2db      	uxtb	r3, r3
    while (*buf != '\0')
 8004de8:	2d00      	cmp	r5, #0
 8004dea:	d1f9      	bne.n	8004de0 <USBD_GetString+0xc>
 8004dec:	005b      	lsls	r3, r3, #1
 8004dee:	3302      	adds	r3, #2
    unicode[idx++] = USB_DESC_TYPE_STRING;
 8004df0:	2403      	movs	r4, #3
    *len = (uint16_t)USBD_GetLen(desc) * 2U + 2U;
 8004df2:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *(uint8_t *)(void *)len;
 8004df4:	700b      	strb	r3, [r1, #0]
    unicode[idx++] = USB_DESC_TYPE_STRING;
 8004df6:	704c      	strb	r4, [r1, #1]
    while (*desc != '\0')
 8004df8:	7804      	ldrb	r4, [r0, #0]
 8004dfa:	b15c      	cbz	r4, 8004e14 <USBD_GetString+0x40>
    unicode[idx++] = USB_DESC_TYPE_STRING;
 8004dfc:	2302      	movs	r3, #2
      unicode[idx++] =  0U;
 8004dfe:	2500      	movs	r5, #0
      unicode[idx++] = *desc++;
 8004e00:	1c5a      	adds	r2, r3, #1
 8004e02:	54cc      	strb	r4, [r1, r3]
      unicode[idx++] =  0U;
 8004e04:	3302      	adds	r3, #2
      unicode[idx++] = *desc++;
 8004e06:	b2d2      	uxtb	r2, r2
      unicode[idx++] =  0U;
 8004e08:	b2db      	uxtb	r3, r3
 8004e0a:	548d      	strb	r5, [r1, r2]
    while (*desc != '\0')
 8004e0c:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8004e10:	2c00      	cmp	r4, #0
 8004e12:	d1f5      	bne.n	8004e00 <USBD_GetString+0x2c>
}
 8004e14:	bc30      	pop	{r4, r5}
 8004e16:	4770      	bx	lr
 8004e18:	4770      	bx	lr
    while (*buf != '\0')
 8004e1a:	2302      	movs	r3, #2
 8004e1c:	e7e8      	b.n	8004df0 <USBD_GetString+0x1c>
 8004e1e:	bf00      	nop

08004e20 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                     uint16_t len)
{
 8004e20:	b570      	push	{r4, r5, r6, lr}
 8004e22:	4615      	mov	r5, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8004e24:	2602      	movs	r6, #2
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;

 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8004e26:	460a      	mov	r2, r1
 8004e28:	2100      	movs	r1, #0
  pdev->ep_in[0].total_length = len;
 8004e2a:	61c5      	str	r5, [r0, #28]
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8004e2c:	462b      	mov	r3, r5
  pdev->ep_in[0].rem_length   = len;
 8004e2e:	6205      	str	r5, [r0, #32]
  pdev->ep0_state = USBD_EP0_DATA_IN;
 8004e30:	f8c0 626c 	str.w	r6, [r0, #620]	; 0x26c
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8004e34:	f003 ff2c 	bl	8008c90 <USBD_LL_Transmit>

  return USBD_OK;
}
 8004e38:	2000      	movs	r0, #0
 8004e3a:	bd70      	pop	{r4, r5, r6, pc}

08004e3c <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData (USBD_HandleTypeDef *pdev,
                                             uint8_t *pbuf, uint16_t len)
{
 8004e3c:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00U, pbuf, len);
 8004e3e:	4613      	mov	r3, r2
 8004e40:	460a      	mov	r2, r1
 8004e42:	2100      	movs	r1, #0
 8004e44:	f003 ff24 	bl	8008c90 <USBD_LL_Transmit>

  return USBD_OK;
}
 8004e48:	2000      	movs	r0, #0
 8004e4a:	bd08      	pop	{r3, pc}

08004e4c <USBD_CtlPrepareRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlPrepareRx (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                      uint16_t len)
{
 8004e4c:	b570      	push	{r4, r5, r6, lr}
 8004e4e:	4615      	mov	r5, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8004e50:	2603      	movs	r6, #3
  pdev->ep_out[0].total_length = len;
  pdev->ep_out[0].rem_length   = len;

  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev, 0U, pbuf, len);
 8004e52:	460a      	mov	r2, r1
 8004e54:	2100      	movs	r1, #0
  pdev->ep_out[0].total_length = len;
 8004e56:	f8c0 5148 	str.w	r5, [r0, #328]	; 0x148
  USBD_LL_PrepareReceive (pdev, 0U, pbuf, len);
 8004e5a:	462b      	mov	r3, r5
  pdev->ep_out[0].rem_length   = len;
 8004e5c:	f8c0 514c 	str.w	r5, [r0, #332]	; 0x14c
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8004e60:	f8c0 626c 	str.w	r6, [r0, #620]	; 0x26c
  USBD_LL_PrepareReceive (pdev, 0U, pbuf, len);
 8004e64:	f003 ff22 	bl	8008cac <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8004e68:	2000      	movs	r0, #0
 8004e6a:	bd70      	pop	{r4, r5, r6, pc}

08004e6c <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx (USBD_HandleTypeDef *pdev, uint8_t *pbuf,
                                       uint16_t len)
{
 8004e6c:	b508      	push	{r3, lr}
  USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8004e6e:	4613      	mov	r3, r2
 8004e70:	460a      	mov	r2, r1
 8004e72:	2100      	movs	r1, #0
 8004e74:	f003 ff1a 	bl	8008cac <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8004e78:	2000      	movs	r0, #0
 8004e7a:	bd08      	pop	{r3, pc}

08004e7c <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus (USBD_HandleTypeDef *pdev)
{
 8004e7c:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8004e7e:	2204      	movs	r2, #4

  /* Start the transfer */
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8004e80:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8004e82:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
  USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 8004e86:	4619      	mov	r1, r3
 8004e88:	461a      	mov	r2, r3
 8004e8a:	f003 ff01 	bl	8008c90 <USBD_LL_Transmit>

  return USBD_OK;
}
 8004e8e:	2000      	movs	r0, #0
 8004e90:	bd08      	pop	{r3, pc}
 8004e92:	bf00      	nop

08004e94 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus (USBD_HandleTypeDef *pdev)
{
 8004e94:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8004e96:	2205      	movs	r2, #5

 /* Start the transfer */
  USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8004e98:	2300      	movs	r3, #0
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 8004e9a:	f8c0 226c 	str.w	r2, [r0, #620]	; 0x26c
  USBD_LL_PrepareReceive (pdev, 0U, NULL, 0U);
 8004e9e:	4619      	mov	r1, r3
 8004ea0:	461a      	mov	r2, r3
 8004ea2:	f003 ff03 	bl	8008cac <USBD_LL_PrepareReceive>

  return USBD_OK;
}
 8004ea6:	2000      	movs	r0, #0
 8004ea8:	bd08      	pop	{r3, pc}
 8004eaa:	bf00      	nop

08004eac <MX_ADC1_Init>:
{
  ADC_ChannelConfTypeDef sConfig = {0};

  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
  */
  hadc1.Instance = ADC1;
 8004eac:	4b26      	ldr	r3, [pc, #152]	; (8004f48 <MX_ADC1_Init+0x9c>)
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
 8004eae:	f44f 3240 	mov.w	r2, #196608	; 0x30000
  hadc1.Instance = ADC1;
 8004eb2:	4926      	ldr	r1, [pc, #152]	; (8004f4c <MX_ADC1_Init+0xa0>)
  hadc1.Init.ScanConvMode = ENABLE;
  hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.DiscontinuousConvMode = ENABLE;
  hadc1.Init.NbrOfDiscConversion = 1;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8004eb4:	4826      	ldr	r0, [pc, #152]	; (8004f50 <MX_ADC1_Init+0xa4>)
{
 8004eb6:	b530      	push	{r4, r5, lr}
  hadc1.Init.Resolution = ADC_RESOLUTION_6B;
 8004eb8:	f04f 7540 	mov.w	r5, #50331648	; 0x3000000
{
 8004ebc:	b085      	sub	sp, #20
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.NbrOfConversion = 3;
 8004ebe:	2403      	movs	r4, #3
  hadc1.Instance = ADC1;
 8004ec0:	6019      	str	r1, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV8;
 8004ec2:	605a      	str	r2, [r3, #4]
  hadc1.Init.ScanConvMode = ENABLE;
 8004ec4:	2101      	movs	r1, #1
  ADC_ChannelConfTypeDef sConfig = {0};
 8004ec6:	2200      	movs	r2, #0
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8004ec8:	6298      	str	r0, [r3, #40]	; 0x28
  hadc1.Init.DMAContinuousRequests = DISABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8004eca:	4618      	mov	r0, r3
  hadc1.Init.Resolution = ADC_RESOLUTION_6B;
 8004ecc:	609d      	str	r5, [r3, #8]
  hadc1.Init.NbrOfConversion = 3;
 8004ece:	61dc      	str	r4, [r3, #28]
  hadc1.Init.ScanConvMode = ENABLE;
 8004ed0:	6119      	str	r1, [r3, #16]
  hadc1.Init.DiscontinuousConvMode = ENABLE;
 8004ed2:	f883 1020 	strb.w	r1, [r3, #32]
  hadc1.Init.NbrOfDiscConversion = 1;
 8004ed6:	6259      	str	r1, [r3, #36]	; 0x24
  ADC_ChannelConfTypeDef sConfig = {0};
 8004ed8:	9200      	str	r2, [sp, #0]
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8004eda:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8004edc:	60da      	str	r2, [r3, #12]
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8004ede:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  ADC_ChannelConfTypeDef sConfig = {0};
 8004ee2:	9203      	str	r2, [sp, #12]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8004ee4:	e9c3 1205 	strd	r1, r2, [r3, #20]
  ADC_ChannelConfTypeDef sConfig = {0};
 8004ee8:	e9cd 2201 	strd	r2, r2, [sp, #4]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8004eec:	f7fb fb62 	bl	80005b4 <HAL_ADC_Init>
 8004ef0:	bb30      	cbnz	r0, 8004f40 <MX_ADC1_Init+0x94>
  {
    Error_Handler();
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
  */
  sConfig.Channel = ADC_CHANNEL_4;
 8004ef2:	2404      	movs	r4, #4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8004ef4:	2201      	movs	r2, #1
  sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
 8004ef6:	2307      	movs	r3, #7
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8004ef8:	4669      	mov	r1, sp
 8004efa:	4813      	ldr	r0, [pc, #76]	; (8004f48 <MX_ADC1_Init+0x9c>)
  sConfig.SamplingTime = ADC_SAMPLETIME_480CYCLES;
 8004efc:	9302      	str	r3, [sp, #8]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8004efe:	e9cd 4200 	strd	r4, r2, [sp]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8004f02:	f7fb fced 	bl	80008e0 <HAL_ADC_ConfigChannel>
 8004f06:	b9c0      	cbnz	r0, 8004f3a <MX_ADC1_Init+0x8e>
  {
    Error_Handler();
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
  */
  sConfig.Channel = ADC_CHANNEL_6;
 8004f08:	2206      	movs	r2, #6
  sConfig.Rank = ADC_REGULAR_RANK_2;
 8004f0a:	2302      	movs	r3, #2
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8004f0c:	4669      	mov	r1, sp
 8004f0e:	480e      	ldr	r0, [pc, #56]	; (8004f48 <MX_ADC1_Init+0x9c>)
  sConfig.Rank = ADC_REGULAR_RANK_2;
 8004f10:	e9cd 2300 	strd	r2, r3, [sp]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8004f14:	f7fb fce4 	bl	80008e0 <HAL_ADC_ConfigChannel>
 8004f18:	b960      	cbnz	r0, 8004f34 <MX_ADC1_Init+0x88>
  {
    Error_Handler();
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
  */
  sConfig.Channel = ADC_CHANNEL_7;
 8004f1a:	2207      	movs	r2, #7
  sConfig.Rank = ADC_REGULAR_RANK_3;
 8004f1c:	2303      	movs	r3, #3
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8004f1e:	4669      	mov	r1, sp
 8004f20:	4809      	ldr	r0, [pc, #36]	; (8004f48 <MX_ADC1_Init+0x9c>)
  sConfig.Rank = ADC_REGULAR_RANK_3;
 8004f22:	e9cd 2300 	strd	r2, r3, [sp]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8004f26:	f7fb fcdb 	bl	80008e0 <HAL_ADC_ConfigChannel>
 8004f2a:	b108      	cbz	r0, 8004f30 <MX_ADC1_Init+0x84>
  {
    Error_Handler();
 8004f2c:	f001 fe08 	bl	8006b40 <Error_Handler>
  }

}
 8004f30:	b005      	add	sp, #20
 8004f32:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
 8004f34:	f001 fe04 	bl	8006b40 <Error_Handler>
 8004f38:	e7ef      	b.n	8004f1a <MX_ADC1_Init+0x6e>
    Error_Handler();
 8004f3a:	f001 fe01 	bl	8006b40 <Error_Handler>
 8004f3e:	e7e3      	b.n	8004f08 <MX_ADC1_Init+0x5c>
    Error_Handler();
 8004f40:	f001 fdfe 	bl	8006b40 <Error_Handler>
 8004f44:	e7d5      	b.n	8004ef2 <MX_ADC1_Init+0x46>
 8004f46:	bf00      	nop
 8004f48:	2000029c 	.word	0x2000029c
 8004f4c:	40012000 	.word	0x40012000
 8004f50:	0f000001 	.word	0x0f000001

08004f54 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(adcHandle->Instance==ADC1)
 8004f54:	6801      	ldr	r1, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004f56:	2300      	movs	r3, #0
  if(adcHandle->Instance==ADC1)
 8004f58:	4a14      	ldr	r2, [pc, #80]	; (8004fac <HAL_ADC_MspInit+0x58>)
{
 8004f5a:	b530      	push	{r4, r5, lr}
  if(adcHandle->Instance==ADC1)
 8004f5c:	4291      	cmp	r1, r2
{
 8004f5e:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004f60:	e9cd 3303 	strd	r3, r3, [sp, #12]
 8004f64:	e9cd 3305 	strd	r3, r3, [sp, #20]
 8004f68:	9307      	str	r3, [sp, #28]
  if(adcHandle->Instance==ADC1)
 8004f6a:	d001      	beq.n	8004f70 <HAL_ADC_MspInit+0x1c>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 8004f6c:	b009      	add	sp, #36	; 0x24
 8004f6e:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_ADC1_CLK_ENABLE();
 8004f70:	4b0f      	ldr	r3, [pc, #60]	; (8004fb0 <HAL_ADC_MspInit+0x5c>)
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
 8004f72:	25d0      	movs	r5, #208	; 0xd0
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004f74:	2403      	movs	r4, #3
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004f76:	a903      	add	r1, sp, #12
    __HAL_RCC_ADC1_CLK_ENABLE();
 8004f78:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004f7a:	480e      	ldr	r0, [pc, #56]	; (8004fb4 <HAL_ADC_MspInit+0x60>)
    __HAL_RCC_ADC1_CLK_ENABLE();
 8004f7c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8004f80:	645a      	str	r2, [r3, #68]	; 0x44
 8004f82:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8004f84:	f402 7280 	and.w	r2, r2, #256	; 0x100
 8004f88:	9201      	str	r2, [sp, #4]
 8004f8a:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004f8c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004f8e:	f042 0201 	orr.w	r2, r2, #1
 8004f92:	631a      	str	r2, [r3, #48]	; 0x30
 8004f94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
 8004f96:	9503      	str	r5, [sp, #12]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004f98:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8004f9c:	9404      	str	r4, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8004f9e:	9302      	str	r3, [sp, #8]
 8004fa0:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8004fa2:	f7fb fdd5 	bl	8000b50 <HAL_GPIO_Init>
}
 8004fa6:	b009      	add	sp, #36	; 0x24
 8004fa8:	bd30      	pop	{r4, r5, pc}
 8004faa:	bf00      	nop
 8004fac:	40012000 	.word	0x40012000
 8004fb0:	40023800 	.word	0x40023800
 8004fb4:	40020000 	.word	0x40020000

08004fb8 <initFifo>:

midiData_t fifoData[FIFO_SIZE];

void initFifo(midiFifo *fifo)
{
	fifo->head = 0;
 8004fb8:	2100      	movs	r1, #0
	fifo->tail = 0;
	fifo->size = FIFO_SIZE;
 8004fba:	22ff      	movs	r2, #255	; 0xff
	fifo->midiData = fifoData;
 8004fbc:	4b02      	ldr	r3, [pc, #8]	; (8004fc8 <initFifo+0x10>)
	fifo->head = 0;
 8004fbe:	6001      	str	r1, [r0, #0]
	fifo->size = FIFO_SIZE;
 8004fc0:	8082      	strh	r2, [r0, #4]
	fifo->midiData = fifoData;
 8004fc2:	6083      	str	r3, [r0, #8]
}
 8004fc4:	4770      	bx	lr
 8004fc6:	bf00      	nop
 8004fc8:	200002e4 	.word	0x200002e4

08004fcc <push>:

uint8_t push(midiFifo *fifo, midiData_t *newData)
{
 8004fcc:	b430      	push	{r4, r5}
	if( (fifo->head + 1 == fifo->tail) ||
 8004fce:	8804      	ldrh	r4, [r0, #0]
{
 8004fd0:	4603      	mov	r3, r0
	if( (fifo->head + 1 == fifo->tail) ||
 8004fd2:	8840      	ldrh	r0, [r0, #2]
 8004fd4:	1c62      	adds	r2, r4, #1
 8004fd6:	4282      	cmp	r2, r0
 8004fd8:	d013      	beq.n	8005002 <push+0x36>
			( (fifo->head + 1 == fifo->size) && (fifo->tail == 0) ) )
 8004fda:	889d      	ldrh	r5, [r3, #4]
 8004fdc:	b908      	cbnz	r0, 8004fe2 <push+0x16>
 8004fde:	4295      	cmp	r5, r2
 8004fe0:	d00f      	beq.n	8005002 <push+0x36>
	{
		return 0;
	}
	else
	{
		fifo->midiData[fifo->head++] = newData[0];
 8004fe2:	b292      	uxth	r2, r2
 8004fe4:	6808      	ldr	r0, [r1, #0]
 8004fe6:	6899      	ldr	r1, [r3, #8]
		if(fifo->head == fifo->size)
 8004fe8:	4295      	cmp	r5, r2
		fifo->midiData[fifo->head++] = newData[0];
 8004fea:	801a      	strh	r2, [r3, #0]
 8004fec:	f841 0024 	str.w	r0, [r1, r4, lsl #2]
		if(fifo->head == fifo->size)
 8004ff0:	d002      	beq.n	8004ff8 <push+0x2c>
		{
			fifo->head = 0;
		}
	}
	return 1;
 8004ff2:	2001      	movs	r0, #1
}
 8004ff4:	bc30      	pop	{r4, r5}
 8004ff6:	4770      	bx	lr
			fifo->head = 0;
 8004ff8:	2200      	movs	r2, #0
	return 1;
 8004ffa:	2001      	movs	r0, #1
			fifo->head = 0;
 8004ffc:	801a      	strh	r2, [r3, #0]
}
 8004ffe:	bc30      	pop	{r4, r5}
 8005000:	4770      	bx	lr
		return 0;
 8005002:	2000      	movs	r0, #0
}
 8005004:	bc30      	pop	{r4, r5}
 8005006:	4770      	bx	lr

08005008 <pop>:

midiData_t pop(midiFifo *fifo)
{
	midiData_t returnVal = {.status = 0, .channel = 0, .data1 = 0, .data2 = 0};
	if( fifo->tail != fifo->head )
 8005008:	8843      	ldrh	r3, [r0, #2]
 800500a:	8802      	ldrh	r2, [r0, #0]
 800500c:	429a      	cmp	r2, r3
{
 800500e:	b4f0      	push	{r4, r5, r6, r7}
 8005010:	b082      	sub	sp, #8
	if( fifo->tail != fifo->head )
 8005012:	d02b      	beq.n	800506c <pop+0x64>
	{
		returnVal = fifo->midiData[fifo->tail++];
 8005014:	6884      	ldr	r4, [r0, #8]
 8005016:	1c5a      	adds	r2, r3, #1
		if( fifo->tail == fifo->size )
 8005018:	8887      	ldrh	r7, [r0, #4]
		returnVal = fifo->midiData[fifo->tail++];
 800501a:	eb04 0183 	add.w	r1, r4, r3, lsl #2
 800501e:	f814 6023 	ldrb.w	r6, [r4, r3, lsl #2]
 8005022:	b293      	uxth	r3, r2
 8005024:	784d      	ldrb	r5, [r1, #1]
		if( fifo->tail == fifo->size )
 8005026:	429f      	cmp	r7, r3
		returnVal = fifo->midiData[fifo->tail++];
 8005028:	8043      	strh	r3, [r0, #2]
 800502a:	788c      	ldrb	r4, [r1, #2]
 800502c:	78ca      	ldrb	r2, [r1, #3]
		if( fifo->tail == fifo->size )
 800502e:	d01a      	beq.n	8005066 <pop+0x5e>
		{
			fifo->tail = 0;
		}
	}
	return returnVal;
 8005030:	2300      	movs	r3, #0
 8005032:	4618      	mov	r0, r3
 8005034:	f366 0307 	bfi	r3, r6, #0, #8
 8005038:	f365 230f 	bfi	r3, r5, #8, #8
 800503c:	f364 4317 	bfi	r3, r4, #16, #8
 8005040:	f362 631f 	bfi	r3, r2, #24, #8
 8005044:	b2dc      	uxtb	r4, r3
 8005046:	f3c3 2107 	ubfx	r1, r3, #8, #8
 800504a:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800504e:	0e1b      	lsrs	r3, r3, #24
 8005050:	f364 0007 	bfi	r0, r4, #0, #8
 8005054:	f361 200f 	bfi	r0, r1, #8, #8
 8005058:	f362 4017 	bfi	r0, r2, #16, #8
 800505c:	f363 601f 	bfi	r0, r3, #24, #8
}
 8005060:	b002      	add	sp, #8
 8005062:	bcf0      	pop	{r4, r5, r6, r7}
 8005064:	4770      	bx	lr
			fifo->tail = 0;
 8005066:	2300      	movs	r3, #0
 8005068:	8043      	strh	r3, [r0, #2]
 800506a:	e7e1      	b.n	8005030 <pop+0x28>
	midiData_t returnVal = {.status = 0, .channel = 0, .data1 = 0, .data2 = 0};
 800506c:	2200      	movs	r2, #0
 800506e:	4614      	mov	r4, r2
 8005070:	4615      	mov	r5, r2
 8005072:	4616      	mov	r6, r2
 8005074:	e7dc      	b.n	8005030 <pop+0x28>
 8005076:	bf00      	nop

08005078 <MX_GFXSIMULATOR_Init>:

/* GFXSIMULATOR init function */
void MX_GFXSIMULATOR_Init(void)
{

}
 8005078:	4770      	bx	lr
 800507a:	bf00      	nop

0800507c <MX_GPIO_Init>:
        * EVENT_OUT
        * EXTI
     PA1   ------> UART4_RX
*/
void MX_GPIO_Init(void)
{
 800507c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8005080:	4b5e      	ldr	r3, [pc, #376]	; (80051fc <MX_GPIO_Init+0x180>)
{
 8005082:	b08d      	sub	sp, #52	; 0x34
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005084:	2400      	movs	r4, #0
                           PEPin PEPin PEPin PEPin 
                           PEPin PEPin */
  GPIO_InitStruct.Pin = PWM1_Pin|PWM2_Pin|PWM3_Pin|PWM22_Pin 
                          |PWM23_Pin|PWM25_Pin|PWM27_Pin|PWM30_Pin 
                          |PWM64_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8005086:	2601      	movs	r6, #1
  HAL_GPIO_WritePin(GPIOE, PWM1_Pin|PWM2_Pin|PWM3_Pin|PWM22_Pin 
 8005088:	f8df a178 	ldr.w	sl, [pc, #376]	; 8005204 <MX_GPIO_Init+0x188>
 800508c:	f249 51be 	movw	r1, #38334	; 0x95be
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005090:	9408      	str	r4, [sp, #32]
  HAL_GPIO_WritePin(GPIOE, PWM1_Pin|PWM2_Pin|PWM3_Pin|PWM22_Pin 
 8005092:	4622      	mov	r2, r4
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005094:	9407      	str	r4, [sp, #28]
  HAL_GPIO_WritePin(GPIOE, PWM1_Pin|PWM2_Pin|PWM3_Pin|PWM22_Pin 
 8005096:	4650      	mov	r0, sl
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005098:	940b      	str	r4, [sp, #44]	; 0x2c
  HAL_GPIO_WritePin(GPIOC, PWM6_Pin|PWM7_Pin|PWM8_Pin|PWM9_Pin 
 800509a:	f8df 916c 	ldr.w	r9, [pc, #364]	; 8005208 <MX_GPIO_Init+0x18c>
  HAL_GPIO_WritePin(GPIOA, PWM44_Pin|PWM45_Pin|PWM46_Pin, GPIO_PIN_RESET);
 800509e:	4f58      	ldr	r7, [pc, #352]	; (8005200 <MX_GPIO_Init+0x184>)
  HAL_GPIO_WritePin(GPIOB, PWM21_Pin|PWM31_Pin|PWM32_Pin, GPIO_PIN_RESET);
 80050a0:	f8df 8168 	ldr.w	r8, [pc, #360]	; 800520c <MX_GPIO_Init+0x190>
  HAL_GPIO_WritePin(GPIOD, PWM35_Pin|PWM36_Pin|PWM37_Pin|PWM38_Pin 
 80050a4:	f8df b168 	ldr.w	fp, [pc, #360]	; 8005210 <MX_GPIO_Init+0x194>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80050a8:	e9cd 4409 	strd	r4, r4, [sp, #36]	; 0x24
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80050ac:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 80050ae:	f045 0510 	orr.w	r5, r5, #16
 80050b2:	631d      	str	r5, [r3, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80050b4:	2503      	movs	r5, #3
  __HAL_RCC_GPIOE_CLK_ENABLE();
 80050b6:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 80050ba:	f00c 0c10 	and.w	ip, ip, #16
 80050be:	f8cd c004 	str.w	ip, [sp, #4]
 80050c2:	f8dd c004 	ldr.w	ip, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 80050c6:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 80050ca:	f04c 0c04 	orr.w	ip, ip, #4
 80050ce:	f8c3 c030 	str.w	ip, [r3, #48]	; 0x30
 80050d2:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 80050d6:	f00c 0c04 	and.w	ip, ip, #4
 80050da:	f8cd c008 	str.w	ip, [sp, #8]
 80050de:	f8dd c008 	ldr.w	ip, [sp, #8]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80050e2:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 80050e6:	f04c 0c80 	orr.w	ip, ip, #128	; 0x80
 80050ea:	f8c3 c030 	str.w	ip, [r3, #48]	; 0x30
 80050ee:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 80050f2:	f00c 0c80 	and.w	ip, ip, #128	; 0x80
 80050f6:	f8cd c00c 	str.w	ip, [sp, #12]
 80050fa:	f8dd c00c 	ldr.w	ip, [sp, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80050fe:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 8005102:	ea4c 0c06 	orr.w	ip, ip, r6
 8005106:	f8c3 c030 	str.w	ip, [r3, #48]	; 0x30
 800510a:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 800510e:	ea0c 0c06 	and.w	ip, ip, r6
 8005112:	f8cd c010 	str.w	ip, [sp, #16]
 8005116:	f8dd c010 	ldr.w	ip, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800511a:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 800511e:	f04c 0c02 	orr.w	ip, ip, #2
 8005122:	f8c3 c030 	str.w	ip, [r3, #48]	; 0x30
 8005126:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 800512a:	f00c 0c02 	and.w	ip, ip, #2
 800512e:	f8cd c014 	str.w	ip, [sp, #20]
 8005132:	f8dd c014 	ldr.w	ip, [sp, #20]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8005136:	f8d3 c030 	ldr.w	ip, [r3, #48]	; 0x30
 800513a:	f04c 0c08 	orr.w	ip, ip, #8
 800513e:	f8c3 c030 	str.w	ip, [r3, #48]	; 0x30
 8005142:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005144:	f003 0308 	and.w	r3, r3, #8
 8005148:	9306      	str	r3, [sp, #24]
 800514a:	9b06      	ldr	r3, [sp, #24]
  HAL_GPIO_WritePin(GPIOE, PWM1_Pin|PWM2_Pin|PWM3_Pin|PWM22_Pin 
 800514c:	f7fb fe24 	bl	8000d98 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOC, PWM6_Pin|PWM7_Pin|PWM8_Pin|PWM9_Pin 
 8005150:	4622      	mov	r2, r4
 8005152:	4648      	mov	r0, r9
 8005154:	f64f 413f 	movw	r1, #64575	; 0xfc3f
 8005158:	f7fb fe1e 	bl	8000d98 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, PWM44_Pin|PWM45_Pin|PWM46_Pin, GPIO_PIN_RESET);
 800515c:	4622      	mov	r2, r4
 800515e:	4638      	mov	r0, r7
 8005160:	f44f 4106 	mov.w	r1, #34304	; 0x8600
 8005164:	f7fb fe18 	bl	8000d98 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, PWM21_Pin|PWM31_Pin|PWM32_Pin, GPIO_PIN_RESET);
 8005168:	4622      	mov	r2, r4
 800516a:	4640      	mov	r0, r8
 800516c:	f243 0104 	movw	r1, #12292	; 0x3004
 8005170:	f7fb fe12 	bl	8000d98 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOD, PWM35_Pin|PWM36_Pin|PWM37_Pin|PWM38_Pin 
 8005174:	4622      	mov	r2, r4
 8005176:	4658      	mov	r0, fp
 8005178:	f640 71ff 	movw	r1, #4095	; 0xfff
 800517c:	f7fb fe0c 	bl	8000d98 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = PWM1_Pin|PWM2_Pin|PWM3_Pin|PWM22_Pin 
 8005180:	f249 539e 	movw	r3, #38302	; 0x959e
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8005184:	4650      	mov	r0, sl
 8005186:	a907      	add	r1, sp, #28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8005188:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800518a:	950a      	str	r5, [sp, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800518c:	e9cd 3607 	strd	r3, r6, [sp, #28]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8005190:	f7fb fcde 	bl	8000b50 <HAL_GPIO_Init>

  /*Configure GPIO pins : PCPin PCPin PCPin PCPin 
                           PCPin PCPin PCPin PCPin 
                           PCPin PCPin PCPin PCPin */
  GPIO_InitStruct.Pin = PWM6_Pin|PWM7_Pin|PWM8_Pin|PWM9_Pin 
 8005194:	f64f 433f 	movw	r3, #64575	; 0xfc3f
                          |PWM10_Pin|PWM11_Pin|PWM12_Pin|PWM17_Pin 
                          |PWM18_Pin|PWM47_Pin|PWM48_Pin|PWM49_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8005198:	4648      	mov	r0, r9
 800519a:	a907      	add	r1, sp, #28
  GPIO_InitStruct.Pin = PWM6_Pin|PWM7_Pin|PWM8_Pin|PWM9_Pin 
 800519c:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800519e:	950a      	str	r5, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80051a0:	e9cd 6408 	strd	r6, r4, [sp, #32]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80051a4:	f7fb fcd4 	bl	8000b50 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA0 */
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
 80051a8:	23d0      	movs	r3, #208	; 0xd0
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80051aa:	a907      	add	r1, sp, #28
 80051ac:	4638      	mov	r0, r7
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
 80051ae:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80051b0:	e9cd 4408 	strd	r4, r4, [sp, #32]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80051b4:	f7fb fccc 	bl	8000b50 <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin PAPin PAPin */
  GPIO_InitStruct.Pin = PWM13_Pin|PWM44_Pin|PWM45_Pin|PWM46_Pin|PWM63_Pin;
 80051b8:	f248 6321 	movw	r3, #34337	; 0x8621
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80051bc:	4638      	mov	r0, r7
 80051be:	a907      	add	r1, sp, #28
  GPIO_InitStruct.Pin = PWM13_Pin|PWM44_Pin|PWM45_Pin|PWM46_Pin|PWM63_Pin;
 80051c0:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80051c2:	950a      	str	r5, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80051c4:	e9cd 6408 	strd	r6, r4, [sp, #32]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80051c8:	f7fb fcc2 	bl	8000b50 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = PWM21_Pin|PWM31_Pin|PWM32_Pin;
 80051cc:	f243 0304 	movw	r3, #12292	; 0x3004
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80051d0:	4640      	mov	r0, r8
 80051d2:	a907      	add	r1, sp, #28
  GPIO_InitStruct.Pin = PWM21_Pin|PWM31_Pin|PWM32_Pin;
 80051d4:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80051d6:	950a      	str	r5, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80051d8:	e9cd 6408 	strd	r6, r4, [sp, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80051dc:	f7fb fcb8 	bl	8000b50 <HAL_GPIO_Init>

  /*Configure GPIO pins : PDPin PDPin PDPin PDPin 
                           PDPin PDPin PDPin PDPin 
                           PDPin PDPin PDPin PDPin */
  GPIO_InitStruct.Pin = PWM35_Pin|PWM36_Pin|PWM37_Pin|PWM38_Pin 
 80051e0:	f640 73ff 	movw	r3, #4095	; 0xfff
                          |PWM50_Pin|PWM51_Pin|PWM52_Pin|PWM53_Pin 
                          |PWM54_Pin|PWM55_Pin|PWM56_Pin|PWM57_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80051e4:	a907      	add	r1, sp, #28
 80051e6:	4658      	mov	r0, fp
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80051e8:	950a      	str	r5, [sp, #40]	; 0x28
  GPIO_InitStruct.Pin = PWM35_Pin|PWM36_Pin|PWM37_Pin|PWM38_Pin 
 80051ea:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80051ec:	e9cd 6408 	strd	r6, r4, [sp, #32]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80051f0:	f7fb fcae 	bl	8000b50 <HAL_GPIO_Init>

}
 80051f4:	b00d      	add	sp, #52	; 0x34
 80051f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80051fa:	bf00      	nop
 80051fc:	40023800 	.word	0x40023800
 8005200:	40020000 	.word	0x40020000
 8005204:	40021000 	.word	0x40021000
 8005208:	40020800 	.word	0x40020800
 800520c:	40020400 	.word	0x40020400
 8005210:	40020c00 	.word	0x40020c00

08005214 <MX_I2C1_Init>:
I2C_HandleTypeDef hi2c3;
I2C_HandleTypeDef hi2c4;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 8005214:	b538      	push	{r3, r4, r5, lr}

  hi2c1.Instance = I2C1;
 8005216:	4b13      	ldr	r3, [pc, #76]	; (8005264 <MX_I2C1_Init+0x50>)
  hi2c1.Init.Timing = 0x20404768;
  hi2c1.Init.OwnAddress1 = 0;
 8005218:	2200      	movs	r2, #0
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800521a:	2101      	movs	r1, #1
  hi2c1.Instance = I2C1;
 800521c:	4d12      	ldr	r5, [pc, #72]	; (8005268 <MX_I2C1_Init+0x54>)
  hi2c1.Init.Timing = 0x20404768;
 800521e:	4c13      	ldr	r4, [pc, #76]	; (800526c <MX_I2C1_Init+0x58>)
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8005220:	4618      	mov	r0, r3
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8005222:	621a      	str	r2, [r3, #32]
  hi2c1.Init.Timing = 0x20404768;
 8005224:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c1.Init.OwnAddress1 = 0;
 8005228:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c1.Init.OwnAddress2 = 0;
 800522c:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8005230:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8005234:	f7fb fe66 	bl	8000f04 <HAL_I2C_Init>
 8005238:	b988      	cbnz	r0, 800525e <MX_I2C1_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800523a:	2100      	movs	r1, #0
 800523c:	4809      	ldr	r0, [pc, #36]	; (8005264 <MX_I2C1_Init+0x50>)
 800523e:	f7fb ff85 	bl	800114c <HAL_I2CEx_ConfigAnalogFilter>
 8005242:	b948      	cbnz	r0, 8005258 <MX_I2C1_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8005244:	2100      	movs	r1, #0
 8005246:	4807      	ldr	r0, [pc, #28]	; (8005264 <MX_I2C1_Init+0x50>)
 8005248:	f7fb ffaa 	bl	80011a0 <HAL_I2CEx_ConfigDigitalFilter>
 800524c:	b900      	cbnz	r0, 8005250 <MX_I2C1_Init+0x3c>
  {
    Error_Handler();
  }

}
 800524e:	bd38      	pop	{r3, r4, r5, pc}
 8005250:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 8005254:	f001 bc74 	b.w	8006b40 <Error_Handler>
    Error_Handler();
 8005258:	f001 fc72 	bl	8006b40 <Error_Handler>
 800525c:	e7f2      	b.n	8005244 <MX_I2C1_Init+0x30>
    Error_Handler();
 800525e:	f001 fc6f 	bl	8006b40 <Error_Handler>
 8005262:	e7ea      	b.n	800523a <MX_I2C1_Init+0x26>
 8005264:	20000778 	.word	0x20000778
 8005268:	40005400 	.word	0x40005400
 800526c:	20404768 	.word	0x20404768

08005270 <MX_I2C2_Init>:
/* I2C2 init function */
void MX_I2C2_Init(void)
{
 8005270:	b538      	push	{r3, r4, r5, lr}

  hi2c2.Instance = I2C2;
 8005272:	4b13      	ldr	r3, [pc, #76]	; (80052c0 <MX_I2C2_Init+0x50>)
  hi2c2.Init.Timing = 0x20404768;
  hi2c2.Init.OwnAddress1 = 0;
 8005274:	2200      	movs	r2, #0
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8005276:	2101      	movs	r1, #1
  hi2c2.Instance = I2C2;
 8005278:	4d12      	ldr	r5, [pc, #72]	; (80052c4 <MX_I2C2_Init+0x54>)
  hi2c2.Init.Timing = 0x20404768;
 800527a:	4c13      	ldr	r4, [pc, #76]	; (80052c8 <MX_I2C2_Init+0x58>)
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 800527c:	4618      	mov	r0, r3
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800527e:	621a      	str	r2, [r3, #32]
  hi2c2.Init.Timing = 0x20404768;
 8005280:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c2.Init.OwnAddress1 = 0;
 8005284:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c2.Init.OwnAddress2 = 0;
 8005288:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800528c:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 8005290:	f7fb fe38 	bl	8000f04 <HAL_I2C_Init>
 8005294:	b988      	cbnz	r0, 80052ba <MX_I2C2_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8005296:	2100      	movs	r1, #0
 8005298:	4809      	ldr	r0, [pc, #36]	; (80052c0 <MX_I2C2_Init+0x50>)
 800529a:	f7fb ff57 	bl	800114c <HAL_I2CEx_ConfigAnalogFilter>
 800529e:	b948      	cbnz	r0, 80052b4 <MX_I2C2_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
 80052a0:	2100      	movs	r1, #0
 80052a2:	4807      	ldr	r0, [pc, #28]	; (80052c0 <MX_I2C2_Init+0x50>)
 80052a4:	f7fb ff7c 	bl	80011a0 <HAL_I2CEx_ConfigDigitalFilter>
 80052a8:	b900      	cbnz	r0, 80052ac <MX_I2C2_Init+0x3c>
  {
    Error_Handler();
  }

}
 80052aa:	bd38      	pop	{r3, r4, r5, pc}
 80052ac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 80052b0:	f001 bc46 	b.w	8006b40 <Error_Handler>
    Error_Handler();
 80052b4:	f001 fc44 	bl	8006b40 <Error_Handler>
 80052b8:	e7f2      	b.n	80052a0 <MX_I2C2_Init+0x30>
    Error_Handler();
 80052ba:	f001 fc41 	bl	8006b40 <Error_Handler>
 80052be:	e7ea      	b.n	8005296 <MX_I2C2_Init+0x26>
 80052c0:	200007c4 	.word	0x200007c4
 80052c4:	40005800 	.word	0x40005800
 80052c8:	20404768 	.word	0x20404768

080052cc <MX_I2C3_Init>:
/* I2C3 init function */
void MX_I2C3_Init(void)
{
 80052cc:	b538      	push	{r3, r4, r5, lr}

  hi2c3.Instance = I2C3;
 80052ce:	4b13      	ldr	r3, [pc, #76]	; (800531c <MX_I2C3_Init+0x50>)
  hi2c3.Init.Timing = 0x20404768;
  hi2c3.Init.OwnAddress1 = 0;
 80052d0:	2200      	movs	r2, #0
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80052d2:	2101      	movs	r1, #1
  hi2c3.Instance = I2C3;
 80052d4:	4d12      	ldr	r5, [pc, #72]	; (8005320 <MX_I2C3_Init+0x54>)
  hi2c3.Init.Timing = 0x20404768;
 80052d6:	4c13      	ldr	r4, [pc, #76]	; (8005324 <MX_I2C3_Init+0x58>)
  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c3.Init.OwnAddress2 = 0;
  hi2c3.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
 80052d8:	4618      	mov	r0, r3
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80052da:	621a      	str	r2, [r3, #32]
  hi2c3.Init.Timing = 0x20404768;
 80052dc:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c3.Init.OwnAddress1 = 0;
 80052e0:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c3.Init.OwnAddress2 = 0;
 80052e4:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80052e8:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
 80052ec:	f7fb fe0a 	bl	8000f04 <HAL_I2C_Init>
 80052f0:	b988      	cbnz	r0, 8005316 <MX_I2C3_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c3, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80052f2:	2100      	movs	r1, #0
 80052f4:	4809      	ldr	r0, [pc, #36]	; (800531c <MX_I2C3_Init+0x50>)
 80052f6:	f7fb ff29 	bl	800114c <HAL_I2CEx_ConfigAnalogFilter>
 80052fa:	b948      	cbnz	r0, 8005310 <MX_I2C3_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c3, 0) != HAL_OK)
 80052fc:	2100      	movs	r1, #0
 80052fe:	4807      	ldr	r0, [pc, #28]	; (800531c <MX_I2C3_Init+0x50>)
 8005300:	f7fb ff4e 	bl	80011a0 <HAL_I2CEx_ConfigDigitalFilter>
 8005304:	b900      	cbnz	r0, 8005308 <MX_I2C3_Init+0x3c>
  {
    Error_Handler();
  }

}
 8005306:	bd38      	pop	{r3, r4, r5, pc}
 8005308:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 800530c:	f001 bc18 	b.w	8006b40 <Error_Handler>
    Error_Handler();
 8005310:	f001 fc16 	bl	8006b40 <Error_Handler>
 8005314:	e7f2      	b.n	80052fc <MX_I2C3_Init+0x30>
    Error_Handler();
 8005316:	f001 fc13 	bl	8006b40 <Error_Handler>
 800531a:	e7ea      	b.n	80052f2 <MX_I2C3_Init+0x26>
 800531c:	200006e0 	.word	0x200006e0
 8005320:	40005c00 	.word	0x40005c00
 8005324:	20404768 	.word	0x20404768

08005328 <MX_I2C4_Init>:
/* I2C4 init function */
void MX_I2C4_Init(void)
{
 8005328:	b538      	push	{r3, r4, r5, lr}

  hi2c4.Instance = I2C4;
 800532a:	4b13      	ldr	r3, [pc, #76]	; (8005378 <MX_I2C4_Init+0x50>)
  hi2c4.Init.Timing = 0x20404768;
  hi2c4.Init.OwnAddress1 = 0;
 800532c:	2200      	movs	r2, #0
  hi2c4.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800532e:	2101      	movs	r1, #1
  hi2c4.Instance = I2C4;
 8005330:	4d12      	ldr	r5, [pc, #72]	; (800537c <MX_I2C4_Init+0x54>)
  hi2c4.Init.Timing = 0x20404768;
 8005332:	4c13      	ldr	r4, [pc, #76]	; (8005380 <MX_I2C4_Init+0x58>)
  hi2c4.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c4.Init.OwnAddress2 = 0;
  hi2c4.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
 8005334:	4618      	mov	r0, r3
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8005336:	621a      	str	r2, [r3, #32]
  hi2c4.Init.Timing = 0x20404768;
 8005338:	e9c3 5400 	strd	r5, r4, [r3]
  hi2c4.Init.OwnAddress1 = 0;
 800533c:	e9c3 2102 	strd	r2, r1, [r3, #8]
  hi2c4.Init.OwnAddress2 = 0;
 8005340:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8005344:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
 8005348:	f7fb fddc 	bl	8000f04 <HAL_I2C_Init>
 800534c:	b988      	cbnz	r0, 8005372 <MX_I2C4_Init+0x4a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800534e:	2100      	movs	r1, #0
 8005350:	4809      	ldr	r0, [pc, #36]	; (8005378 <MX_I2C4_Init+0x50>)
 8005352:	f7fb fefb 	bl	800114c <HAL_I2CEx_ConfigAnalogFilter>
 8005356:	b948      	cbnz	r0, 800536c <MX_I2C4_Init+0x44>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c4, 0) != HAL_OK)
 8005358:	2100      	movs	r1, #0
 800535a:	4807      	ldr	r0, [pc, #28]	; (8005378 <MX_I2C4_Init+0x50>)
 800535c:	f7fb ff20 	bl	80011a0 <HAL_I2CEx_ConfigDigitalFilter>
 8005360:	b900      	cbnz	r0, 8005364 <MX_I2C4_Init+0x3c>
  {
    Error_Handler();
  }

}
 8005362:	bd38      	pop	{r3, r4, r5, pc}
 8005364:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 8005368:	f001 bbea 	b.w	8006b40 <Error_Handler>
    Error_Handler();
 800536c:	f001 fbe8 	bl	8006b40 <Error_Handler>
 8005370:	e7f2      	b.n	8005358 <MX_I2C4_Init+0x30>
    Error_Handler();
 8005372:	f001 fbe5 	bl	8006b40 <Error_Handler>
 8005376:	e7ea      	b.n	800534e <MX_I2C4_Init+0x26>
 8005378:	2000072c 	.word	0x2000072c
 800537c:	40006000 	.word	0x40006000
 8005380:	20404768 	.word	0x20404768

08005384 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(i2cHandle->Instance==I2C1)
 8005384:	6802      	ldr	r2, [r0, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005386:	2300      	movs	r3, #0
  if(i2cHandle->Instance==I2C1)
 8005388:	495d      	ldr	r1, [pc, #372]	; (8005500 <HAL_I2C_MspInit+0x17c>)
{
 800538a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(i2cHandle->Instance==I2C1)
 800538e:	428a      	cmp	r2, r1
{
 8005390:	b08e      	sub	sp, #56	; 0x38
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8005392:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
 8005396:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 800539a:	930d      	str	r3, [sp, #52]	; 0x34
  if(i2cHandle->Instance==I2C1)
 800539c:	d030      	beq.n	8005400 <HAL_I2C_MspInit+0x7c>
    __HAL_RCC_I2C1_CLK_ENABLE();
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
  else if(i2cHandle->Instance==I2C2)
 800539e:	4b59      	ldr	r3, [pc, #356]	; (8005504 <HAL_I2C_MspInit+0x180>)
 80053a0:	429a      	cmp	r2, r3
 80053a2:	d051      	beq.n	8005448 <HAL_I2C_MspInit+0xc4>
    __HAL_RCC_I2C2_CLK_ENABLE();
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
  else if(i2cHandle->Instance==I2C3)
 80053a4:	4b58      	ldr	r3, [pc, #352]	; (8005508 <HAL_I2C_MspInit+0x184>)
 80053a6:	429a      	cmp	r2, r3
 80053a8:	d073      	beq.n	8005492 <HAL_I2C_MspInit+0x10e>
    __HAL_RCC_I2C3_CLK_ENABLE();
  /* USER CODE BEGIN I2C3_MspInit 1 */

  /* USER CODE END I2C3_MspInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
 80053aa:	4b58      	ldr	r3, [pc, #352]	; (800550c <HAL_I2C_MspInit+0x188>)
 80053ac:	429a      	cmp	r2, r3
 80053ae:	d002      	beq.n	80053b6 <HAL_I2C_MspInit+0x32>
    __HAL_RCC_I2C4_CLK_ENABLE();
  /* USER CODE BEGIN I2C4_MspInit 1 */

  /* USER CODE END I2C4_MspInit 1 */
  }
}
 80053b0:	b00e      	add	sp, #56	; 0x38
 80053b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80053b6:	4c56      	ldr	r4, [pc, #344]	; (8005510 <HAL_I2C_MspInit+0x18c>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80053b8:	2212      	movs	r2, #18
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80053ba:	2001      	movs	r0, #1
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
 80053bc:	f44f 5640 	mov.w	r6, #12288	; 0x3000
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80053c0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80053c2:	2503      	movs	r5, #3
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80053c4:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80053c6:	f043 0308 	orr.w	r3, r3, #8
 80053ca:	6323      	str	r3, [r4, #48]	; 0x30
 80053cc:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80053ce:	920a      	str	r2, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
 80053d0:	2204      	movs	r2, #4
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80053d2:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80053d6:	900b      	str	r0, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80053d8:	484e      	ldr	r0, [pc, #312]	; (8005514 <HAL_I2C_MspInit+0x190>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80053da:	9307      	str	r3, [sp, #28]
 80053dc:	9b07      	ldr	r3, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
 80053de:	9609      	str	r6, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
 80053e0:	e9cd 520c 	strd	r5, r2, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80053e4:	f7fb fbb4 	bl	8000b50 <HAL_GPIO_Init>
    __HAL_RCC_I2C4_CLK_ENABLE();
 80053e8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80053ea:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80053ee:	6423      	str	r3, [r4, #64]	; 0x40
 80053f0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80053f2:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80053f6:	9308      	str	r3, [sp, #32]
 80053f8:	9b08      	ldr	r3, [sp, #32]
}
 80053fa:	b00e      	add	sp, #56	; 0x38
 80053fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005400:	4c43      	ldr	r4, [pc, #268]	; (8005510 <HAL_I2C_MspInit+0x18c>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005402:	2212      	movs	r2, #18
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005404:	2001      	movs	r0, #1
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8005406:	26c0      	movs	r6, #192	; 0xc0
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005408:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800540a:	2503      	movs	r5, #3
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800540c:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800540e:	f043 0302 	orr.w	r3, r3, #2
 8005412:	6323      	str	r3, [r4, #48]	; 0x30
 8005414:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005416:	920a      	str	r2, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8005418:	2204      	movs	r2, #4
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800541a:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800541e:	900b      	str	r0, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005420:	483d      	ldr	r0, [pc, #244]	; (8005518 <HAL_I2C_MspInit+0x194>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005422:	9300      	str	r3, [sp, #0]
 8005424:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 8005426:	9609      	str	r6, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8005428:	e9cd 520c 	strd	r5, r2, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800542c:	f7fb fb90 	bl	8000b50 <HAL_GPIO_Init>
    __HAL_RCC_I2C1_CLK_ENABLE();
 8005430:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005432:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8005436:	6423      	str	r3, [r4, #64]	; 0x40
 8005438:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800543a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800543e:	9301      	str	r3, [sp, #4]
 8005440:	9b01      	ldr	r3, [sp, #4]
}
 8005442:	b00e      	add	sp, #56	; 0x38
 8005444:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005448:	4c31      	ldr	r4, [pc, #196]	; (8005510 <HAL_I2C_MspInit+0x18c>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800544a:	2212      	movs	r2, #18
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 800544c:	2001      	movs	r0, #1
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 800544e:	f44f 6640 	mov.w	r6, #3072	; 0xc00
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005452:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8005454:	2503      	movs	r5, #3
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005456:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005458:	f043 0302 	orr.w	r3, r3, #2
 800545c:	6323      	str	r3, [r4, #48]	; 0x30
 800545e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8005460:	920a      	str	r2, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 8005462:	2204      	movs	r2, #4
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8005464:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005468:	900b      	str	r0, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800546a:	482b      	ldr	r0, [pc, #172]	; (8005518 <HAL_I2C_MspInit+0x194>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800546c:	9302      	str	r3, [sp, #8]
 800546e:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 8005470:	9609      	str	r6, [sp, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 8005472:	e9cd 520c 	strd	r5, r2, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8005476:	f7fb fb6b 	bl	8000b50 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
 800547a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800547c:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8005480:	6423      	str	r3, [r4, #64]	; 0x40
 8005482:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005484:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8005488:	9303      	str	r3, [sp, #12]
 800548a:	9b03      	ldr	r3, [sp, #12]
}
 800548c:	b00e      	add	sp, #56	; 0x38
 800548e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8005492:	4c1f      	ldr	r4, [pc, #124]	; (8005510 <HAL_I2C_MspInit+0x18c>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 8005494:	2504      	movs	r5, #4
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8005496:	2701      	movs	r7, #1
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8005498:	f44f 7200 	mov.w	r2, #512	; 0x200
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800549c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800549e:	f04f 0812 	mov.w	r8, #18
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80054a2:	2603      	movs	r6, #3
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80054a4:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80054a6:	432b      	orrs	r3, r5
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80054a8:	481c      	ldr	r0, [pc, #112]	; (800551c <HAL_I2C_MspInit+0x198>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80054aa:	6323      	str	r3, [r4, #48]	; 0x30
 80054ac:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80054ae:	402b      	ands	r3, r5
 80054b0:	9304      	str	r3, [sp, #16]
 80054b2:	9b04      	ldr	r3, [sp, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80054b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80054b6:	433b      	orrs	r3, r7
 80054b8:	6323      	str	r3, [r4, #48]	; 0x30
 80054ba:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_9;
 80054bc:	9209      	str	r2, [sp, #36]	; 0x24
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80054be:	403b      	ands	r3, r7
 80054c0:	9305      	str	r3, [sp, #20]
 80054c2:	9b05      	ldr	r3, [sp, #20]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80054c4:	e9cd 870a 	strd	r8, r7, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 80054c8:	e9cd 650c 	strd	r6, r5, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80054cc:	f7fb fb40 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_8;
 80054d0:	f44f 7380 	mov.w	r3, #256	; 0x100
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80054d4:	a909      	add	r1, sp, #36	; 0x24
 80054d6:	4812      	ldr	r0, [pc, #72]	; (8005520 <HAL_I2C_MspInit+0x19c>)
    GPIO_InitStruct.Pin = GPIO_PIN_8;
 80054d8:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80054da:	e9cd 870a 	strd	r8, r7, [sp, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 80054de:	e9cd 650c 	strd	r6, r5, [sp, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80054e2:	f7fb fb35 	bl	8000b50 <HAL_GPIO_Init>
    __HAL_RCC_I2C3_CLK_ENABLE();
 80054e6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80054e8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80054ec:	6423      	str	r3, [r4, #64]	; 0x40
 80054ee:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80054f0:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80054f4:	9306      	str	r3, [sp, #24]
 80054f6:	9b06      	ldr	r3, [sp, #24]
}
 80054f8:	b00e      	add	sp, #56	; 0x38
 80054fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80054fe:	bf00      	nop
 8005500:	40005400 	.word	0x40005400
 8005504:	40005800 	.word	0x40005800
 8005508:	40005c00 	.word	0x40005c00
 800550c:	40006000 	.word	0x40006000
 8005510:	40023800 	.word	0x40023800
 8005514:	40020c00 	.word	0x40020c00
 8005518:	40020400 	.word	0x40020400
 800551c:	40020800 	.word	0x40020800
 8005520:	40020000 	.word	0x40020000

08005524 <initializeOutputs>:
						GPIO_TypeDef	  *gpio,
						uint16_t		  pin,
						uint16_t          dirMask,
						outputType        outType)
{
	out->htim = NULL;
 8005524:	4bef      	ldr	r3, [pc, #956]	; (80058e4 <initializeOutputs+0x3c0>)
 8005526:	2200      	movs	r2, #0
	out->hi2c = hi2c;
	out->deviceAddress = deviceAddress;
	out->gpio = gpio;
	out->pin = pin;
	out->dirMask = dirMask;
	out->outType = outType;
 8005528:	2101      	movs	r1, #1
	out->pin = pin;
 800552a:	f8df c3ec 	ldr.w	ip, [pc, #1004]	; 8005918 <initializeOutputs+0x3f4>
	out->deviceAddress = deviceAddress;
 800552e:	2042      	movs	r0, #66	; 0x42
	out->outputEnabled = 0;
	out->isOutputSetByNoteOn = 0;
}

void initializeOutputs()
{
 8005530:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	out->pin = pin;
 8005534:	4fec      	ldr	r7, [pc, #944]	; (80058e8 <initializeOutputs+0x3c4>)
	out->deviceAddress = deviceAddress;
 8005536:	2440      	movs	r4, #64	; 0x40
	out->hi2c = hi2c;
 8005538:	4dec      	ldr	r5, [pc, #944]	; (80058ec <initializeOutputs+0x3c8>)
	out->gpio = gpio;
 800553a:	f8df b3e0 	ldr.w	fp, [pc, #992]	; 800591c <initializeOutputs+0x3f8>
	out->htim = htim;
 800553e:	4eec      	ldr	r6, [pc, #944]	; (80058f0 <initializeOutputs+0x3cc>)
	out->pin = pin;
 8005540:	f8df a3dc 	ldr.w	sl, [pc, #988]	; 8005920 <initializeOutputs+0x3fc>
 8005544:	f8df 93dc 	ldr.w	r9, [pc, #988]	; 8005924 <initializeOutputs+0x400>
 8005548:	615f      	str	r7, [r3, #20]
	out->pin = 0;
 800554a:	f44f 0740 	mov.w	r7, #12582912	; 0xc00000
	out->pin = pin;
 800554e:	f8c3 a030 	str.w	sl, [r3, #48]	; 0x30
 8005552:	f10a 0a18 	add.w	sl, sl, #24
 8005556:	f8c3 904c 	str.w	r9, [r3, #76]	; 0x4c
 800555a:	f1a9 090c 	sub.w	r9, r9, #12
	out->hi2c = hi2c;
 800555e:	609d      	str	r5, [r3, #8]
 8005560:	625d      	str	r5, [r3, #36]	; 0x24
 8005562:	641d      	str	r5, [r3, #64]	; 0x40
	out->hi2c = hi2c;
 8005564:	65dd      	str	r5, [r3, #92]	; 0x5c
	out->deviceAddress = deviceAddress;
 8005566:	731c      	strb	r4, [r3, #12]
 8005568:	f883 4028 	strb.w	r4, [r3, #40]	; 0x28
 800556c:	f883 4044 	strb.w	r4, [r3, #68]	; 0x44
	out->deviceAddress = deviceAddress;
 8005570:	f883 4060 	strb.w	r4, [r3, #96]	; 0x60
	out->htim = htim;
 8005574:	655e      	str	r6, [r3, #84]	; 0x54
	out->htim = NULL;
 8005576:	601a      	str	r2, [r3, #0]
	out->timChannel = 0;
 8005578:	809a      	strh	r2, [r3, #4]
	out->outputEnabled = 0;
 800557a:	769a      	strb	r2, [r3, #26]
	out->isOutputSetByNoteOn = 0;
 800557c:	76da      	strb	r2, [r3, #27]
	out->htim = NULL;
 800557e:	61da      	str	r2, [r3, #28]
	out->timChannel = 0;
 8005580:	841a      	strh	r2, [r3, #32]
	out->outputEnabled = 0;
 8005582:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
	out->isOutputSetByNoteOn = 0;
 8005586:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
	out->htim = NULL;
 800558a:	639a      	str	r2, [r3, #56]	; 0x38
	out->timChannel = 0;
 800558c:	879a      	strh	r2, [r3, #60]	; 0x3c
	out->outputEnabled = 0;
 800558e:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
	out->timChannel = timChannel;
 8005592:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
	out->gpio = NULL;
 8005596:	665a      	str	r2, [r3, #100]	; 0x64
	out->gpio = gpio;
 8005598:	f8c3 b010 	str.w	fp, [r3, #16]
 800559c:	f8c3 b02c 	str.w	fp, [r3, #44]	; 0x2c
 80055a0:	f8c3 b048 	str.w	fp, [r3, #72]	; 0x48
	out->outType = outType;
 80055a4:	7659      	strb	r1, [r3, #25]
 80055a6:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
 80055aa:	f883 1051 	strb.w	r1, [r3, #81]	; 0x51
	out->pin = 0;
 80055ae:	669f      	str	r7, [r3, #104]	; 0x68
 80055b0:	f04f 7740 	mov.w	r7, #50331648	; 0x3000000
	out->htim = htim;
 80055b4:	671e      	str	r6, [r3, #112]	; 0x70
	out->timChannel = timChannel;
 80055b6:	f04f 0604 	mov.w	r6, #4
	out->gpio = gpio;
 80055ba:	f8df 836c 	ldr.w	r8, [pc, #876]	; 8005928 <initializeOutputs+0x404>
	out->timChannel = timChannel;
 80055be:	f8a3 6074 	strh.w	r6, [r3, #116]	; 0x74
	out->pin = 0;
 80055c2:	f04f 7640 	mov.w	r6, #50331648	; 0x3000000
	out->pin = pin;
 80055c6:	f8df e364 	ldr.w	lr, [pc, #868]	; 800592c <initializeOutputs+0x408>
	out->pin = 0;
 80055ca:	f8c3 6084 	str.w	r6, [r3, #132]	; 0x84
	out->pin = pin;
 80055ce:	4ec9      	ldr	r6, [pc, #804]	; (80058f4 <initializeOutputs+0x3d0>)
	out->hi2c = hi2c;
 80055d0:	679d      	str	r5, [r3, #120]	; 0x78
	out->deviceAddress = deviceAddress;
 80055d2:	f883 407c 	strb.w	r4, [r3, #124]	; 0x7c
	out->hi2c = hi2c;
 80055d6:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
	out->deviceAddress = deviceAddress;
 80055da:	f883 4098 	strb.w	r4, [r3, #152]	; 0x98
	out->hi2c = hi2c;
 80055de:	f8c3 50b0 	str.w	r5, [r3, #176]	; 0xb0
	out->deviceAddress = deviceAddress;
 80055e2:	f883 40b4 	strb.w	r4, [r3, #180]	; 0xb4
	out->hi2c = hi2c;
 80055e6:	f8c3 50cc 	str.w	r5, [r3, #204]	; 0xcc
	out->deviceAddress = deviceAddress;
 80055ea:	f883 40d0 	strb.w	r4, [r3, #208]	; 0xd0
	out->pin = pin;
 80055ee:	f8c3 e0a0 	str.w	lr, [r3, #160]	; 0xa0
 80055f2:	f8c3 c0bc 	str.w	ip, [r3, #188]	; 0xbc
	out->gpio = gpio;
 80055f6:	f8c3 809c 	str.w	r8, [r3, #156]	; 0x9c
	out->outType = outType;
 80055fa:	f883 106d 	strb.w	r1, [r3, #109]	; 0x6d
	out->outputEnabled = 0;
 80055fe:	f8a3 206e 	strh.w	r2, [r3, #110]	; 0x6e
	out->gpio = NULL;
 8005602:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	out->outType = outType;
 8005606:	f883 1089 	strb.w	r1, [r3, #137]	; 0x89
	out->outputEnabled = 0;
 800560a:	f883 208a 	strb.w	r2, [r3, #138]	; 0x8a
	out->isOutputSetByNoteOn = 0;
 800560e:	f883 208b 	strb.w	r2, [r3, #139]	; 0x8b
	out->htim = NULL;
 8005612:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	out->timChannel = 0;
 8005616:	f8a3 2090 	strh.w	r2, [r3, #144]	; 0x90
	out->outType = outType;
 800561a:	f883 10a5 	strb.w	r1, [r3, #165]	; 0xa5
	out->outputEnabled = 0;
 800561e:	f883 20a6 	strb.w	r2, [r3, #166]	; 0xa6
	out->isOutputSetByNoteOn = 0;
 8005622:	f883 20a7 	strb.w	r2, [r3, #167]	; 0xa7
	out->htim = NULL;
 8005626:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	out->timChannel = 0;
 800562a:	f8a3 20ac 	strh.w	r2, [r3, #172]	; 0xac
	out->outType = outType;
 800562e:	f883 10c1 	strb.w	r1, [r3, #193]	; 0xc1
	out->outputEnabled = 0;
 8005632:	f883 20c2 	strb.w	r2, [r3, #194]	; 0xc2
	out->isOutputSetByNoteOn = 0;
 8005636:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3
	out->htim = NULL;
 800563a:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
	out->timChannel = 0;
 800563e:	f8a3 20c8 	strh.w	r2, [r3, #200]	; 0xc8
	out->gpio = gpio;
 8005642:	f8c3 80b8 	str.w	r8, [r3, #184]	; 0xb8
	out->pin = pin;
 8005646:	f8c3 60d8 	str.w	r6, [r3, #216]	; 0xd8
 800564a:	4eab      	ldr	r6, [pc, #684]	; (80058f8 <initializeOutputs+0x3d4>)
	out->htim = htim;
 800564c:	f8df c2e0 	ldr.w	ip, [pc, #736]	; 8005930 <initializeOutputs+0x40c>
	out->pin = pin;
 8005650:	f8c3 60f4 	str.w	r6, [r3, #244]	; 0xf4
 8005654:	4ea9      	ldr	r6, [pc, #676]	; (80058fc <initializeOutputs+0x3d8>)
	out->gpio = gpio;
 8005656:	f8c3 80d4 	str.w	r8, [r3, #212]	; 0xd4
	out->hi2c = hi2c;
 800565a:	f8c3 50e8 	str.w	r5, [r3, #232]	; 0xe8
	out->gpio = gpio;
 800565e:	f8c3 80f0 	str.w	r8, [r3, #240]	; 0xf0
	out->hi2c = hi2c;
 8005662:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104
	out->gpio = gpio;
 8005666:	f8c3 810c 	str.w	r8, [r3, #268]	; 0x10c
	out->hi2c = hi2c;
 800566a:	f8c3 5120 	str.w	r5, [r3, #288]	; 0x120
	out->gpio = gpio;
 800566e:	f8c3 8128 	str.w	r8, [r3, #296]	; 0x128
	out->pin = pin;
 8005672:	f8c3 6110 	str.w	r6, [r3, #272]	; 0x110
 8005676:	f8c3 912c 	str.w	r9, [r3, #300]	; 0x12c
	out->outType = outType;
 800567a:	f883 10dd 	strb.w	r1, [r3, #221]	; 0xdd
	out->outputEnabled = 0;
 800567e:	f883 20de 	strb.w	r2, [r3, #222]	; 0xde
	out->isOutputSetByNoteOn = 0;
 8005682:	f883 20df 	strb.w	r2, [r3, #223]	; 0xdf
	out->htim = NULL;
 8005686:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
	out->timChannel = 0;
 800568a:	f8a3 20e4 	strh.w	r2, [r3, #228]	; 0xe4
	out->outType = outType;
 800568e:	f883 10f9 	strb.w	r1, [r3, #249]	; 0xf9
	out->outputEnabled = 0;
 8005692:	f883 20fa 	strb.w	r2, [r3, #250]	; 0xfa
	out->isOutputSetByNoteOn = 0;
 8005696:	f883 20fb 	strb.w	r2, [r3, #251]	; 0xfb
	out->htim = NULL;
 800569a:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
	out->timChannel = 0;
 800569e:	f8a3 2100 	strh.w	r2, [r3, #256]	; 0x100
	out->outType = outType;
 80056a2:	f883 1115 	strb.w	r1, [r3, #277]	; 0x115
	out->outputEnabled = 0;
 80056a6:	f883 2116 	strb.w	r2, [r3, #278]	; 0x116
	out->isOutputSetByNoteOn = 0;
 80056aa:	f883 2117 	strb.w	r2, [r3, #279]	; 0x117
	out->htim = NULL;
 80056ae:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	out->timChannel = 0;
 80056b2:	f8a3 211c 	strh.w	r2, [r3, #284]	; 0x11c
	out->outType = outType;
 80056b6:	f883 1131 	strb.w	r1, [r3, #305]	; 0x131
	out->outputEnabled = 0;
 80056ba:	f883 2132 	strb.w	r2, [r3, #306]	; 0x132
	out->isOutputSetByNoteOn = 0;
 80056be:	f883 2133 	strb.w	r2, [r3, #307]	; 0x133
	out->htim = NULL;
 80056c2:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
	out->deviceAddress = deviceAddress;
 80056c6:	f883 00ec 	strb.w	r0, [r3, #236]	; 0xec
 80056ca:	f883 0108 	strb.w	r0, [r3, #264]	; 0x108
 80056ce:	f883 0124 	strb.w	r0, [r3, #292]	; 0x124
	out->pin = 0;
 80056d2:	f8c3 7164 	str.w	r7, [r3, #356]	; 0x164
	out->timChannel = timChannel;
 80056d6:	f04f 0704 	mov.w	r7, #4
	out->htim = htim;
 80056da:	f8c3 c150 	str.w	ip, [r3, #336]	; 0x150
	out->timChannel = timChannel;
 80056de:	f8a3 7170 	strh.w	r7, [r3, #368]	; 0x170
	out->pin = 0;
 80056e2:	f04f 5740 	mov.w	r7, #805306368	; 0x30000000
	out->htim = htim;
 80056e6:	f8c3 c16c 	str.w	ip, [r3, #364]	; 0x16c
 80056ea:	f8c3 c188 	str.w	ip, [r3, #392]	; 0x188
 80056ee:	f8c3 c1a4 	str.w	ip, [r3, #420]	; 0x1a4
	out->pin = 0;
 80056f2:	f04f 6c40 	mov.w	ip, #201326592	; 0xc000000
	out->pin = pin;
 80056f6:	f8df e23c 	ldr.w	lr, [pc, #572]	; 8005934 <initializeOutputs+0x410>
	out->pin = 0;
 80056fa:	f8c3 c180 	str.w	ip, [r3, #384]	; 0x180
	out->timChannel = timChannel;
 80056fe:	f04f 0c08 	mov.w	ip, #8
	out->pin = 0;
 8005702:	f8c3 719c 	str.w	r7, [r3, #412]	; 0x19c
	out->timChannel = timChannel;
 8005706:	f04f 070c 	mov.w	r7, #12
	out->hi2c = hi2c;
 800570a:	f8c3 513c 	str.w	r5, [r3, #316]	; 0x13c
	out->gpio = gpio;
 800570e:	f8c3 8144 	str.w	r8, [r3, #324]	; 0x144
	out->hi2c = hi2c;
 8005712:	f8c3 5158 	str.w	r5, [r3, #344]	; 0x158
 8005716:	f8c3 5174 	str.w	r5, [r3, #372]	; 0x174
 800571a:	f8c3 5190 	str.w	r5, [r3, #400]	; 0x190
	out->pin = pin;
 800571e:	f8c3 e148 	str.w	lr, [r3, #328]	; 0x148
	out->timChannel = timChannel;
 8005722:	f8a3 c18c 	strh.w	ip, [r3, #396]	; 0x18c
	out->timChannel = 0;
 8005726:	f8a3 2138 	strh.w	r2, [r3, #312]	; 0x138
	out->deviceAddress = deviceAddress;
 800572a:	f883 0140 	strb.w	r0, [r3, #320]	; 0x140
	out->outType = outType;
 800572e:	f883 114d 	strb.w	r1, [r3, #333]	; 0x14d
	out->outputEnabled = 0;
 8005732:	f8a3 214e 	strh.w	r2, [r3, #334]	; 0x14e
	out->timChannel = timChannel;
 8005736:	f8a3 2154 	strh.w	r2, [r3, #340]	; 0x154
	out->deviceAddress = deviceAddress;
 800573a:	f883 015c 	strb.w	r0, [r3, #348]	; 0x15c
	out->gpio = NULL;
 800573e:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
	out->outType = outType;
 8005742:	f883 1169 	strb.w	r1, [r3, #361]	; 0x169
	out->outputEnabled = 0;
 8005746:	f8a3 216a 	strh.w	r2, [r3, #362]	; 0x16a
	out->deviceAddress = deviceAddress;
 800574a:	f883 0178 	strb.w	r0, [r3, #376]	; 0x178
	out->gpio = NULL;
 800574e:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
	out->outType = outType;
 8005752:	f883 1185 	strb.w	r1, [r3, #389]	; 0x185
	out->outputEnabled = 0;
 8005756:	f8a3 2186 	strh.w	r2, [r3, #390]	; 0x186
	out->deviceAddress = deviceAddress;
 800575a:	f883 0194 	strb.w	r0, [r3, #404]	; 0x194
	out->gpio = NULL;
 800575e:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
	out->outType = outType;
 8005762:	f883 11a1 	strb.w	r1, [r3, #417]	; 0x1a1
	out->outputEnabled = 0;
 8005766:	f8a3 21a2 	strh.w	r2, [r3, #418]	; 0x1a2
	out->timChannel = timChannel;
 800576a:	f8a3 71a8 	strh.w	r7, [r3, #424]	; 0x1a8
	out->hi2c = hi2c;
 800576e:	f8c3 51ac 	str.w	r5, [r3, #428]	; 0x1ac
	out->pin = pin;
 8005772:	4d63      	ldr	r5, [pc, #396]	; (8005900 <initializeOutputs+0x3dc>)
	out->hi2c = hi2c;
 8005774:	4e63      	ldr	r6, [pc, #396]	; (8005904 <initializeOutputs+0x3e0>)
	out->pin = pin;
 8005776:	f8c3 51d4 	str.w	r5, [r3, #468]	; 0x1d4
	out->pin = 0;
 800577a:	f04f 4540 	mov.w	r5, #3221225472	; 0xc0000000
	out->pin = pin;
 800577e:	f8c3 a1f0 	str.w	sl, [r3, #496]	; 0x1f0
	out->pin = 0;
 8005782:	f44f 1a40 	mov.w	sl, #3145728	; 0x300000
 8005786:	f8c3 51b8 	str.w	r5, [r3, #440]	; 0x1b8
	out->htim = htim;
 800578a:	4d5f      	ldr	r5, [pc, #380]	; (8005908 <initializeOutputs+0x3e4>)
	out->deviceAddress = deviceAddress;
 800578c:	f883 41cc 	strb.w	r4, [r3, #460]	; 0x1cc
	out->gpio = gpio;
 8005790:	f8c3 81d0 	str.w	r8, [r3, #464]	; 0x1d0
	out->deviceAddress = deviceAddress;
 8005794:	f883 41e8 	strb.w	r4, [r3, #488]	; 0x1e8
	out->gpio = gpio;
 8005798:	f8c3 81ec 	str.w	r8, [r3, #492]	; 0x1ec
	out->timChannel = timChannel;
 800579c:	f8a3 c1fc 	strh.w	ip, [r3, #508]	; 0x1fc
	out->deviceAddress = deviceAddress;
 80057a0:	f883 4204 	strb.w	r4, [r3, #516]	; 0x204
	out->hi2c = hi2c;
 80057a4:	f8c3 61c8 	str.w	r6, [r3, #456]	; 0x1c8
 80057a8:	f8c3 61e4 	str.w	r6, [r3, #484]	; 0x1e4
	out->hi2c = hi2c;
 80057ac:	f8c3 6200 	str.w	r6, [r3, #512]	; 0x200
	out->htim = htim;
 80057b0:	f8c3 51f8 	str.w	r5, [r3, #504]	; 0x1f8
 80057b4:	f8c3 5214 	str.w	r5, [r3, #532]	; 0x214
	out->pin = 0;
 80057b8:	f44f 0540 	mov.w	r5, #12582912	; 0xc00000
	out->deviceAddress = deviceAddress;
 80057bc:	f883 01b0 	strb.w	r0, [r3, #432]	; 0x1b0
	out->gpio = NULL;
 80057c0:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
	out->outType = outType;
 80057c4:	f883 11bd 	strb.w	r1, [r3, #445]	; 0x1bd
	out->outputEnabled = 0;
 80057c8:	f883 21be 	strb.w	r2, [r3, #446]	; 0x1be
	out->isOutputSetByNoteOn = 0;
 80057cc:	f883 21bf 	strb.w	r2, [r3, #447]	; 0x1bf
	out->htim = NULL;
 80057d0:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
	out->timChannel = 0;
 80057d4:	f8a3 21c4 	strh.w	r2, [r3, #452]	; 0x1c4
	out->outType = outType;
 80057d8:	f883 11d9 	strb.w	r1, [r3, #473]	; 0x1d9
	out->outputEnabled = 0;
 80057dc:	f883 21da 	strb.w	r2, [r3, #474]	; 0x1da
	out->isOutputSetByNoteOn = 0;
 80057e0:	f883 21db 	strb.w	r2, [r3, #475]	; 0x1db
	out->htim = NULL;
 80057e4:	f8c3 21dc 	str.w	r2, [r3, #476]	; 0x1dc
	out->timChannel = 0;
 80057e8:	f8a3 21e0 	strh.w	r2, [r3, #480]	; 0x1e0
	out->outType = outType;
 80057ec:	f883 11f5 	strb.w	r1, [r3, #501]	; 0x1f5
	out->outputEnabled = 0;
 80057f0:	f8a3 21f6 	strh.w	r2, [r3, #502]	; 0x1f6
	out->gpio = NULL;
 80057f4:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
	out->outType = outType;
 80057f8:	f883 1211 	strb.w	r1, [r3, #529]	; 0x211
	out->outputEnabled = 0;
 80057fc:	f8a3 2212 	strh.w	r2, [r3, #530]	; 0x212
	out->pin = 0;
 8005800:	f8c3 a20c 	str.w	sl, [r3, #524]	; 0x20c
	out->timChannel = timChannel;
 8005804:	f8a3 7218 	strh.w	r7, [r3, #536]	; 0x218
	out->pin = pin;
 8005808:	4f40      	ldr	r7, [pc, #256]	; (800590c <initializeOutputs+0x3e8>)
 800580a:	f8df e12c 	ldr.w	lr, [pc, #300]	; 8005938 <initializeOutputs+0x414>
 800580e:	f8df 912c 	ldr.w	r9, [pc, #300]	; 800593c <initializeOutputs+0x418>
 8005812:	f8c3 727c 	str.w	r7, [r3, #636]	; 0x27c
	out->gpio = gpio;
 8005816:	4f3e      	ldr	r7, [pc, #248]	; (8005910 <initializeOutputs+0x3ec>)
	out->hi2c = hi2c;
 8005818:	f8c3 621c 	str.w	r6, [r3, #540]	; 0x21c
	out->deviceAddress = deviceAddress;
 800581c:	f883 4220 	strb.w	r4, [r3, #544]	; 0x220
	out->pin = 0;
 8005820:	f8c3 5228 	str.w	r5, [r3, #552]	; 0x228
	out->hi2c = hi2c;
 8005824:	f8c3 6238 	str.w	r6, [r3, #568]	; 0x238
	out->deviceAddress = deviceAddress;
 8005828:	f883 423c 	strb.w	r4, [r3, #572]	; 0x23c
	out->hi2c = hi2c;
 800582c:	f8c3 6254 	str.w	r6, [r3, #596]	; 0x254
	out->deviceAddress = deviceAddress;
 8005830:	f883 4258 	strb.w	r4, [r3, #600]	; 0x258
	out->hi2c = hi2c;
 8005834:	f8c3 6270 	str.w	r6, [r3, #624]	; 0x270
	out->deviceAddress = deviceAddress;
 8005838:	f883 4274 	strb.w	r4, [r3, #628]	; 0x274
	out->pin = pin;
 800583c:	f8c3 e244 	str.w	lr, [r3, #580]	; 0x244
	out->pin = 0;
 8005840:	f04f 4e40 	mov.w	lr, #3221225472	; 0xc0000000
	out->pin = pin;
 8005844:	f8c3 9260 	str.w	r9, [r3, #608]	; 0x260
	out->gpio = NULL;
 8005848:	f8c3 2224 	str.w	r2, [r3, #548]	; 0x224
	out->outType = outType;
 800584c:	f883 122d 	strb.w	r1, [r3, #557]	; 0x22d
	out->outputEnabled = 0;
 8005850:	f883 222e 	strb.w	r2, [r3, #558]	; 0x22e
	out->isOutputSetByNoteOn = 0;
 8005854:	f883 222f 	strb.w	r2, [r3, #559]	; 0x22f
	out->htim = NULL;
 8005858:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
	out->timChannel = 0;
 800585c:	f8a3 2234 	strh.w	r2, [r3, #564]	; 0x234
	out->outType = outType;
 8005860:	f883 1249 	strb.w	r1, [r3, #585]	; 0x249
	out->outputEnabled = 0;
 8005864:	f883 224a 	strb.w	r2, [r3, #586]	; 0x24a
	out->isOutputSetByNoteOn = 0;
 8005868:	f883 224b 	strb.w	r2, [r3, #587]	; 0x24b
	out->htim = NULL;
 800586c:	f8c3 224c 	str.w	r2, [r3, #588]	; 0x24c
	out->timChannel = 0;
 8005870:	f8a3 2250 	strh.w	r2, [r3, #592]	; 0x250
	out->gpio = gpio;
 8005874:	f8c3 b25c 	str.w	fp, [r3, #604]	; 0x25c
	out->outType = outType;
 8005878:	f883 1265 	strb.w	r1, [r3, #613]	; 0x265
	out->outputEnabled = 0;
 800587c:	f883 2266 	strb.w	r2, [r3, #614]	; 0x266
	out->isOutputSetByNoteOn = 0;
 8005880:	f883 2267 	strb.w	r2, [r3, #615]	; 0x267
	out->htim = NULL;
 8005884:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
	out->timChannel = 0;
 8005888:	f8a3 226c 	strh.w	r2, [r3, #620]	; 0x26c
	out->gpio = gpio;
 800588c:	f8c3 b278 	str.w	fp, [r3, #632]	; 0x278
	out->outType = outType;
 8005890:	f883 1281 	strb.w	r1, [r3, #641]	; 0x281
	out->gpio = gpio;
 8005894:	f8c3 7240 	str.w	r7, [r3, #576]	; 0x240
	out->timChannel = timChannel;
 8005898:	f04f 0704 	mov.w	r7, #4
	out->htim = htim;
 800589c:	4d1d      	ldr	r5, [pc, #116]	; (8005914 <initializeOutputs+0x3f0>)
	out->pin = pin;
 800589e:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 8005940 <initializeOutputs+0x41c>
	out->pin = 0;
 80058a2:	f8c3 e298 	str.w	lr, [r3, #664]	; 0x298
	out->pin = pin;
 80058a6:	f44f 3e41 	mov.w	lr, #197632	; 0x30400
	out->timChannel = timChannel;
 80058aa:	f8a3 72c0 	strh.w	r7, [r3, #704]	; 0x2c0
	out->pin = 0;
 80058ae:	f44f 2740 	mov.w	r7, #786432	; 0xc0000
	out->hi2c = hi2c;
 80058b2:	f8c3 628c 	str.w	r6, [r3, #652]	; 0x28c
	out->deviceAddress = deviceAddress;
 80058b6:	f883 4290 	strb.w	r4, [r3, #656]	; 0x290
	out->hi2c = hi2c;
 80058ba:	f8c3 62a8 	str.w	r6, [r3, #680]	; 0x2a8
	out->hi2c = hi2c;
 80058be:	f8c3 62c4 	str.w	r6, [r3, #708]	; 0x2c4
	out->hi2c = hi2c;
 80058c2:	f8c3 62e0 	str.w	r6, [r3, #736]	; 0x2e0
	out->pin = pin;
 80058c6:	f8c3 e2b4 	str.w	lr, [r3, #692]	; 0x2b4
 80058ca:	f8c3 c2ec 	str.w	ip, [r3, #748]	; 0x2ec
	out->timChannel = timChannel;
 80058ce:	f04f 0c08 	mov.w	ip, #8
	out->htim = htim;
 80058d2:	f8c3 5284 	str.w	r5, [r3, #644]	; 0x284
 80058d6:	f8c3 52bc 	str.w	r5, [r3, #700]	; 0x2bc
	out->outputEnabled = 0;
 80058da:	f8a3 2282 	strh.w	r2, [r3, #642]	; 0x282
	out->timChannel = timChannel;
 80058de:	f8a3 2288 	strh.w	r2, [r3, #648]	; 0x288
 80058e2:	e02f      	b.n	8005944 <initializeOutputs+0x420>
 80058e4:	20000834 	.word	0x20000834
 80058e8:	00030004 	.word	0x00030004
 80058ec:	20000778 	.word	0x20000778
 80058f0:	2000117c 	.word	0x2000117c
 80058f4:	c0008000 	.word	0xc0008000
 80058f8:	00030001 	.word	0x00030001
 80058fc:	000c0002 	.word	0x000c0002
 8005900:	00030010 	.word	0x00030010
 8005904:	200007c4 	.word	0x200007c4
 8005908:	2000103c 	.word	0x2000103c
 800590c:	30000100 	.word	0x30000100
 8005910:	40020400 	.word	0x40020400
 8005914:	2000113c 	.word	0x2000113c
 8005918:	30004000 	.word	0x30004000
 800591c:	40021000 	.word	0x40021000
 8005920:	000c0008 	.word	0x000c0008
 8005924:	00300010 	.word	0x00300010
 8005928:	40020800 	.word	0x40020800
 800592c:	0c002000 	.word	0x0c002000
 8005930:	20000ffc 	.word	0x20000ffc
 8005934:	00c00008 	.word	0x00c00008
 8005938:	03000004 	.word	0x03000004
 800593c:	0c000080 	.word	0x0c000080
 8005940:	00301000 	.word	0x00301000
	out->gpio = NULL;
 8005944:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
	out->outType = outType;
 8005948:	f883 129d 	strb.w	r1, [r3, #669]	; 0x29d
	out->outputEnabled = 0;
 800594c:	f883 229e 	strb.w	r2, [r3, #670]	; 0x29e
	out->isOutputSetByNoteOn = 0;
 8005950:	f883 229f 	strb.w	r2, [r3, #671]	; 0x29f
	out->htim = NULL;
 8005954:	f8c3 22a0 	str.w	r2, [r3, #672]	; 0x2a0
	out->timChannel = 0;
 8005958:	f8a3 22a4 	strh.w	r2, [r3, #676]	; 0x2a4
	out->deviceAddress = deviceAddress;
 800595c:	f883 02ac 	strb.w	r0, [r3, #684]	; 0x2ac
	out->gpio = gpio;
 8005960:	f8c3 b2b0 	str.w	fp, [r3, #688]	; 0x2b0
	out->outType = outType;
 8005964:	f883 12b9 	strb.w	r1, [r3, #697]	; 0x2b9
	out->outputEnabled = 0;
 8005968:	f8a3 22ba 	strh.w	r2, [r3, #698]	; 0x2ba
	out->deviceAddress = deviceAddress;
 800596c:	f883 02c8 	strb.w	r0, [r3, #712]	; 0x2c8
	out->gpio = NULL;
 8005970:	f8c3 22cc 	str.w	r2, [r3, #716]	; 0x2cc
	out->outType = outType;
 8005974:	f883 12d5 	strb.w	r1, [r3, #725]	; 0x2d5
	out->outputEnabled = 0;
 8005978:	f883 22d6 	strb.w	r2, [r3, #726]	; 0x2d6
	out->isOutputSetByNoteOn = 0;
 800597c:	f883 22d7 	strb.w	r2, [r3, #727]	; 0x2d7
	out->htim = NULL;
 8005980:	f8c3 22d8 	str.w	r2, [r3, #728]	; 0x2d8
	out->timChannel = 0;
 8005984:	f8a3 22dc 	strh.w	r2, [r3, #732]	; 0x2dc
	out->deviceAddress = deviceAddress;
 8005988:	f883 02e4 	strb.w	r0, [r3, #740]	; 0x2e4
	out->gpio = gpio;
 800598c:	f8c3 b2e8 	str.w	fp, [r3, #744]	; 0x2e8
	out->pin = 0;
 8005990:	f8c3 72d0 	str.w	r7, [r3, #720]	; 0x2d0
	out->timChannel = timChannel;
 8005994:	f04f 070c 	mov.w	r7, #12
	out->htim = htim;
 8005998:	f8c3 52f4 	str.w	r5, [r3, #756]	; 0x2f4
 800599c:	f8c3 5310 	str.w	r5, [r3, #784]	; 0x310
	out->pin = 0;
 80059a0:	f04f 7540 	mov.w	r5, #50331648	; 0x3000000
	out->timChannel = timChannel;
 80059a4:	f8a3 7314 	strh.w	r7, [r3, #788]	; 0x314
	out->gpio = gpio;
 80059a8:	f105 5774 	add.w	r7, r5, #1023410176	; 0x3d000000
	out->pin = pin;
 80059ac:	f8df a420 	ldr.w	sl, [pc, #1056]	; 8005dd0 <initializeOutputs+0x8ac>
	out->timChannel = timChannel;
 80059b0:	f8a3 c2f8 	strh.w	ip, [r3, #760]	; 0x2f8
	out->pin = 0;
 80059b4:	f44f 0c40 	mov.w	ip, #12582912	; 0xc00000
	out->gpio = gpio;
 80059b8:	f507 3701 	add.w	r7, r7, #132096	; 0x20400
	out->pin = 0;
 80059bc:	f8c3 5324 	str.w	r5, [r3, #804]	; 0x324
	out->pin = pin;
 80059c0:	4df6      	ldr	r5, [pc, #984]	; (8005d9c <initializeOutputs+0x878>)
 80059c2:	f8df 9410 	ldr.w	r9, [pc, #1040]	; 8005dd4 <initializeOutputs+0x8b0>
	out->hi2c = hi2c;
 80059c6:	f8c3 62fc 	str.w	r6, [r3, #764]	; 0x2fc
	out->pin = 0;
 80059ca:	f8c3 c308 	str.w	ip, [r3, #776]	; 0x308
	out->hi2c = hi2c;
 80059ce:	f8c3 6318 	str.w	r6, [r3, #792]	; 0x318
	out->hi2c = hi2c;
 80059d2:	f8c3 6334 	str.w	r6, [r3, #820]	; 0x334
 80059d6:	f8c3 6350 	str.w	r6, [r3, #848]	; 0x350
	out->gpio = gpio;
 80059da:	f8c3 7358 	str.w	r7, [r3, #856]	; 0x358
	out->outType = outType;
 80059de:	f883 12f1 	strb.w	r1, [r3, #753]	; 0x2f1
	out->outputEnabled = 0;
 80059e2:	f8a3 22f2 	strh.w	r2, [r3, #754]	; 0x2f2
	out->deviceAddress = deviceAddress;
 80059e6:	f883 0300 	strb.w	r0, [r3, #768]	; 0x300
	out->gpio = NULL;
 80059ea:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	out->outType = outType;
 80059ee:	f883 130d 	strb.w	r1, [r3, #781]	; 0x30d
	out->outputEnabled = 0;
 80059f2:	f8a3 230e 	strh.w	r2, [r3, #782]	; 0x30e
	out->deviceAddress = deviceAddress;
 80059f6:	f883 031c 	strb.w	r0, [r3, #796]	; 0x31c
	out->gpio = NULL;
 80059fa:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
	out->outType = outType;
 80059fe:	f883 1329 	strb.w	r1, [r3, #809]	; 0x329
	out->outputEnabled = 0;
 8005a02:	f883 232a 	strb.w	r2, [r3, #810]	; 0x32a
	out->isOutputSetByNoteOn = 0;
 8005a06:	f883 232b 	strb.w	r2, [r3, #811]	; 0x32b
	out->htim = NULL;
 8005a0a:	f8c3 232c 	str.w	r2, [r3, #812]	; 0x32c
	out->timChannel = 0;
 8005a0e:	f8a3 2330 	strh.w	r2, [r3, #816]	; 0x330
	out->deviceAddress = deviceAddress;
 8005a12:	f883 0338 	strb.w	r0, [r3, #824]	; 0x338
	out->gpio = gpio;
 8005a16:	f8c3 b33c 	str.w	fp, [r3, #828]	; 0x33c
	out->outType = outType;
 8005a1a:	f883 1345 	strb.w	r1, [r3, #837]	; 0x345
	out->outputEnabled = 0;
 8005a1e:	f883 2346 	strb.w	r2, [r3, #838]	; 0x346
	out->isOutputSetByNoteOn = 0;
 8005a22:	f883 2347 	strb.w	r2, [r3, #839]	; 0x347
	out->htim = NULL;
 8005a26:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
	out->timChannel = 0;
 8005a2a:	f8a3 234c 	strh.w	r2, [r3, #844]	; 0x34c
	out->deviceAddress = deviceAddress;
 8005a2e:	f883 0354 	strb.w	r0, [r3, #852]	; 0x354
	out->pin = pin;
 8005a32:	f8c3 5340 	str.w	r5, [r3, #832]	; 0x340
 8005a36:	f8c3 a35c 	str.w	sl, [r3, #860]	; 0x35c
	out->timChannel = timChannel;
 8005a3a:	f04f 0a04 	mov.w	sl, #4
	out->hi2c = hi2c;
 8005a3e:	f8df c398 	ldr.w	ip, [pc, #920]	; 8005dd8 <initializeOutputs+0x8b4>
	out->htim = htim;
 8005a42:	f8df e398 	ldr.w	lr, [pc, #920]	; 8005ddc <initializeOutputs+0x8b8>
	out->pin = pin;
 8005a46:	4dd6      	ldr	r5, [pc, #856]	; (8005da0 <initializeOutputs+0x87c>)
	out->timChannel = timChannel;
 8005a48:	f8a3 a3a0 	strh.w	sl, [r3, #928]	; 0x3a0
	out->pin = 0;
 8005a4c:	f44f 2a40 	mov.w	sl, #786432	; 0xc0000
	out->pin = pin;
 8005a50:	f8c3 9378 	str.w	r9, [r3, #888]	; 0x378
	out->pin = 0;
 8005a54:	f44f 3940 	mov.w	r9, #196608	; 0x30000
	out->hi2c = hi2c;
 8005a58:	f8c3 636c 	str.w	r6, [r3, #876]	; 0x36c
	out->gpio = gpio;
 8005a5c:	f8c3 7374 	str.w	r7, [r3, #884]	; 0x374
	out->deviceAddress = deviceAddress;
 8005a60:	f883 438c 	strb.w	r4, [r3, #908]	; 0x38c
 8005a64:	f883 43a8 	strb.w	r4, [r3, #936]	; 0x3a8
	out->pin = 0;
 8005a68:	f8c3 a3b0 	str.w	sl, [r3, #944]	; 0x3b0
	out->deviceAddress = deviceAddress;
 8005a6c:	f883 43c4 	strb.w	r4, [r3, #964]	; 0x3c4
	out->htim = htim;
 8005a70:	f8c3 e380 	str.w	lr, [r3, #896]	; 0x380
 8005a74:	f8c3 e39c 	str.w	lr, [r3, #924]	; 0x39c
	out->timChannel = timChannel;
 8005a78:	f04f 0e08 	mov.w	lr, #8
	out->hi2c = hi2c;
 8005a7c:	f8c3 c388 	str.w	ip, [r3, #904]	; 0x388
 8005a80:	f8c3 c3a4 	str.w	ip, [r3, #932]	; 0x3a4
	out->hi2c = hi2c;
 8005a84:	f8c3 c3c0 	str.w	ip, [r3, #960]	; 0x3c0
	out->outType = outType;
 8005a88:	f883 1361 	strb.w	r1, [r3, #865]	; 0x361
	out->outputEnabled = 0;
 8005a8c:	f883 2362 	strb.w	r2, [r3, #866]	; 0x362
	out->isOutputSetByNoteOn = 0;
 8005a90:	f883 2363 	strb.w	r2, [r3, #867]	; 0x363
	out->htim = NULL;
 8005a94:	f8c3 2364 	str.w	r2, [r3, #868]	; 0x364
	out->timChannel = 0;
 8005a98:	f8a3 2368 	strh.w	r2, [r3, #872]	; 0x368
	out->deviceAddress = deviceAddress;
 8005a9c:	f883 0370 	strb.w	r0, [r3, #880]	; 0x370
	out->outType = outType;
 8005aa0:	f883 137d 	strb.w	r1, [r3, #893]	; 0x37d
	out->outputEnabled = 0;
 8005aa4:	f8a3 237e 	strh.w	r2, [r3, #894]	; 0x37e
	out->timChannel = timChannel;
 8005aa8:	f8a3 2384 	strh.w	r2, [r3, #900]	; 0x384
	out->gpio = NULL;
 8005aac:	f8c3 2390 	str.w	r2, [r3, #912]	; 0x390
	out->outType = outType;
 8005ab0:	f883 1399 	strb.w	r1, [r3, #921]	; 0x399
	out->outputEnabled = 0;
 8005ab4:	f8a3 239a 	strh.w	r2, [r3, #922]	; 0x39a
	out->gpio = NULL;
 8005ab8:	f8c3 23ac 	str.w	r2, [r3, #940]	; 0x3ac
	out->outType = outType;
 8005abc:	f883 13b5 	strb.w	r1, [r3, #949]	; 0x3b5
	out->outputEnabled = 0;
 8005ac0:	f883 23b6 	strb.w	r2, [r3, #950]	; 0x3b6
	out->isOutputSetByNoteOn = 0;
 8005ac4:	f883 23b7 	strb.w	r2, [r3, #951]	; 0x3b7
	out->htim = NULL;
 8005ac8:	f8c3 23b8 	str.w	r2, [r3, #952]	; 0x3b8
	out->timChannel = 0;
 8005acc:	f8a3 23bc 	strh.w	r2, [r3, #956]	; 0x3bc
	out->pin = 0;
 8005ad0:	f8c3 9394 	str.w	r9, [r3, #916]	; 0x394
	out->pin = pin;
 8005ad4:	f8c3 53cc 	str.w	r5, [r3, #972]	; 0x3cc
 8005ad8:	4db2      	ldr	r5, [pc, #712]	; (8005da4 <initializeOutputs+0x880>)
	out->gpio = gpio;
 8005ada:	4eb3      	ldr	r6, [pc, #716]	; (8005da8 <initializeOutputs+0x884>)
	out->pin = pin;
 8005adc:	f8df a300 	ldr.w	sl, [pc, #768]	; 8005de0 <initializeOutputs+0x8bc>
	out->timChannel = timChannel;
 8005ae0:	f8a3 e42c 	strh.w	lr, [r3, #1068]	; 0x42c
	out->pin = 0;
 8005ae4:	f04f 5e40 	mov.w	lr, #805306368	; 0x30000000
	out->pin = pin;
 8005ae8:	f8c3 5420 	str.w	r5, [r3, #1056]	; 0x420
 8005aec:	4faf      	ldr	r7, [pc, #700]	; (8005dac <initializeOutputs+0x888>)
	out->htim = htim;
 8005aee:	4db0      	ldr	r5, [pc, #704]	; (8005db0 <initializeOutputs+0x88c>)
	out->gpio = gpio;
 8005af0:	f8c3 63c8 	str.w	r6, [r3, #968]	; 0x3c8
	out->hi2c = hi2c;
 8005af4:	f8c3 c3dc 	str.w	ip, [r3, #988]	; 0x3dc
	out->deviceAddress = deviceAddress;
 8005af8:	f883 43e0 	strb.w	r4, [r3, #992]	; 0x3e0
	out->gpio = gpio;
 8005afc:	f8c3 63e4 	str.w	r6, [r3, #996]	; 0x3e4
	out->hi2c = hi2c;
 8005b00:	f8c3 c3f8 	str.w	ip, [r3, #1016]	; 0x3f8
	out->deviceAddress = deviceAddress;
 8005b04:	f883 43fc 	strb.w	r4, [r3, #1020]	; 0x3fc
	out->gpio = gpio;
 8005b08:	f8c3 6400 	str.w	r6, [r3, #1024]	; 0x400
	out->hi2c = hi2c;
 8005b0c:	f8c3 c414 	str.w	ip, [r3, #1044]	; 0x414
	out->deviceAddress = deviceAddress;
 8005b10:	f883 4418 	strb.w	r4, [r3, #1048]	; 0x418
	out->gpio = gpio;
 8005b14:	f8c3 641c 	str.w	r6, [r3, #1052]	; 0x41c
	out->pin = pin;
 8005b18:	f8c3 73e8 	str.w	r7, [r3, #1000]	; 0x3e8
	out->timChannel = timChannel;
 8005b1c:	f04f 0704 	mov.w	r7, #4
	out->pin = pin;
 8005b20:	f8c3 a404 	str.w	sl, [r3, #1028]	; 0x404
	out->outType = outType;
 8005b24:	f883 13d1 	strb.w	r1, [r3, #977]	; 0x3d1
	out->outputEnabled = 0;
 8005b28:	f883 23d2 	strb.w	r2, [r3, #978]	; 0x3d2
	out->isOutputSetByNoteOn = 0;
 8005b2c:	f883 23d3 	strb.w	r2, [r3, #979]	; 0x3d3
	out->htim = NULL;
 8005b30:	f8c3 23d4 	str.w	r2, [r3, #980]	; 0x3d4
	out->timChannel = 0;
 8005b34:	f8a3 23d8 	strh.w	r2, [r3, #984]	; 0x3d8
	out->outType = outType;
 8005b38:	f883 13ed 	strb.w	r1, [r3, #1005]	; 0x3ed
	out->outputEnabled = 0;
 8005b3c:	f883 23ee 	strb.w	r2, [r3, #1006]	; 0x3ee
	out->isOutputSetByNoteOn = 0;
 8005b40:	f883 23ef 	strb.w	r2, [r3, #1007]	; 0x3ef
	out->htim = NULL;
 8005b44:	f8c3 23f0 	str.w	r2, [r3, #1008]	; 0x3f0
	out->timChannel = 0;
 8005b48:	f8a3 23f4 	strh.w	r2, [r3, #1012]	; 0x3f4
	out->outType = outType;
 8005b4c:	f883 1409 	strb.w	r1, [r3, #1033]	; 0x409
	out->outputEnabled = 0;
 8005b50:	f883 240a 	strb.w	r2, [r3, #1034]	; 0x40a
	out->isOutputSetByNoteOn = 0;
 8005b54:	f883 240b 	strb.w	r2, [r3, #1035]	; 0x40b
	out->htim = NULL;
 8005b58:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
	out->timChannel = 0;
 8005b5c:	f8a3 2410 	strh.w	r2, [r3, #1040]	; 0x410
	out->outType = outType;
 8005b60:	f883 1425 	strb.w	r1, [r3, #1061]	; 0x425
	out->outputEnabled = 0;
 8005b64:	f8a3 2426 	strh.w	r2, [r3, #1062]	; 0x426
	out->htim = htim;
 8005b68:	f8c3 5428 	str.w	r5, [r3, #1064]	; 0x428
	out->pin = 0;
 8005b6c:	f8c3 e43c 	str.w	lr, [r3, #1084]	; 0x43c
	out->timChannel = timChannel;
 8005b70:	f04f 0e0c 	mov.w	lr, #12
 8005b74:	f8a3 7480 	strh.w	r7, [r3, #1152]	; 0x480
	out->pin = 0;
 8005b78:	f44f 2740 	mov.w	r7, #786432	; 0xc0000
	out->timChannel = timChannel;
 8005b7c:	f8a3 e448 	strh.w	lr, [r3, #1096]	; 0x448
	out->pin = 0;
 8005b80:	f04f 4e40 	mov.w	lr, #3221225472	; 0xc0000000
	out->htim = htim;
 8005b84:	f8df 925c 	ldr.w	r9, [pc, #604]	; 8005de4 <initializeOutputs+0x8c0>
 8005b88:	f8c3 5444 	str.w	r5, [r3, #1092]	; 0x444
	out->timChannel = timChannel;
 8005b8c:	f04f 0508 	mov.w	r5, #8
	out->pin = 0;
 8005b90:	f8c3 e458 	str.w	lr, [r3, #1112]	; 0x458
 8005b94:	f44f 3e40 	mov.w	lr, #196608	; 0x30000
 8005b98:	f8c3 7490 	str.w	r7, [r3, #1168]	; 0x490
	out->pin = pin;
 8005b9c:	4f83      	ldr	r7, [pc, #524]	; (8005dac <initializeOutputs+0x888>)
	out->hi2c = hi2c;
 8005b9e:	f8c3 c430 	str.w	ip, [r3, #1072]	; 0x430
	out->deviceAddress = deviceAddress;
 8005ba2:	f883 4434 	strb.w	r4, [r3, #1076]	; 0x434
	out->hi2c = hi2c;
 8005ba6:	f8c3 c44c 	str.w	ip, [r3, #1100]	; 0x44c
	out->deviceAddress = deviceAddress;
 8005baa:	f883 4450 	strb.w	r4, [r3, #1104]	; 0x450
	out->hi2c = hi2c;
 8005bae:	f8c3 c468 	str.w	ip, [r3, #1128]	; 0x468
	out->pin = 0;
 8005bb2:	f8c3 e474 	str.w	lr, [r3, #1140]	; 0x474
	out->hi2c = hi2c;
 8005bb6:	f8c3 c484 	str.w	ip, [r3, #1156]	; 0x484
	out->timChannel = timChannel;
 8005bba:	f8a3 549c 	strh.w	r5, [r3, #1180]	; 0x49c
	out->hi2c = hi2c;
 8005bbe:	f8c3 c4a0 	str.w	ip, [r3, #1184]	; 0x4a0
	out->htim = htim;
 8005bc2:	f8c3 9460 	str.w	r9, [r3, #1120]	; 0x460
 8005bc6:	f8c3 947c 	str.w	r9, [r3, #1148]	; 0x47c
	out->gpio = NULL;
 8005bca:	f8c3 2438 	str.w	r2, [r3, #1080]	; 0x438
	out->outType = outType;
 8005bce:	f883 1441 	strb.w	r1, [r3, #1089]	; 0x441
	out->outputEnabled = 0;
 8005bd2:	f8a3 2442 	strh.w	r2, [r3, #1090]	; 0x442
	out->gpio = NULL;
 8005bd6:	f8c3 2454 	str.w	r2, [r3, #1108]	; 0x454
	out->outType = outType;
 8005bda:	f883 145d 	strb.w	r1, [r3, #1117]	; 0x45d
	out->outputEnabled = 0;
 8005bde:	f8a3 245e 	strh.w	r2, [r3, #1118]	; 0x45e
	out->timChannel = timChannel;
 8005be2:	f8a3 2464 	strh.w	r2, [r3, #1124]	; 0x464
	out->deviceAddress = deviceAddress;
 8005be6:	f883 046c 	strb.w	r0, [r3, #1132]	; 0x46c
	out->gpio = NULL;
 8005bea:	f8c3 2470 	str.w	r2, [r3, #1136]	; 0x470
	out->outType = outType;
 8005bee:	f883 1479 	strb.w	r1, [r3, #1145]	; 0x479
	out->outputEnabled = 0;
 8005bf2:	f8a3 247a 	strh.w	r2, [r3, #1146]	; 0x47a
	out->deviceAddress = deviceAddress;
 8005bf6:	f883 0488 	strb.w	r0, [r3, #1160]	; 0x488
	out->gpio = NULL;
 8005bfa:	f8c3 248c 	str.w	r2, [r3, #1164]	; 0x48c
	out->outType = outType;
 8005bfe:	f883 1495 	strb.w	r1, [r3, #1173]	; 0x495
	out->outputEnabled = 0;
 8005c02:	f8a3 2496 	strh.w	r2, [r3, #1174]	; 0x496
	out->htim = htim;
 8005c06:	f8c3 9498 	str.w	r9, [r3, #1176]	; 0x498
	out->pin = 0;
 8005c0a:	f44f 1940 	mov.w	r9, #3145728	; 0x300000
	out->pin = pin;
 8005c0e:	f8c3 74c8 	str.w	r7, [r3, #1224]	; 0x4c8
 8005c12:	4f62      	ldr	r7, [pc, #392]	; (8005d9c <initializeOutputs+0x878>)
	out->pin = 0;
 8005c14:	f8c3 94ac 	str.w	r9, [r3, #1196]	; 0x4ac
	out->pin = pin;
 8005c18:	f8c3 7500 	str.w	r7, [r3, #1280]	; 0x500
	out->gpio = gpio;
 8005c1c:	4f65      	ldr	r7, [pc, #404]	; (8005db4 <initializeOutputs+0x890>)
	out->hi2c = hi2c;
 8005c1e:	f8c3 c4bc 	str.w	ip, [r3, #1212]	; 0x4bc
 8005c22:	f8c3 c4d8 	str.w	ip, [r3, #1240]	; 0x4d8
	out->pin = pin;
 8005c26:	f8c3 a4e4 	str.w	sl, [r3, #1252]	; 0x4e4
	out->hi2c = hi2c;
 8005c2a:	f8c3 c4f4 	str.w	ip, [r3, #1268]	; 0x4f4
	out->gpio = gpio;
 8005c2e:	f8c3 74c4 	str.w	r7, [r3, #1220]	; 0x4c4
 8005c32:	f8c3 74e0 	str.w	r7, [r3, #1248]	; 0x4e0
	out->deviceAddress = deviceAddress;
 8005c36:	f883 04a4 	strb.w	r0, [r3, #1188]	; 0x4a4
	out->gpio = NULL;
 8005c3a:	f8c3 24a8 	str.w	r2, [r3, #1192]	; 0x4a8
	out->outType = outType;
 8005c3e:	f883 14b1 	strb.w	r1, [r3, #1201]	; 0x4b1
	out->outputEnabled = 0;
 8005c42:	f883 24b2 	strb.w	r2, [r3, #1202]	; 0x4b2
	out->isOutputSetByNoteOn = 0;
 8005c46:	f883 24b3 	strb.w	r2, [r3, #1203]	; 0x4b3
	out->htim = NULL;
 8005c4a:	f8c3 24b4 	str.w	r2, [r3, #1204]	; 0x4b4
	out->timChannel = 0;
 8005c4e:	f8a3 24b8 	strh.w	r2, [r3, #1208]	; 0x4b8
	out->deviceAddress = deviceAddress;
 8005c52:	f883 04c0 	strb.w	r0, [r3, #1216]	; 0x4c0
	out->outType = outType;
 8005c56:	f883 14cd 	strb.w	r1, [r3, #1229]	; 0x4cd
	out->outputEnabled = 0;
 8005c5a:	f883 24ce 	strb.w	r2, [r3, #1230]	; 0x4ce
	out->isOutputSetByNoteOn = 0;
 8005c5e:	f883 24cf 	strb.w	r2, [r3, #1231]	; 0x4cf
	out->htim = NULL;
 8005c62:	f8c3 24d0 	str.w	r2, [r3, #1232]	; 0x4d0
	out->timChannel = 0;
 8005c66:	f8a3 24d4 	strh.w	r2, [r3, #1236]	; 0x4d4
	out->deviceAddress = deviceAddress;
 8005c6a:	f883 04dc 	strb.w	r0, [r3, #1244]	; 0x4dc
	out->outType = outType;
 8005c6e:	f883 14e9 	strb.w	r1, [r3, #1257]	; 0x4e9
	out->outputEnabled = 0;
 8005c72:	f883 24ea 	strb.w	r2, [r3, #1258]	; 0x4ea
	out->isOutputSetByNoteOn = 0;
 8005c76:	f883 24eb 	strb.w	r2, [r3, #1259]	; 0x4eb
	out->htim = NULL;
 8005c7a:	f8c3 24ec 	str.w	r2, [r3, #1260]	; 0x4ec
	out->timChannel = 0;
 8005c7e:	f8a3 24f0 	strh.w	r2, [r3, #1264]	; 0x4f0
	out->deviceAddress = deviceAddress;
 8005c82:	f883 04f8 	strb.w	r0, [r3, #1272]	; 0x4f8
	out->outType = outType;
 8005c86:	f883 1505 	strb.w	r1, [r3, #1285]	; 0x505
	out->outputEnabled = 0;
 8005c8a:	f883 2506 	strb.w	r2, [r3, #1286]	; 0x506
	out->isOutputSetByNoteOn = 0;
 8005c8e:	f883 2507 	strb.w	r2, [r3, #1287]	; 0x507
	out->gpio = gpio;
 8005c92:	f8c3 74fc 	str.w	r7, [r3, #1276]	; 0x4fc
	out->pin = pin;
 8005c96:	4f48      	ldr	r7, [pc, #288]	; (8005db8 <initializeOutputs+0x894>)
	out->hi2c = hi2c;
 8005c98:	4d48      	ldr	r5, [pc, #288]	; (8005dbc <initializeOutputs+0x898>)
	out->pin = pin;
 8005c9a:	f8c3 751c 	str.w	r7, [r3, #1308]	; 0x51c
 8005c9e:	4f48      	ldr	r7, [pc, #288]	; (8005dc0 <initializeOutputs+0x89c>)
 8005ca0:	f8df e144 	ldr.w	lr, [pc, #324]	; 8005de8 <initializeOutputs+0x8c4>
	out->gpio = gpio;
 8005ca4:	f8c3 8518 	str.w	r8, [r3, #1304]	; 0x518
 8005ca8:	f8c3 8534 	str.w	r8, [r3, #1332]	; 0x534
 8005cac:	f8c3 8550 	str.w	r8, [r3, #1360]	; 0x550
	out->pin = pin;
 8005cb0:	f44f 3844 	mov.w	r8, #200704	; 0x31000
 8005cb4:	f8c3 7538 	str.w	r7, [r3, #1336]	; 0x538
 8005cb8:	4f42      	ldr	r7, [pc, #264]	; (8005dc4 <initializeOutputs+0x8a0>)
	out->hi2c = hi2c;
 8005cba:	f8c3 c510 	str.w	ip, [r3, #1296]	; 0x510
 8005cbe:	f8c3 c52c 	str.w	ip, [r3, #1324]	; 0x52c
	out->deviceAddress = deviceAddress;
 8005cc2:	f883 454c 	strb.w	r4, [r3, #1356]	; 0x54c
 8005cc6:	f883 4568 	strb.w	r4, [r3, #1384]	; 0x568
	out->gpio = gpio;
 8005cca:	f8c3 656c 	str.w	r6, [r3, #1388]	; 0x56c
	out->pin = pin;
 8005cce:	f8c3 8554 	str.w	r8, [r3, #1364]	; 0x554
 8005cd2:	f8c3 e570 	str.w	lr, [r3, #1392]	; 0x570
	out->htim = NULL;
 8005cd6:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	out->timChannel = 0;
 8005cda:	f8a3 250c 	strh.w	r2, [r3, #1292]	; 0x50c
	out->deviceAddress = deviceAddress;
 8005cde:	f883 0514 	strb.w	r0, [r3, #1300]	; 0x514
	out->outType = outType;
 8005ce2:	f883 1521 	strb.w	r1, [r3, #1313]	; 0x521
	out->outputEnabled = 0;
 8005ce6:	f883 2522 	strb.w	r2, [r3, #1314]	; 0x522
	out->isOutputSetByNoteOn = 0;
 8005cea:	f883 2523 	strb.w	r2, [r3, #1315]	; 0x523
	out->htim = NULL;
 8005cee:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	out->timChannel = 0;
 8005cf2:	f8a3 2528 	strh.w	r2, [r3, #1320]	; 0x528
	out->deviceAddress = deviceAddress;
 8005cf6:	f883 0530 	strb.w	r0, [r3, #1328]	; 0x530
	out->outType = outType;
 8005cfa:	f883 153d 	strb.w	r1, [r3, #1341]	; 0x53d
	out->outputEnabled = 0;
 8005cfe:	f883 253e 	strb.w	r2, [r3, #1342]	; 0x53e
	out->isOutputSetByNoteOn = 0;
 8005d02:	f883 253f 	strb.w	r2, [r3, #1343]	; 0x53f
	out->htim = NULL;
 8005d06:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
	out->timChannel = 0;
 8005d0a:	f8a3 2544 	strh.w	r2, [r3, #1348]	; 0x544
	out->outType = outType;
 8005d0e:	f883 1559 	strb.w	r1, [r3, #1369]	; 0x559
	out->outputEnabled = 0;
 8005d12:	f883 255a 	strb.w	r2, [r3, #1370]	; 0x55a
	out->isOutputSetByNoteOn = 0;
 8005d16:	f883 255b 	strb.w	r2, [r3, #1371]	; 0x55b
	out->htim = NULL;
 8005d1a:	f8c3 255c 	str.w	r2, [r3, #1372]	; 0x55c
	out->timChannel = 0;
 8005d1e:	f8a3 2560 	strh.w	r2, [r3, #1376]	; 0x560
	out->hi2c = hi2c;
 8005d22:	f8c3 5548 	str.w	r5, [r3, #1352]	; 0x548
 8005d26:	f8c3 5564 	str.w	r5, [r3, #1380]	; 0x564
	out->pin = pin;
 8005d2a:	f8c3 758c 	str.w	r7, [r3, #1420]	; 0x58c
 8005d2e:	4f26      	ldr	r7, [pc, #152]	; (8005dc8 <initializeOutputs+0x8a4>)
	out->deviceAddress = deviceAddress;
 8005d30:	f883 4584 	strb.w	r4, [r3, #1412]	; 0x584
	out->pin = pin;
 8005d34:	f8c3 75a8 	str.w	r7, [r3, #1448]	; 0x5a8
 8005d38:	4f24      	ldr	r7, [pc, #144]	; (8005dcc <initializeOutputs+0x8a8>)
	out->gpio = gpio;
 8005d3a:	f8c3 6588 	str.w	r6, [r3, #1416]	; 0x588
	out->deviceAddress = deviceAddress;
 8005d3e:	f883 45a0 	strb.w	r4, [r3, #1440]	; 0x5a0
	out->gpio = gpio;
 8005d42:	f8c3 65a4 	str.w	r6, [r3, #1444]	; 0x5a4
	out->deviceAddress = deviceAddress;
 8005d46:	f883 45bc 	strb.w	r4, [r3, #1468]	; 0x5bc
	out->gpio = gpio;
 8005d4a:	f8c3 65c0 	str.w	r6, [r3, #1472]	; 0x5c0
	out->outType = outType;
 8005d4e:	f883 1575 	strb.w	r1, [r3, #1397]	; 0x575
	out->outputEnabled = 0;
 8005d52:	f883 2576 	strb.w	r2, [r3, #1398]	; 0x576
	out->isOutputSetByNoteOn = 0;
 8005d56:	f883 2577 	strb.w	r2, [r3, #1399]	; 0x577
	out->htim = NULL;
 8005d5a:	f8c3 2578 	str.w	r2, [r3, #1400]	; 0x578
	out->timChannel = 0;
 8005d5e:	f8a3 257c 	strh.w	r2, [r3, #1404]	; 0x57c
	out->hi2c = hi2c;
 8005d62:	f8c3 5580 	str.w	r5, [r3, #1408]	; 0x580
	out->outType = outType;
 8005d66:	f883 1591 	strb.w	r1, [r3, #1425]	; 0x591
	out->outputEnabled = 0;
 8005d6a:	f883 2592 	strb.w	r2, [r3, #1426]	; 0x592
	out->isOutputSetByNoteOn = 0;
 8005d6e:	f883 2593 	strb.w	r2, [r3, #1427]	; 0x593
	out->htim = NULL;
 8005d72:	f8c3 2594 	str.w	r2, [r3, #1428]	; 0x594
	out->timChannel = 0;
 8005d76:	f8a3 2598 	strh.w	r2, [r3, #1432]	; 0x598
	out->hi2c = hi2c;
 8005d7a:	f8c3 559c 	str.w	r5, [r3, #1436]	; 0x59c
	out->outType = outType;
 8005d7e:	f883 15ad 	strb.w	r1, [r3, #1453]	; 0x5ad
	out->outputEnabled = 0;
 8005d82:	f883 25ae 	strb.w	r2, [r3, #1454]	; 0x5ae
	out->isOutputSetByNoteOn = 0;
 8005d86:	f883 25af 	strb.w	r2, [r3, #1455]	; 0x5af
	out->htim = NULL;
 8005d8a:	f8c3 25b0 	str.w	r2, [r3, #1456]	; 0x5b0
	out->timChannel = 0;
 8005d8e:	f8a3 25b4 	strh.w	r2, [r3, #1460]	; 0x5b4
	out->hi2c = hi2c;
 8005d92:	f8c3 55b8 	str.w	r5, [r3, #1464]	; 0x5b8
	out->outType = outType;
 8005d96:	f883 15c9 	strb.w	r1, [r3, #1481]	; 0x5c9
 8005d9a:	e027      	b.n	8005dec <initializeOutputs+0x8c8>
 8005d9c:	0c008000 	.word	0x0c008000
 8005da0:	00300100 	.word	0x00300100
 8005da4:	0c000800 	.word	0x0c000800
 8005da8:	40020c00 	.word	0x40020c00
 8005dac:	00c00200 	.word	0x00c00200
 8005db0:	20000f7c 	.word	0x20000f7c
 8005db4:	40020000 	.word	0x40020000
 8005db8:	30000400 	.word	0x30000400
 8005dbc:	2000072c 	.word	0x2000072c
 8005dc0:	c0000800 	.word	0xc0000800
 8005dc4:	00300002 	.word	0x00300002
 8005dc8:	00c00004 	.word	0x00c00004
 8005dcc:	03000008 	.word	0x03000008
 8005dd0:	30001000 	.word	0x30001000
 8005dd4:	c0002000 	.word	0xc0002000
 8005dd8:	200006e0 	.word	0x200006e0
 8005ddc:	2000123c 	.word	0x2000123c
 8005de0:	03000400 	.word	0x03000400
 8005de4:	20000f3c 	.word	0x20000f3c
 8005de8:	000c0001 	.word	0x000c0001
	out->outputEnabled = 0;
 8005dec:	f883 25ca 	strb.w	r2, [r3, #1482]	; 0x5ca
	out->isOutputSetByNoteOn = 0;
 8005df0:	f883 25cb 	strb.w	r2, [r3, #1483]	; 0x5cb
	out->htim = NULL;
 8005df4:	f8c3 25cc 	str.w	r2, [r3, #1484]	; 0x5cc
	out->timChannel = 0;
 8005df8:	f8a3 25d0 	strh.w	r2, [r3, #1488]	; 0x5d0
	out->hi2c = hi2c;
 8005dfc:	f8c3 55d4 	str.w	r5, [r3, #1492]	; 0x5d4
	out->pin = pin;
 8005e00:	f8c3 75c4 	str.w	r7, [r3, #1476]	; 0x5c4
	out->timChannel = timChannel;
 8005e04:	f04f 0704 	mov.w	r7, #4
	out->gpio = gpio;
 8005e08:	f8c3 65dc 	str.w	r6, [r3, #1500]	; 0x5dc
 8005e0c:	f8c3 65f8 	str.w	r6, [r3, #1528]	; 0x5f8
 8005e10:	f8c3 6614 	str.w	r6, [r3, #1556]	; 0x614
 8005e14:	f8c3 6630 	str.w	r6, [r3, #1584]	; 0x630
	out->pin = pin;
 8005e18:	4e63      	ldr	r6, [pc, #396]	; (8005fa8 <initializeOutputs+0xa84>)
 8005e1a:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 8005fbc <initializeOutputs+0xa98>
	out->deviceAddress = deviceAddress;
 8005e1e:	f883 45d8 	strb.w	r4, [r3, #1496]	; 0x5d8
 8005e22:	f883 45f4 	strb.w	r4, [r3, #1524]	; 0x5f4
 8005e26:	f883 4610 	strb.w	r4, [r3, #1552]	; 0x610
	out->pin = pin;
 8005e2a:	f8c3 65e0 	str.w	r6, [r3, #1504]	; 0x5e0
	out->htim = htim;
 8005e2e:	4c5f      	ldr	r4, [pc, #380]	; (8005fac <initializeOutputs+0xa88>)
	out->pin = pin;
 8005e30:	4e5f      	ldr	r6, [pc, #380]	; (8005fb0 <initializeOutputs+0xa8c>)
 8005e32:	f8df a18c 	ldr.w	sl, [pc, #396]	; 8005fc0 <initializeOutputs+0xa9c>
	out->htim = htim;
 8005e36:	f8df 918c 	ldr.w	r9, [pc, #396]	; 8005fc4 <initializeOutputs+0xaa0>
	out->pin = pin;
 8005e3a:	f8c3 6618 	str.w	r6, [r3, #1560]	; 0x618
	out->pin = 0;
 8005e3e:	f44f 2640 	mov.w	r6, #786432	; 0xc0000
	out->outType = outType;
 8005e42:	f883 15e5 	strb.w	r1, [r3, #1509]	; 0x5e5
	out->outputEnabled = 0;
 8005e46:	f883 25e6 	strb.w	r2, [r3, #1510]	; 0x5e6
	out->isOutputSetByNoteOn = 0;
 8005e4a:	f883 25e7 	strb.w	r2, [r3, #1511]	; 0x5e7
	out->htim = NULL;
 8005e4e:	f8c3 25e8 	str.w	r2, [r3, #1512]	; 0x5e8
	out->timChannel = 0;
 8005e52:	f8a3 25ec 	strh.w	r2, [r3, #1516]	; 0x5ec
	out->hi2c = hi2c;
 8005e56:	f8c3 55f0 	str.w	r5, [r3, #1520]	; 0x5f0
	out->outType = outType;
 8005e5a:	f883 1601 	strb.w	r1, [r3, #1537]	; 0x601
	out->outputEnabled = 0;
 8005e5e:	f883 2602 	strb.w	r2, [r3, #1538]	; 0x602
	out->isOutputSetByNoteOn = 0;
 8005e62:	f883 2603 	strb.w	r2, [r3, #1539]	; 0x603
	out->htim = NULL;
 8005e66:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
	out->timChannel = 0;
 8005e6a:	f8a3 2608 	strh.w	r2, [r3, #1544]	; 0x608
	out->hi2c = hi2c;
 8005e6e:	f8c3 560c 	str.w	r5, [r3, #1548]	; 0x60c
	out->outType = outType;
 8005e72:	f883 161d 	strb.w	r1, [r3, #1565]	; 0x61d
	out->outputEnabled = 0;
 8005e76:	f883 261e 	strb.w	r2, [r3, #1566]	; 0x61e
	out->isOutputSetByNoteOn = 0;
 8005e7a:	f883 261f 	strb.w	r2, [r3, #1567]	; 0x61f
	out->htim = NULL;
 8005e7e:	f8c3 2620 	str.w	r2, [r3, #1568]	; 0x620
	out->timChannel = 0;
 8005e82:	f8a3 2624 	strh.w	r2, [r3, #1572]	; 0x624
	out->hi2c = hi2c;
 8005e86:	f8c3 5628 	str.w	r5, [r3, #1576]	; 0x628
	out->deviceAddress = deviceAddress;
 8005e8a:	f883 062c 	strb.w	r0, [r3, #1580]	; 0x62c
	out->outType = outType;
 8005e8e:	f883 1639 	strb.w	r1, [r3, #1593]	; 0x639
	out->outputEnabled = 0;
 8005e92:	f8a3 263a 	strh.w	r2, [r3, #1594]	; 0x63a
	out->pin = pin;
 8005e96:	f8c3 a634 	str.w	sl, [r3, #1588]	; 0x634
	out->htim = htim;
 8005e9a:	f8c3 963c 	str.w	r9, [r3, #1596]	; 0x63c
	out->pin = pin;
 8005e9e:	f8c3 c5fc 	str.w	ip, [r3, #1532]	; 0x5fc
	out->htim = htim;
 8005ea2:	f8c3 4658 	str.w	r4, [r3, #1624]	; 0x658
 8005ea6:	f8c3 4674 	str.w	r4, [r3, #1652]	; 0x674
	out->pin = 0;
 8005eaa:	f44f 0440 	mov.w	r4, #12582912	; 0xc00000
 8005eae:	f8c3 6650 	str.w	r6, [r3, #1616]	; 0x650
 8005eb2:	f44f 1640 	mov.w	r6, #3145728	; 0x300000
 8005eb6:	f8c3 4688 	str.w	r4, [r3, #1672]	; 0x688
 8005eba:	f04f 7440 	mov.w	r4, #50331648	; 0x3000000
	out->htim = htim;
 8005ebe:	f8df 8108 	ldr.w	r8, [pc, #264]	; 8005fc8 <initializeOutputs+0xaa4>
	out->pin = 0;
 8005ec2:	f8c3 46a4 	str.w	r4, [r3, #1700]	; 0x6a4
	out->htim = htim;
 8005ec6:	4c3b      	ldr	r4, [pc, #236]	; (8005fb4 <initializeOutputs+0xa90>)
	out->pin = pin;
 8005ec8:	f8df e100 	ldr.w	lr, [pc, #256]	; 8005fcc <initializeOutputs+0xaa8>
	out->htim = htim;
 8005ecc:	f8c3 4690 	str.w	r4, [r3, #1680]	; 0x690
	out->pin = 0;
 8005ed0:	f04f 6440 	mov.w	r4, #201326592	; 0xc000000
	out->timChannel = timChannel;
 8005ed4:	f8a3 7640 	strh.w	r7, [r3, #1600]	; 0x640
	out->hi2c = hi2c;
 8005ed8:	f8c3 5644 	str.w	r5, [r3, #1604]	; 0x644
	out->deviceAddress = deviceAddress;
 8005edc:	f883 0648 	strb.w	r0, [r3, #1608]	; 0x648
	out->gpio = NULL;
 8005ee0:	f8c3 264c 	str.w	r2, [r3, #1612]	; 0x64c
	out->outType = outType;
 8005ee4:	f883 1655 	strb.w	r1, [r3, #1621]	; 0x655
	out->outputEnabled = 0;
 8005ee8:	f8a3 2656 	strh.w	r2, [r3, #1622]	; 0x656
	out->timChannel = timChannel;
 8005eec:	f8a3 265c 	strh.w	r2, [r3, #1628]	; 0x65c
	out->hi2c = hi2c;
 8005ef0:	f8c3 5660 	str.w	r5, [r3, #1632]	; 0x660
	out->deviceAddress = deviceAddress;
 8005ef4:	f883 0664 	strb.w	r0, [r3, #1636]	; 0x664
	out->gpio = NULL;
 8005ef8:	f8c3 2668 	str.w	r2, [r3, #1640]	; 0x668
	out->pin = 0;
 8005efc:	f8c3 666c 	str.w	r6, [r3, #1644]	; 0x66c
	out->outType = outType;
 8005f00:	f883 1671 	strb.w	r1, [r3, #1649]	; 0x671
	out->outputEnabled = 0;
 8005f04:	f8a3 2672 	strh.w	r2, [r3, #1650]	; 0x672
	out->timChannel = timChannel;
 8005f08:	f8a3 7678 	strh.w	r7, [r3, #1656]	; 0x678
	out->hi2c = hi2c;
 8005f0c:	f8c3 567c 	str.w	r5, [r3, #1660]	; 0x67c
	out->deviceAddress = deviceAddress;
 8005f10:	f883 0680 	strb.w	r0, [r3, #1664]	; 0x680
	out->gpio = NULL;
 8005f14:	f8c3 2684 	str.w	r2, [r3, #1668]	; 0x684
	out->outType = outType;
 8005f18:	f883 168d 	strb.w	r1, [r3, #1677]	; 0x68d
	out->outputEnabled = 0;
 8005f1c:	f8a3 268e 	strh.w	r2, [r3, #1678]	; 0x68e
	out->timChannel = timChannel;
 8005f20:	f8a3 2694 	strh.w	r2, [r3, #1684]	; 0x694
	out->hi2c = hi2c;
 8005f24:	f8c3 5698 	str.w	r5, [r3, #1688]	; 0x698
	out->deviceAddress = deviceAddress;
 8005f28:	f883 069c 	strb.w	r0, [r3, #1692]	; 0x69c
	out->gpio = NULL;
 8005f2c:	f8c3 26a0 	str.w	r2, [r3, #1696]	; 0x6a0
	out->outType = outType;
 8005f30:	f883 16a9 	strb.w	r1, [r3, #1705]	; 0x6a9
	out->outputEnabled = 0;
 8005f34:	f8a3 26aa 	strh.w	r2, [r3, #1706]	; 0x6aa
	out->timChannel = timChannel;
 8005f38:	f8a3 26b0 	strh.w	r2, [r3, #1712]	; 0x6b0
	out->htim = htim;
 8005f3c:	f8c3 86ac 	str.w	r8, [r3, #1708]	; 0x6ac
	out->pin = 0;
 8005f40:	f8c3 46c0 	str.w	r4, [r3, #1728]	; 0x6c0
	out->gpio = gpio;
 8005f44:	4c1c      	ldr	r4, [pc, #112]	; (8005fb8 <initializeOutputs+0xa94>)
	out->hi2c = hi2c;
 8005f46:	f8c3 56b4 	str.w	r5, [r3, #1716]	; 0x6b4
	out->deviceAddress = deviceAddress;
 8005f4a:	f883 06b8 	strb.w	r0, [r3, #1720]	; 0x6b8
	out->gpio = NULL;
 8005f4e:	f8c3 26bc 	str.w	r2, [r3, #1724]	; 0x6bc
	out->outType = outType;
 8005f52:	f883 16c5 	strb.w	r1, [r3, #1733]	; 0x6c5
	out->outputEnabled = 0;
 8005f56:	f883 26c6 	strb.w	r2, [r3, #1734]	; 0x6c6
	out->isOutputSetByNoteOn = 0;
 8005f5a:	f883 26c7 	strb.w	r2, [r3, #1735]	; 0x6c7
	out->htim = NULL;
 8005f5e:	f8c3 26c8 	str.w	r2, [r3, #1736]	; 0x6c8
	out->timChannel = 0;
 8005f62:	f8a3 26cc 	strh.w	r2, [r3, #1740]	; 0x6cc
	out->hi2c = hi2c;
 8005f66:	f8c3 56d0 	str.w	r5, [r3, #1744]	; 0x6d0
	out->deviceAddress = deviceAddress;
 8005f6a:	f883 06d4 	strb.w	r0, [r3, #1748]	; 0x6d4
	out->gpio = gpio;
 8005f6e:	f8c3 46d8 	str.w	r4, [r3, #1752]	; 0x6d8
	out->pin = pin;
 8005f72:	f8c3 c6dc 	str.w	ip, [r3, #1756]	; 0x6dc
	out->outType = outType;
 8005f76:	f883 16e1 	strb.w	r1, [r3, #1761]	; 0x6e1
	out->outputEnabled = 0;
 8005f7a:	f883 26e2 	strb.w	r2, [r3, #1762]	; 0x6e2
	out->isOutputSetByNoteOn = 0;
 8005f7e:	f883 26e3 	strb.w	r2, [r3, #1763]	; 0x6e3
	out->htim = NULL;
 8005f82:	f8c3 26e4 	str.w	r2, [r3, #1764]	; 0x6e4
	out->timChannel = 0;
 8005f86:	f8a3 26e8 	strh.w	r2, [r3, #1768]	; 0x6e8
	out->hi2c = hi2c;
 8005f8a:	f8c3 56ec 	str.w	r5, [r3, #1772]	; 0x6ec
	out->deviceAddress = deviceAddress;
 8005f8e:	f883 06f0 	strb.w	r0, [r3, #1776]	; 0x6f0
	out->gpio = gpio;
 8005f92:	f8c3 b6f4 	str.w	fp, [r3, #1780]	; 0x6f4
	out->outType = outType;
 8005f96:	f883 16fd 	strb.w	r1, [r3, #1789]	; 0x6fd
	out->outputEnabled = 0;
 8005f9a:	f8a3 26fe 	strh.w	r2, [r3, #1790]	; 0x6fe
	out->pin = pin;
 8005f9e:	f8c3 e6f8 	str.w	lr, [r3, #1784]	; 0x6f8
	setupOutputHardPWM(&outputs[59], &htim3, TIM_CHANNEL_2, &hi2c4, PCAL6416A_ADDR_VCC_W, 0x00C0, oneDirectionPWM);
	setupOutputHardPWM(&outputs[60], &htim10, TIM_CHANNEL_1, &hi2c4, PCAL6416A_ADDR_VCC_W, 0x0300, oneDirectionPWM);
	setupOutputHardPWM(&outputs[61], &htim11, TIM_CHANNEL_1, &hi2c4, PCAL6416A_ADDR_VCC_W, 0x0C00, oneDirectionPWM);
	setupOutputSoftPWM(&outputs[62], &hi2c4, PCAL6416A_ADDR_VCC_W, PWM63_GPIO_Port, PWM63_Pin, 0x3000, oneDirectionPWM);
	setupOutputSoftPWM(&outputs[63], &hi2c4, PCAL6416A_ADDR_VCC_W, PWM64_GPIO_Port, PWM64_Pin, 0xC000, oneDirectionPWM);
}
 8005fa2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005fa6:	bf00      	nop
 8005fa8:	0c000010 	.word	0x0c000010
 8005fac:	2000103c 	.word	0x2000103c
 8005fb0:	c0000040 	.word	0xc0000040
 8005fb4:	20000fbc 	.word	0x20000fbc
 8005fb8:	40020000 	.word	0x40020000
 8005fbc:	30000020 	.word	0x30000020
 8005fc0:	00030080 	.word	0x00030080
 8005fc4:	200011bc 	.word	0x200011bc
 8005fc8:	200010bc 	.word	0x200010bc
 8005fcc:	c0000002 	.word	0xc0000002

08005fd0 <setBidirectionalPWM>:
		break;
	}
}

void setBidirectionalPWM(outputParams *out, uint8_t pwmValue, uint8_t channel)
{
 8005fd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005fd4:	4607      	mov	r7, r0
 8005fd6:	b084      	sub	sp, #16
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, 0, 0 };
 8005fd8:	2002      	movs	r0, #2
 8005fda:	2300      	movs	r3, #0
 8005fdc:	f8b7 c016 	ldrh.w	ip, [r7, #22]
	if(pwmValue >= 64)
 8005fe0:	293f      	cmp	r1, #63	; 0x3f
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, 0, 0 };
 8005fe2:	f8ad 000c 	strh.w	r0, [sp, #12]
 8005fe6:	ea4f 02d2 	mov.w	r2, r2, lsr #3
 8005fea:	fa4f fe8c 	sxtb.w	lr, ip
 8005fee:	f88d 300e 	strb.w	r3, [sp, #14]
 8005ff2:	f34c 2c07 	sbfx	ip, ip, #8, #8
	{
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8005ff6:	484c      	ldr	r0, [pc, #304]	; (8006128 <setBidirectionalPWM+0x158>)
	if(pwmValue >= 64)
 8005ff8:	d936      	bls.n	8006068 <setBidirectionalPWM+0x98>
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
		i2cOutputsConfig[channel/8][0] = txBuff[1];
		i2cOutputsConfig[channel/8][1] = txBuff[2];
		pwmValue -= 64;
 8005ffa:	f1a1 0340 	sub.w	r3, r1, #64	; 0x40
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8005ffe:	eb00 0842 	add.w	r8, r0, r2, lsl #1
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006002:	f810 1012 	ldrb.w	r1, [r0, r2, lsl #1]
		pwmValue -= 64;
 8006006:	b2de      	uxtb	r6, r3
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006008:	f898 3001 	ldrb.w	r3, [r8, #1]
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 800600c:	b249      	sxtb	r1, r1
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 800600e:	b25b      	sxtb	r3, r3
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006010:	f081 04aa 	eor.w	r4, r1, #170	; 0xaa
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006014:	f083 05aa 	eor.w	r5, r3, #170	; 0xaa
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006018:	ea0e 0404 	and.w	r4, lr, r4
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 800601c:	ea0c 0505 	and.w	r5, ip, r5
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006020:	404c      	eors	r4, r1
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006022:	405d      	eors	r5, r3
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006024:	b2e4      	uxtb	r4, r4
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006026:	b2ed      	uxtb	r5, r5
		i2cOutputsConfig[channel/8][0] = txBuff[1];
 8006028:	f800 4012 	strb.w	r4, [r0, r2, lsl #1]
		i2cOutputsConfig[channel/8][1] = txBuff[2];
 800602c:	f888 5001 	strb.w	r5, [r8, #1]
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
		i2cOutputsConfig[channel/8][0] = txBuff[1];
		i2cOutputsConfig[channel/8][1] = txBuff[2];
		pwmValue = 64 - pwmValue;
	}
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 8006030:	2364      	movs	r3, #100	; 0x64
 8006032:	7b39      	ldrb	r1, [r7, #12]
 8006034:	68b8      	ldr	r0, [r7, #8]
 8006036:	aa03      	add	r2, sp, #12
 8006038:	9300      	str	r3, [sp, #0]
 800603a:	2303      	movs	r3, #3
 800603c:	f88d 500e 	strb.w	r5, [sp, #14]
 8006040:	f88d 400d 	strb.w	r4, [sp, #13]
 8006044:	f7fa ffb2 	bl	8000fac <HAL_I2C_Master_Transmit>
	if(out->htim != NULL)
 8006048:	683a      	ldr	r2, [r7, #0]
 800604a:	bb4a      	cbnz	r2, 80060a0 <setBidirectionalPWM+0xd0>
	{
		setHardPWM(out->htim, out->timChannel, pwmValue*2);
	}
	else
	{
		out->pwmFill = MAX_SOFT_PWM_VAL * pwmValue/63 ;
 800604c:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 8006050:	4a36      	ldr	r2, [pc, #216]	; (800612c <setBidirectionalPWM+0x15c>)
 8006052:	009b      	lsls	r3, r3, #2
 8006054:	fb82 1203 	smull	r1, r2, r2, r3
 8006058:	17d9      	asrs	r1, r3, #31
 800605a:	4413      	add	r3, r2
 800605c:	ebc1 1363 	rsb	r3, r1, r3, asr #5
 8006060:	763b      	strb	r3, [r7, #24]
	}
}
 8006062:	b004      	add	sp, #16
 8006064:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pwmValue = 64 - pwmValue;
 8006068:	f1c1 0340 	rsb	r3, r1, #64	; 0x40
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 800606c:	eb00 0142 	add.w	r1, r0, r2, lsl #1
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006070:	f810 4012 	ldrb.w	r4, [r0, r2, lsl #1]
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006074:	784d      	ldrb	r5, [r1, #1]
		pwmValue = 64 - pwmValue;
 8006076:	b2de      	uxtb	r6, r3
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006078:	b264      	sxtb	r4, r4
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 800607a:	b26d      	sxtb	r5, r5
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 800607c:	f084 0855 	eor.w	r8, r4, #85	; 0x55
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006080:	f085 0355 	eor.w	r3, r5, #85	; 0x55
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006084:	ea0e 0e08 	and.w	lr, lr, r8
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006088:	ea0c 0c03 	and.w	ip, ip, r3
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 800608c:	ea84 040e 	eor.w	r4, r4, lr
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006090:	ea85 050c 	eor.w	r5, r5, ip
		txBuff[1] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006094:	b2e4      	uxtb	r4, r4
		txBuff[2] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_2) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006096:	b2ed      	uxtb	r5, r5
		i2cOutputsConfig[channel/8][0] = txBuff[1];
 8006098:	f800 4012 	strb.w	r4, [r0, r2, lsl #1]
		i2cOutputsConfig[channel/8][1] = txBuff[2];
 800609c:	704d      	strb	r5, [r1, #1]
 800609e:	e7c7      	b.n	8006030 <setBidirectionalPWM+0x60>
		setHardPWM(out->htim, out->timChannel, pwmValue*2);
 80060a0:	0073      	lsls	r3, r6, #1
	switch(timChannel)
 80060a2:	88b9      	ldrh	r1, [r7, #4]
		setHardPWM(out->htim, out->timChannel, pwmValue*2);
 80060a4:	b2db      	uxtb	r3, r3
	switch(timChannel)
 80060a6:	2914      	cmp	r1, #20
 80060a8:	d8db      	bhi.n	8006062 <setBidirectionalPWM+0x92>
 80060aa:	a001      	add	r0, pc, #4	; (adr r0, 80060b0 <setBidirectionalPWM+0xe0>)
 80060ac:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
 80060b0:	08006123 	.word	0x08006123
 80060b4:	08006063 	.word	0x08006063
 80060b8:	08006063 	.word	0x08006063
 80060bc:	08006063 	.word	0x08006063
 80060c0:	0800611d 	.word	0x0800611d
 80060c4:	08006063 	.word	0x08006063
 80060c8:	08006063 	.word	0x08006063
 80060cc:	08006063 	.word	0x08006063
 80060d0:	08006117 	.word	0x08006117
 80060d4:	08006063 	.word	0x08006063
 80060d8:	08006063 	.word	0x08006063
 80060dc:	08006063 	.word	0x08006063
 80060e0:	08006111 	.word	0x08006111
 80060e4:	08006063 	.word	0x08006063
 80060e8:	08006063 	.word	0x08006063
 80060ec:	08006063 	.word	0x08006063
 80060f0:	0800610b 	.word	0x0800610b
 80060f4:	08006063 	.word	0x08006063
 80060f8:	08006063 	.word	0x08006063
 80060fc:	08006063 	.word	0x08006063
 8006100:	08006105 	.word	0x08006105
		htim->Instance->CCR6 = pwmValue;
 8006104:	6812      	ldr	r2, [r2, #0]
 8006106:	65d3      	str	r3, [r2, #92]	; 0x5c
 8006108:	e7ab      	b.n	8006062 <setBidirectionalPWM+0x92>
		htim->Instance->CCR5 = pwmValue;
 800610a:	6812      	ldr	r2, [r2, #0]
 800610c:	6593      	str	r3, [r2, #88]	; 0x58
 800610e:	e7a8      	b.n	8006062 <setBidirectionalPWM+0x92>
		htim->Instance->CCR4 = pwmValue;
 8006110:	6812      	ldr	r2, [r2, #0]
 8006112:	6413      	str	r3, [r2, #64]	; 0x40
 8006114:	e7a5      	b.n	8006062 <setBidirectionalPWM+0x92>
		htim->Instance->CCR3 = pwmValue;
 8006116:	6812      	ldr	r2, [r2, #0]
 8006118:	63d3      	str	r3, [r2, #60]	; 0x3c
 800611a:	e7a2      	b.n	8006062 <setBidirectionalPWM+0x92>
		htim->Instance->CCR2 = pwmValue;
 800611c:	6812      	ldr	r2, [r2, #0]
 800611e:	6393      	str	r3, [r2, #56]	; 0x38
 8006120:	e79f      	b.n	8006062 <setBidirectionalPWM+0x92>
		htim->Instance->CCR1 = pwmValue;
 8006122:	6812      	ldr	r2, [r2, #0]
 8006124:	6353      	str	r3, [r2, #52]	; 0x34
 8006126:	e79c      	b.n	8006062 <setBidirectionalPWM+0x92>
 8006128:	20000810 	.word	0x20000810
 800612c:	82082083 	.word	0x82082083

08006130 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8006130:	b570      	push	{r4, r5, r6, lr}
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8006132:	2400      	movs	r4, #0
{
 8006134:	b0b4      	sub	sp, #208	; 0xd0
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8006136:	2284      	movs	r2, #132	; 0x84
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8006138:	2502      	movs	r5, #2
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800613a:	4621      	mov	r1, r4
 800613c:	a813      	add	r0, sp, #76	; 0x4c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800613e:	9409      	str	r4, [sp, #36]	; 0x24
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8006140:	2601      	movs	r6, #1
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8006142:	9402      	str	r4, [sp, #8]
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8006144:	940c      	str	r4, [sp, #48]	; 0x30
 8006146:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800614a:	e9cd 4403 	strd	r4, r4, [sp, #12]
 800614e:	e9cd 4405 	strd	r4, r4, [sp, #20]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8006152:	f002 ff9f 	bl	8009094 <memset>
  __HAL_RCC_PWR_CLK_ENABLE();
 8006156:	4b22      	ldr	r3, [pc, #136]	; (80061e0 <SystemClock_Config+0xb0>)
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8006158:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800615c:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  __HAL_RCC_PWR_CLK_ENABLE();
 8006160:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006162:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8006166:	641a      	str	r2, [r3, #64]	; 0x40
 8006168:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800616a:	f5a3 33e4 	sub.w	r3, r3, #116736	; 0x1c800
  __HAL_RCC_PWR_CLK_ENABLE();
 800616e:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8006172:	9200      	str	r2, [sp, #0]
 8006174:	9a00      	ldr	r2, [sp, #0]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8006176:	681a      	ldr	r2, [r3, #0]
 8006178:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800617c:	601a      	str	r2, [r3, #0]
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 432;
 800617e:	f44f 72d8 	mov.w	r2, #432	; 0x1b0
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8006182:	681b      	ldr	r3, [r3, #0]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8006184:	9108      	str	r1, [sp, #32]
  RCC_OscInitStruct.PLL.PLLM = 25;
 8006186:	2119      	movs	r1, #25
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8006188:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800618c:	900e      	str	r0, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 9;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800618e:	a807      	add	r0, sp, #28
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8006190:	9607      	str	r6, [sp, #28]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8006192:	9301      	str	r3, [sp, #4]
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8006194:	260f      	movs	r6, #15
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8006196:	9b01      	ldr	r3, [sp, #4]
  RCC_OscInitStruct.PLL.PLLQ = 9;
 8006198:	2309      	movs	r3, #9
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800619a:	950d      	str	r5, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLQ = 9;
 800619c:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800619e:	9511      	str	r5, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLN = 432;
 80061a0:	e9cd 120f 	strd	r1, r2, [sp, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80061a4:	f7fb fe28 	bl	8001df8 <HAL_RCC_OscConfig>
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 80061a8:	f7fb fdea 	bl	8001d80 <HAL_PWREx_EnableOverDrive>
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80061ac:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80061b0:	f44f 5380 	mov.w	r3, #4096	; 0x1000

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 80061b4:	2107      	movs	r1, #7
 80061b6:	a802      	add	r0, sp, #8
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80061b8:	9503      	str	r5, [sp, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80061ba:	9404      	str	r4, [sp, #16]
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80061bc:	9602      	str	r6, [sp, #8]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80061be:	e9cd 2305 	strd	r2, r3, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
 80061c2:	f7fb ffe5 	bl	8002190 <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART8|RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_I2C2
 80061c6:	4b07      	ldr	r3, [pc, #28]	; (80061e4 <SystemClock_Config+0xb4>)
  PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
  PeriphClkInitStruct.I2c3ClockSelection = RCC_I2C3CLKSOURCE_PCLK1;
  PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_PCLK1;
  PeriphClkInitStruct.Uart8ClockSelection = RCC_UART8CLKSOURCE_PCLK1;
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLL;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80061c8:	a813      	add	r0, sp, #76	; 0x4c
  PeriphClkInitStruct.Uart8ClockSelection = RCC_UART8CLKSOURCE_PCLK1;
 80061ca:	942b      	str	r4, [sp, #172]	; 0xac
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLL;
 80061cc:	9432      	str	r4, [sp, #200]	; 0xc8
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART8|RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_I2C2
 80061ce:	9313      	str	r3, [sp, #76]	; 0x4c
  PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
 80061d0:	e9cd 442c 	strd	r4, r4, [sp, #176]	; 0xb0
  PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_PCLK1;
 80061d4:	e9cd 442e 	strd	r4, r4, [sp, #184]	; 0xb8
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80061d8:	f7fc f8fe 	bl	80023d8 <HAL_RCCEx_PeriphCLKConfig>
  {
    Error_Handler();
  }
}
 80061dc:	b034      	add	sp, #208	; 0xd0
 80061de:	bd70      	pop	{r4, r5, r6, pc}
 80061e0:	40023800 	.word	0x40023800
 80061e4:	0023e000 	.word	0x0023e000

080061e8 <main>:
{
 80061e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t pcal6416aConfig[3] = { 0x06, 0x00, 0x00 };
 80061ec:	2306      	movs	r3, #6
 80061ee:	2400      	movs	r4, #0
	initFifo(&fifo);
 80061f0:	48ca      	ldr	r0, [pc, #808]	; (800651c <main+0x334>)
	rxBuff = 0;
 80061f2:	4dcb      	ldr	r5, [pc, #812]	; (8006520 <main+0x338>)
{
 80061f4:	ed2d 8b06 	vpush	{d8-d10}
 80061f8:	b095      	sub	sp, #84	; 0x54
	uint8_t pcal6416aConfig[3] = { 0x06, 0x00, 0x00 };
 80061fa:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
 80061fe:	f88d 4036 	strb.w	r4, [sp, #54]	; 0x36
	initFifo(&fifo);
 8006202:	f7fe fed9 	bl	8004fb8 <initFifo>
	uint8_t txMidiMessage[4][4] = {{ MIDI_STATUS_CC, MIDI_STATUS_CC << 4, 1, 0 },
 8006206:	4bc7      	ldr	r3, [pc, #796]	; (8006524 <main+0x33c>)
	rxBuff = 0;
 8006208:	702c      	strb	r4, [r5, #0]
	uint8_t txMidiMessage[4][4] = {{ MIDI_STATUS_CC, MIDI_STATUS_CC << 4, 1, 0 },
 800620a:	ad10      	add	r5, sp, #64	; 0x40
 800620c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800620e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8006212:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8006216:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 800621a:	4ac3      	ldr	r2, [pc, #780]	; (8006528 <main+0x340>)
 800621c:	f8c2 4250 	str.w	r4, [r2, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8006220:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8006224:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8006228:	6953      	ldr	r3, [r2, #20]
 800622a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800622e:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8006230:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8006234:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8006238:	f8c2 4084 	str.w	r4, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 800623c:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 8006240:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8006244:	f643 77e0 	movw	r7, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8006248:	f3c3 05c9 	ubfx	r5, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 800624c:	f3c3 334e 	ubfx	r3, r3, #13, #15
 8006250:	07ae      	lsls	r6, r5, #30
 8006252:	015b      	lsls	r3, r3, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8006254:	ea03 0c07 	and.w	ip, r3, r7
 8006258:	4630      	mov	r0, r6
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 800625a:	4629      	mov	r1, r5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800625c:	ea40 040c 	orr.w	r4, r0, ip
      } while (ways-- != 0U);
 8006260:	3901      	subs	r1, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8006262:	f100 4040 	add.w	r0, r0, #3221225472	; 0xc0000000
 8006266:	f8c2 4260 	str.w	r4, [r2, #608]	; 0x260
      } while (ways-- != 0U);
 800626a:	1c4c      	adds	r4, r1, #1
 800626c:	d1f6      	bne.n	800625c <main+0x74>
 800626e:	3b20      	subs	r3, #32
    } while(sets-- != 0U);
 8006270:	f113 0f20 	cmn.w	r3, #32
 8006274:	d1ee      	bne.n	8006254 <main+0x6c>
 8006276:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 800627a:	6953      	ldr	r3, [r2, #20]
 800627c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8006280:	6153      	str	r3, [r2, #20]
 8006282:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8006286:	f3bf 8f6f 	isb	sy
	uint32_t lastSystickVal = 0;
 800628a:	f04f 0b00 	mov.w	fp, #0
  HAL_Init();
 800628e:	f7fa f95b 	bl	8000548 <HAL_Init>
  HAL_I2C_Master_Transmit(&hi2c1, PCAL6416A_ADDR_GND_W ,pcal6416aConfig, ARRAY_SIZE(pcal6416aConfig), 100);
 8006292:	2664      	movs	r6, #100	; 0x64
  SystemClock_Config();
 8006294:	f7ff ff4c 	bl	8006130 <SystemClock_Config>
  MX_GPIO_Init();
 8006298:	f7fe fef0 	bl	800507c <MX_GPIO_Init>
	lpfData lpfAdc2 = {0, 0.1};
 800629c:	ed9f 8aa3 	vldr	s16, [pc, #652]	; 800652c <main+0x344>
  MX_I2C1_Init();
 80062a0:	f7fe ffb8 	bl	8005214 <MX_I2C1_Init>
	uint8_t adcConvNum = 0;
 80062a4:	465d      	mov	r5, fp
  MX_I2C2_Init();
 80062a6:	f7fe ffe3 	bl	8005270 <MX_I2C2_Init>
	lpfData lpfAdc1 = {0, 0.1};
 80062aa:	eeb0 9a48 	vmov.f32	s18, s16
  MX_I2C3_Init();
 80062ae:	f7ff f80d 	bl	80052cc <MX_I2C3_Init>
	lpfData lpfAdc0 = {0, 0.1};
 80062b2:	eef0 8a48 	vmov.f32	s17, s16
  MX_I2C4_Init();
 80062b6:	f7ff f837 	bl	8005328 <MX_I2C4_Init>
	 filterData->lastData = filterData->lastData - (filterData->LPF_Beta * (filterData->lastData - inputValue));
 80062ba:	ed9f aa9d 	vldr	s20, [pc, #628]	; 8006530 <main+0x348>
  MX_TIM1_Init();
 80062be:	f000 fcc3 	bl	8006c48 <MX_TIM1_Init>
	 if(filterData->lastData > 255)
 80062c2:	eddf 9a9c 	vldr	s19, [pc, #624]	; 8006534 <main+0x34c>
  MX_TIM2_Init();
 80062c6:	f000 fe4b 	bl	8006f60 <MX_TIM2_Init>
	uint8_t lastAdcConvNum = 123;
 80062ca:	277b      	movs	r7, #123	; 0x7b
  MX_TIM3_Init();
 80062cc:	f000 ffb8 	bl	8007240 <MX_TIM3_Init>
 80062d0:	f8df 8288 	ldr.w	r8, [pc, #648]	; 800655c <main+0x374>
  MX_TIM4_Init();
 80062d4:	f001 f93c 	bl	8007550 <MX_TIM4_Init>
 80062d8:	f8df 9284 	ldr.w	r9, [pc, #644]	; 8006560 <main+0x378>
  MX_TIM5_Init();
 80062dc:	f001 faa8 	bl	8007830 <MX_TIM5_Init>
	uint8_t pressedCount = 0;
 80062e0:	f8cd b018 	str.w	fp, [sp, #24]
  MX_TIM8_Init();
 80062e4:	f001 fb24 	bl	8007930 <MX_TIM8_Init>
	uint8_t pressedDownFlag = 0;
 80062e8:	f8cd b010 	str.w	fp, [sp, #16]
  MX_TIM9_Init();
 80062ec:	f001 fcc0 	bl	8007c70 <MX_TIM9_Init>
	uint8_t momentarySwithWasPressed = 0;
 80062f0:	f8cd b014 	str.w	fp, [sp, #20]
  MX_TIM10_Init();
 80062f4:	f001 fe1c 	bl	8007f30 <MX_TIM10_Init>
 80062f8:	f8df a268 	ldr.w	sl, [pc, #616]	; 8006564 <main+0x37c>
  MX_TIM11_Init();
 80062fc:	f001 ff76 	bl	80081ec <MX_TIM11_Init>
 8006300:	4b8d      	ldr	r3, [pc, #564]	; (8006538 <main+0x350>)
 8006302:	f503 64e0 	add.w	r4, r3, #1792	; 0x700
  MX_TIM12_Init();
 8006306:	f002 f8cf 	bl	80084a8 <MX_TIM12_Init>
  MX_TIM6_Init();
 800630a:	f001 faeb 	bl	80078e4 <MX_TIM6_Init>
  MX_USB_DEVICE_Init();
 800630e:	f002 fb55 	bl	80089bc <MX_USB_DEVICE_Init>
  MX_GFXSIMULATOR_Init();
 8006312:	f7fe feb1 	bl	8005078 <MX_GFXSIMULATOR_Init>
  MX_ADC1_Init();
 8006316:	f7fe fdc9 	bl	8004eac <MX_ADC1_Init>
  MX_UART8_Init();
 800631a:	f002 faf3 	bl	8008904 <MX_UART8_Init>
  HAL_I2C_Master_Transmit(&hi2c1, PCAL6416A_ADDR_GND_W ,pcal6416aConfig, ARRAY_SIZE(pcal6416aConfig), 100);
 800631e:	aa0d      	add	r2, sp, #52	; 0x34
 8006320:	2303      	movs	r3, #3
 8006322:	2140      	movs	r1, #64	; 0x40
 8006324:	9600      	str	r6, [sp, #0]
 8006326:	4885      	ldr	r0, [pc, #532]	; (800653c <main+0x354>)
 8006328:	f7fa fe40 	bl	8000fac <HAL_I2C_Master_Transmit>
  HAL_I2C_Master_Transmit(&hi2c1, PCAL6416A_ADDR_VCC_W ,pcal6416aConfig, ARRAY_SIZE(pcal6416aConfig), 100);
 800632c:	aa0d      	add	r2, sp, #52	; 0x34
 800632e:	2303      	movs	r3, #3
 8006330:	2142      	movs	r1, #66	; 0x42
 8006332:	9600      	str	r6, [sp, #0]
 8006334:	4881      	ldr	r0, [pc, #516]	; (800653c <main+0x354>)
 8006336:	f7fa fe39 	bl	8000fac <HAL_I2C_Master_Transmit>
  HAL_I2C_Master_Transmit(&hi2c2, PCAL6416A_ADDR_GND_W ,pcal6416aConfig, ARRAY_SIZE(pcal6416aConfig), 100);
 800633a:	aa0d      	add	r2, sp, #52	; 0x34
 800633c:	2303      	movs	r3, #3
 800633e:	2140      	movs	r1, #64	; 0x40
 8006340:	9600      	str	r6, [sp, #0]
 8006342:	487f      	ldr	r0, [pc, #508]	; (8006540 <main+0x358>)
 8006344:	f7fa fe32 	bl	8000fac <HAL_I2C_Master_Transmit>
  HAL_I2C_Master_Transmit(&hi2c2, PCAL6416A_ADDR_VCC_W ,pcal6416aConfig, ARRAY_SIZE(pcal6416aConfig), 100);
 8006348:	aa0d      	add	r2, sp, #52	; 0x34
 800634a:	2303      	movs	r3, #3
 800634c:	2142      	movs	r1, #66	; 0x42
 800634e:	9600      	str	r6, [sp, #0]
 8006350:	487b      	ldr	r0, [pc, #492]	; (8006540 <main+0x358>)
 8006352:	f7fa fe2b 	bl	8000fac <HAL_I2C_Master_Transmit>
  HAL_I2C_Master_Transmit(&hi2c3, PCAL6416A_ADDR_GND_W ,pcal6416aConfig, ARRAY_SIZE(pcal6416aConfig), 100);
 8006356:	aa0d      	add	r2, sp, #52	; 0x34
 8006358:	2303      	movs	r3, #3
 800635a:	2140      	movs	r1, #64	; 0x40
 800635c:	9600      	str	r6, [sp, #0]
 800635e:	4879      	ldr	r0, [pc, #484]	; (8006544 <main+0x35c>)
 8006360:	f7fa fe24 	bl	8000fac <HAL_I2C_Master_Transmit>
  HAL_I2C_Master_Transmit(&hi2c3, PCAL6416A_ADDR_VCC_W ,pcal6416aConfig, ARRAY_SIZE(pcal6416aConfig), 100);
 8006364:	aa0d      	add	r2, sp, #52	; 0x34
 8006366:	2303      	movs	r3, #3
 8006368:	2142      	movs	r1, #66	; 0x42
 800636a:	9600      	str	r6, [sp, #0]
 800636c:	4875      	ldr	r0, [pc, #468]	; (8006544 <main+0x35c>)
 800636e:	f7fa fe1d 	bl	8000fac <HAL_I2C_Master_Transmit>
  HAL_I2C_Master_Transmit(&hi2c4, PCAL6416A_ADDR_GND_W ,pcal6416aConfig, ARRAY_SIZE(pcal6416aConfig), 100);
 8006372:	aa0d      	add	r2, sp, #52	; 0x34
 8006374:	2303      	movs	r3, #3
 8006376:	2140      	movs	r1, #64	; 0x40
 8006378:	9600      	str	r6, [sp, #0]
 800637a:	4873      	ldr	r0, [pc, #460]	; (8006548 <main+0x360>)
 800637c:	f7fa fe16 	bl	8000fac <HAL_I2C_Master_Transmit>
  HAL_I2C_Master_Transmit(&hi2c4, PCAL6416A_ADDR_VCC_W ,pcal6416aConfig, ARRAY_SIZE(pcal6416aConfig), 100);
 8006380:	aa0d      	add	r2, sp, #52	; 0x34
 8006382:	2303      	movs	r3, #3
 8006384:	2142      	movs	r1, #66	; 0x42
 8006386:	9600      	str	r6, [sp, #0]
 8006388:	486f      	ldr	r0, [pc, #444]	; (8006548 <main+0x360>)
 800638a:	f7fa fe0f 	bl	8000fac <HAL_I2C_Master_Transmit>
  initializeOutputs();
 800638e:	f7ff f8c9 	bl	8005524 <initializeOutputs>
	HAL_TIM_Base_Start_IT(&htim6);
 8006392:	486e      	ldr	r0, [pc, #440]	; (800654c <main+0x364>)
 8006394:	f7fc fb44 	bl	8002a20 <HAL_TIM_Base_Start_IT>
  HAL_UART_Receive_IT(&huart8,&rxBuff,1);
 8006398:	2201      	movs	r2, #1
 800639a:	4961      	ldr	r1, [pc, #388]	; (8006520 <main+0x338>)
 800639c:	486c      	ldr	r0, [pc, #432]	; (8006550 <main+0x368>)
 800639e:	f7fc ff11 	bl	80031c4 <HAL_UART_Receive_IT>
	  rxMidiMessage = pop(&fifo);
 80063a2:	485e      	ldr	r0, [pc, #376]	; (800651c <main+0x334>)
 80063a4:	f7fe fe30 	bl	8005008 <pop>
	  if(rxMidiMessage.status != 0)
 80063a8:	f010 03ff 	ands.w	r3, r0, #255	; 0xff
	  rxMidiMessage = pop(&fifo);
 80063ac:	900f      	str	r0, [sp, #60]	; 0x3c
	  if(rxMidiMessage.status != 0)
 80063ae:	d00f      	beq.n	80063d0 <main+0x1e8>
	  rxMidiMessage = pop(&fifo);
 80063b0:	f89d 103f 	ldrb.w	r1, [sp, #63]	; 0x3f
		  switch(rxMidiMessage.status)
 80063b4:	2b09      	cmp	r3, #9
	  rxMidiMessage = pop(&fifo);
 80063b6:	f89d 203e 	ldrb.w	r2, [sp, #62]	; 0x3e
		  lastMidiMessage = rxMidiMessage;
 80063ba:	f8c8 0000 	str.w	r0, [r8]
	  rxMidiMessage = pop(&fifo);
 80063be:	9103      	str	r1, [sp, #12]
		  switch(rxMidiMessage.status)
 80063c0:	f000 82aa 	beq.w	8006918 <main+0x730>
 80063c4:	2b0b      	cmp	r3, #11
 80063c6:	f000 81ed 	beq.w	80067a4 <main+0x5bc>
 80063ca:	2b08      	cmp	r3, #8
 80063cc:	f000 81c8 	beq.w	8006760 <main+0x578>
	  if(adcConvNum == 0 && adcConvNum != lastAdcConvNum)
 80063d0:	1beb      	subs	r3, r5, r7
 80063d2:	bf18      	it	ne
 80063d4:	2301      	movne	r3, #1
 80063d6:	2d00      	cmp	r5, #0
 80063d8:	f040 80c6 	bne.w	8006568 <main+0x380>
 80063dc:	2b00      	cmp	r3, #0
 80063de:	f000 80c3 	beq.w	8006568 <main+0x380>
		  HAL_ADC_Start(&hadc1);
 80063e2:	485c      	ldr	r0, [pc, #368]	; (8006554 <main+0x36c>)
 80063e4:	f7fa f99c 	bl	8000720 <HAL_ADC_Start>
		  HAL_ADC_PollForConversion(&hadc1,100);
 80063e8:	2164      	movs	r1, #100	; 0x64
 80063ea:	485a      	ldr	r0, [pc, #360]	; (8006554 <main+0x36c>)
 80063ec:	f7fa fa22 	bl	8000834 <HAL_ADC_PollForConversion>
		  midiOutData[0]= 127 * lpfFilter(HAL_ADC_GetValue(&hadc1), &lpfAdc0)/62;
 80063f0:	4858      	ldr	r0, [pc, #352]	; (8006554 <main+0x36c>)
 80063f2:	f7fa fa71 	bl	80008d8 <HAL_ADC_GetValue>
	 filterData->lastData = filterData->lastData - (filterData->LPF_Beta * (filterData->lastData - inputValue));
 80063f6:	b2c0      	uxtb	r0, r0
 80063f8:	ee07 0a90 	vmov	s15, r0
 80063fc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8006400:	ee78 7ae7 	vsub.f32	s15, s17, s15
 8006404:	eee7 8aca 	vfms.f32	s17, s15, s20
	 if(filterData->lastData > 255)
 8006408:	eef4 8ae9 	vcmpe.f32	s17, s19
 800640c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8006410:	f300 8157 	bgt.w	80066c2 <main+0x4da>
 8006414:	eefc 7ae8 	vcvt.u32.f32	s15, s17
 8006418:	4a4f      	ldr	r2, [pc, #316]	; (8006558 <main+0x370>)
 800641a:	edcd 7a03 	vstr	s15, [sp, #12]
 800641e:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8006422:	ebc3 13c3 	rsb	r3, r3, r3, lsl #7
 8006426:	085b      	lsrs	r3, r3, #1
 8006428:	fba2 2303 	umull	r2, r3, r2, r3
 800642c:	f3c3 1307 	ubfx	r3, r3, #4, #8
		  midiOutData[0]= 127 * lpfFilter(HAL_ADC_GetValue(&hadc1), &lpfAdc0)/62;
 8006430:	f889 3000 	strb.w	r3, [r9]
		  if(midiOutData[0] < 64)
 8006434:	f899 3000 	ldrb.w	r3, [r9]
 8006438:	2b3f      	cmp	r3, #63	; 0x3f
 800643a:	f240 814c 	bls.w	80066d6 <main+0x4ee>
		  if((midiOutData[0] > midiOutLastData[0]) || (midiOutData[0] < midiOutLastData[0]))
 800643e:	f899 2000 	ldrb.w	r2, [r9]
 8006442:	f89a 3000 	ldrb.w	r3, [sl]
 8006446:	429a      	cmp	r2, r3
 8006448:	d805      	bhi.n	8006456 <main+0x26e>
 800644a:	f899 2000 	ldrb.w	r2, [r9]
 800644e:	f89a 3000 	ldrb.w	r3, [sl]
 8006452:	429a      	cmp	r2, r3
 8006454:	d20c      	bcs.n	8006470 <main+0x288>
		      txMidiMessage[0][3] = midiOutData[0];
 8006456:	f899 2000 	ldrb.w	r2, [r9]
		      MIDI_Transmit_FS(txMidiMessage[0],4);
 800645a:	2104      	movs	r1, #4
		      midiOutLastData[0] = midiOutData[0];
 800645c:	f899 3000 	ldrb.w	r3, [r9]
		      MIDI_Transmit_FS(txMidiMessage[0],4);
 8006460:	a810      	add	r0, sp, #64	; 0x40
		      txMidiMessage[0][3] = midiOutData[0];
 8006462:	f88d 2043 	strb.w	r2, [sp, #67]	; 0x43
		      midiOutLastData[0] = midiOutData[0];
 8006466:	b2db      	uxtb	r3, r3
 8006468:	f88a 3000 	strb.w	r3, [sl]
		      MIDI_Transmit_FS(txMidiMessage[0],4);
 800646c:	f002 fd98 	bl	8008fa0 <MIDI_Transmit_FS>
				  pressedDownFlag = 1;
 8006470:	2300      	movs	r3, #0
 8006472:	461f      	mov	r7, r3
	  if(adcConvNum == 3 && adcConvNum != lastAdcConvNum)
 8006474:	2d03      	cmp	r5, #3
 8006476:	d142      	bne.n	80064fe <main+0x316>
 8006478:	2b00      	cmp	r3, #0
 800647a:	d040      	beq.n	80064fe <main+0x316>
		  HAL_ADC_Start(&hadc1);
 800647c:	4835      	ldr	r0, [pc, #212]	; (8006554 <main+0x36c>)
 800647e:	f7fa f94f 	bl	8000720 <HAL_ADC_Start>
		  HAL_ADC_PollForConversion(&hadc1,100);
 8006482:	2164      	movs	r1, #100	; 0x64
 8006484:	4833      	ldr	r0, [pc, #204]	; (8006554 <main+0x36c>)
 8006486:	f7fa f9d5 	bl	8000834 <HAL_ADC_PollForConversion>
		  midiOutData[3]= 127 * lpfFilter(HAL_ADC_GetValue(&hadc1), &lpfAdc2)/62;
 800648a:	4832      	ldr	r0, [pc, #200]	; (8006554 <main+0x36c>)
 800648c:	f7fa fa24 	bl	80008d8 <HAL_ADC_GetValue>
	 filterData->lastData = filterData->lastData - (filterData->LPF_Beta * (filterData->lastData - inputValue));
 8006490:	b2c0      	uxtb	r0, r0
 8006492:	ee07 0a90 	vmov	s15, r0
 8006496:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800649a:	ee78 7a67 	vsub.f32	s15, s16, s15
 800649e:	eea7 8aca 	vfms.f32	s16, s15, s20
	 if(filterData->lastData > 255)
 80064a2:	eeb4 8ae9 	vcmpe.f32	s16, s19
 80064a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80064aa:	f300 8135 	bgt.w	8006718 <main+0x530>
 80064ae:	eefc 7ac8 	vcvt.u32.f32	s15, s16
 80064b2:	4a29      	ldr	r2, [pc, #164]	; (8006558 <main+0x370>)
 80064b4:	edcd 7a03 	vstr	s15, [sp, #12]
 80064b8:	f89d 300c 	ldrb.w	r3, [sp, #12]
 80064bc:	ebc3 13c3 	rsb	r3, r3, r3, lsl #7
 80064c0:	085b      	lsrs	r3, r3, #1
 80064c2:	fba2 2303 	umull	r2, r3, r2, r3
 80064c6:	f3c3 1307 	ubfx	r3, r3, #4, #8
		  midiOutData[3]= 127 * lpfFilter(HAL_ADC_GetValue(&hadc1), &lpfAdc2)/62;
 80064ca:	f889 3003 	strb.w	r3, [r9, #3]
		  if(midiOutData[3] < 63)
 80064ce:	f899 3003 	ldrb.w	r3, [r9, #3]
 80064d2:	2b3e      	cmp	r3, #62	; 0x3e
 80064d4:	f240 812a 	bls.w	800672c <main+0x544>
			  if(momentarySwithWasPressed == 1)
 80064d8:	9b05      	ldr	r3, [sp, #20]
 80064da:	2b00      	cmp	r3, #0
 80064dc:	f040 826c 	bne.w	80069b8 <main+0x7d0>
		  if((midiOutData[3] > midiOutLastData[3]) || (midiOutData[3] < midiOutLastData[3]))
 80064e0:	f899 2003 	ldrb.w	r2, [r9, #3]
 80064e4:	f89a 3003 	ldrb.w	r3, [sl, #3]
 80064e8:	429a      	cmp	r2, r3
 80064ea:	f200 80c5 	bhi.w	8006678 <main+0x490>
 80064ee:	f899 2003 	ldrb.w	r2, [r9, #3]
 80064f2:	f89a 3003 	ldrb.w	r3, [sl, #3]
 80064f6:	429a      	cmp	r2, r3
 80064f8:	f0c0 80be 	bcc.w	8006678 <main+0x490>
 80064fc:	2703      	movs	r7, #3
	  if(lastSystickVal != HAL_GetTick())
 80064fe:	f7fa f841 	bl	8000584 <HAL_GetTick>
 8006502:	4558      	cmp	r0, fp
 8006504:	f43f af4d 	beq.w	80063a2 <main+0x1ba>
 8006508:	3501      	adds	r5, #1
 800650a:	b2ed      	uxtb	r5, r5
			  adcConvNum = 0;
 800650c:	2d04      	cmp	r5, #4
 800650e:	bf28      	it	cs
 8006510:	2500      	movcs	r5, #0
		  lastSystickVal = HAL_GetTick();
 8006512:	f7fa f837 	bl	8000584 <HAL_GetTick>
 8006516:	4683      	mov	fp, r0
 8006518:	e743      	b.n	80063a2 <main+0x1ba>
 800651a:	bf00      	nop
 800651c:	20000828 	.word	0x20000828
 8006520:	20000f34 	.word	0x20000f34
 8006524:	08009244 	.word	0x08009244
 8006528:	e000ed00 	.word	0xe000ed00
 800652c:	00000000 	.word	0x00000000
 8006530:	3dcccccd 	.word	0x3dcccccd
 8006534:	437f0000 	.word	0x437f0000
 8006538:	20000834 	.word	0x20000834
 800653c:	20000778 	.word	0x20000778
 8006540:	200007c4 	.word	0x200007c4
 8006544:	200006e0 	.word	0x200006e0
 8006548:	2000072c 	.word	0x2000072c
 800654c:	200010fc 	.word	0x200010fc
 8006550:	2000127c 	.word	0x2000127c
 8006554:	2000029c 	.word	0x2000029c
 8006558:	84210843 	.word	0x84210843
 800655c:	20000820 	.word	0x20000820
 8006560:	20000824 	.word	0x20000824
 8006564:	20000f38 	.word	0x20000f38
	  if(adcConvNum == 1 && adcConvNum != lastAdcConvNum)
 8006568:	2d01      	cmp	r5, #1
 800656a:	d126      	bne.n	80065ba <main+0x3d2>
 800656c:	b32b      	cbz	r3, 80065ba <main+0x3d2>
		  midiOutData[1] = (HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_13) ? 127 : 0);
 800656e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8006572:	4886      	ldr	r0, [pc, #536]	; (800678c <main+0x5a4>)
 8006574:	f7fa fc0a 	bl	8000d8c <HAL_GPIO_ReadPin>
 8006578:	2800      	cmp	r0, #0
 800657a:	bf0c      	ite	eq
 800657c:	2300      	moveq	r3, #0
 800657e:	237f      	movne	r3, #127	; 0x7f
 8006580:	f889 3001 	strb.w	r3, [r9, #1]
		  if((midiOutData[1] > midiOutLastData[1]) || (midiOutData[1] < midiOutLastData[1]))
 8006584:	f899 2001 	ldrb.w	r2, [r9, #1]
 8006588:	f89a 3001 	ldrb.w	r3, [sl, #1]
 800658c:	429a      	cmp	r2, r3
 800658e:	d805      	bhi.n	800659c <main+0x3b4>
 8006590:	f899 2001 	ldrb.w	r2, [r9, #1]
 8006594:	f89a 3001 	ldrb.w	r3, [sl, #1]
 8006598:	429a      	cmp	r2, r3
 800659a:	d20c      	bcs.n	80065b6 <main+0x3ce>
			  txMidiMessage[1][3] = midiOutData[1];
 800659c:	f899 2001 	ldrb.w	r2, [r9, #1]
			  MIDI_Transmit_FS(txMidiMessage[1],4);
 80065a0:	2104      	movs	r1, #4
			  midiOutLastData[1] = midiOutData[1];
 80065a2:	f899 3001 	ldrb.w	r3, [r9, #1]
			  MIDI_Transmit_FS(txMidiMessage[1],4);
 80065a6:	a811      	add	r0, sp, #68	; 0x44
			  txMidiMessage[1][3] = midiOutData[1];
 80065a8:	f88d 2047 	strb.w	r2, [sp, #71]	; 0x47
			  midiOutLastData[1] = midiOutData[1];
 80065ac:	b2db      	uxtb	r3, r3
 80065ae:	f88a 3001 	strb.w	r3, [sl, #1]
			  MIDI_Transmit_FS(txMidiMessage[1],4);
 80065b2:	f002 fcf5 	bl	8008fa0 <MIDI_Transmit_FS>
			  MIDI_Transmit_FS(txMidiMessage[2],4);
 80065b6:	2701      	movs	r7, #1
 80065b8:	e7a1      	b.n	80064fe <main+0x316>
	  if(adcConvNum == 2 && adcConvNum != lastAdcConvNum)
 80065ba:	2d02      	cmp	r5, #2
 80065bc:	f47f af5a 	bne.w	8006474 <main+0x28c>
 80065c0:	2b00      	cmp	r3, #0
 80065c2:	f43f af57 	beq.w	8006474 <main+0x28c>
		  HAL_ADC_Start(&hadc1);
 80065c6:	4872      	ldr	r0, [pc, #456]	; (8006790 <main+0x5a8>)
 80065c8:	f7fa f8aa 	bl	8000720 <HAL_ADC_Start>
		  HAL_ADC_PollForConversion(&hadc1,100);
 80065cc:	2164      	movs	r1, #100	; 0x64
 80065ce:	4870      	ldr	r0, [pc, #448]	; (8006790 <main+0x5a8>)
 80065d0:	f7fa f930 	bl	8000834 <HAL_ADC_PollForConversion>
		  midiOutData[2]= 127 * lpfFilter(HAL_ADC_GetValue(&hadc1), &lpfAdc1)/62;
 80065d4:	486e      	ldr	r0, [pc, #440]	; (8006790 <main+0x5a8>)
 80065d6:	f7fa f97f 	bl	80008d8 <HAL_ADC_GetValue>
	 filterData->lastData = filterData->lastData - (filterData->LPF_Beta * (filterData->lastData - inputValue));
 80065da:	b2c0      	uxtb	r0, r0
 80065dc:	ee07 0a90 	vmov	s15, r0
 80065e0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80065e4:	ee79 7a67 	vsub.f32	s15, s18, s15
 80065e8:	eea7 9aca 	vfms.f32	s18, s15, s20
	 if(filterData->lastData > 255)
 80065ec:	eeb4 9ae9 	vcmpe.f32	s18, s19
 80065f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80065f4:	dc61      	bgt.n	80066ba <main+0x4d2>
 80065f6:	eefc 7ac9 	vcvt.u32.f32	s15, s18
 80065fa:	4a66      	ldr	r2, [pc, #408]	; (8006794 <main+0x5ac>)
 80065fc:	edcd 7a03 	vstr	s15, [sp, #12]
 8006600:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8006604:	ebc3 13c3 	rsb	r3, r3, r3, lsl #7
 8006608:	085b      	lsrs	r3, r3, #1
 800660a:	fba2 2303 	umull	r2, r3, r2, r3
 800660e:	f3c3 1307 	ubfx	r3, r3, #4, #8
		  midiOutData[2]= 127 * lpfFilter(HAL_ADC_GetValue(&hadc1), &lpfAdc1)/62;
 8006612:	f889 3002 	strb.w	r3, [r9, #2]
		  if(midiOutData[2] < 63)
 8006616:	f899 3002 	ldrb.w	r3, [r9, #2]
 800661a:	2b3e      	cmp	r3, #62	; 0x3e
 800661c:	d84a      	bhi.n	80066b4 <main+0x4cc>
			  if(pressedDownFlag != 1)
 800661e:	9b04      	ldr	r3, [sp, #16]
 8006620:	2b01      	cmp	r3, #1
 8006622:	d01b      	beq.n	800665c <main+0x474>
				  if(pressedCount == 0)
 8006624:	9b06      	ldr	r3, [sp, #24]
 8006626:	2b00      	cmp	r3, #0
 8006628:	f040 81ac 	bne.w	8006984 <main+0x79c>
				outputs[i].outputEnabled = 0;
 800662c:	461f      	mov	r7, r3
 800662e:	4e5a      	ldr	r6, [pc, #360]	; (8006798 <main+0x5b0>)
 8006630:	e006      	b.n	8006640 <main+0x458>
				HAL_TIM_PWM_Stop(outputs[i].htim,outputs[i].timChannel);
 8006632:	88b1      	ldrh	r1, [r6, #4]
 8006634:	f7fc fabe 	bl	8002bb4 <HAL_TIM_PWM_Stop>
				outputs[i].outputEnabled = 0;
 8006638:	76b7      	strb	r7, [r6, #26]
 800663a:	361c      	adds	r6, #28
	for(int i = 0; i < 64; ++i)
 800663c:	42b4      	cmp	r4, r6
 800663e:	d00a      	beq.n	8006656 <main+0x46e>
		if(outputs[i].isOutputSetByNoteOn)
 8006640:	7ef3      	ldrb	r3, [r6, #27]
 8006642:	2b00      	cmp	r3, #0
 8006644:	d0f9      	beq.n	800663a <main+0x452>
			if(outputs[i].htim != NULL)
 8006646:	6833      	ldr	r3, [r6, #0]
				HAL_TIM_PWM_Stop(outputs[i].htim,outputs[i].timChannel);
 8006648:	4618      	mov	r0, r3
			if(outputs[i].htim != NULL)
 800664a:	2b00      	cmp	r3, #0
 800664c:	d1f1      	bne.n	8006632 <main+0x44a>
			outputs[i].outputEnabled = 0;
 800664e:	76b3      	strb	r3, [r6, #26]
 8006650:	361c      	adds	r6, #28
	for(int i = 0; i < 64; ++i)
 8006652:	42b4      	cmp	r4, r6
 8006654:	d1f4      	bne.n	8006640 <main+0x458>
					  pressedCount = 1;
 8006656:	2301      	movs	r3, #1
 8006658:	9306      	str	r3, [sp, #24]
				  pressedDownFlag = 1;
 800665a:	9304      	str	r3, [sp, #16]
		  if((midiOutData[2] > midiOutLastData[2]) || (midiOutData[2] < midiOutLastData[2]))
 800665c:	f899 2002 	ldrb.w	r2, [r9, #2]
 8006660:	f89a 3002 	ldrb.w	r3, [sl, #2]
 8006664:	429a      	cmp	r2, r3
 8006666:	d816      	bhi.n	8006696 <main+0x4ae>
 8006668:	f899 2002 	ldrb.w	r2, [r9, #2]
 800666c:	f89a 3002 	ldrb.w	r3, [sl, #2]
 8006670:	429a      	cmp	r2, r3
 8006672:	d310      	bcc.n	8006696 <main+0x4ae>
 8006674:	2702      	movs	r7, #2
 8006676:	e742      	b.n	80064fe <main+0x316>
			  txMidiMessage[3][3] = midiOutData[3];
 8006678:	f899 2003 	ldrb.w	r2, [r9, #3]
			  MIDI_Transmit_FS(txMidiMessage[3],4);
 800667c:	2104      	movs	r1, #4
			  midiOutLastData[3] = midiOutData[3];
 800667e:	f899 3003 	ldrb.w	r3, [r9, #3]
			  MIDI_Transmit_FS(txMidiMessage[3],4);
 8006682:	a813      	add	r0, sp, #76	; 0x4c
			  txMidiMessage[3][3] = midiOutData[3];
 8006684:	f88d 204f 	strb.w	r2, [sp, #79]	; 0x4f
			  MIDI_Transmit_FS(txMidiMessage[3],4);
 8006688:	2703      	movs	r7, #3
			  midiOutLastData[3] = midiOutData[3];
 800668a:	b2db      	uxtb	r3, r3
 800668c:	f88a 3003 	strb.w	r3, [sl, #3]
			  MIDI_Transmit_FS(txMidiMessage[3],4);
 8006690:	f002 fc86 	bl	8008fa0 <MIDI_Transmit_FS>
 8006694:	e733      	b.n	80064fe <main+0x316>
			  txMidiMessage[2][3] = midiOutData[2];
 8006696:	f899 2002 	ldrb.w	r2, [r9, #2]
			  MIDI_Transmit_FS(txMidiMessage[2],4);
 800669a:	2104      	movs	r1, #4
			  midiOutLastData[2] = midiOutData[2];
 800669c:	f899 3002 	ldrb.w	r3, [r9, #2]
			  MIDI_Transmit_FS(txMidiMessage[2],4);
 80066a0:	a812      	add	r0, sp, #72	; 0x48
			  txMidiMessage[2][3] = midiOutData[2];
 80066a2:	f88d 204b 	strb.w	r2, [sp, #75]	; 0x4b
			  MIDI_Transmit_FS(txMidiMessage[2],4);
 80066a6:	2702      	movs	r7, #2
			  midiOutLastData[2] = midiOutData[2];
 80066a8:	b2db      	uxtb	r3, r3
 80066aa:	f88a 3002 	strb.w	r3, [sl, #2]
			  MIDI_Transmit_FS(txMidiMessage[2],4);
 80066ae:	f002 fc77 	bl	8008fa0 <MIDI_Transmit_FS>
 80066b2:	e724      	b.n	80064fe <main+0x316>
			  pressedDownFlag = 0;
 80066b4:	2300      	movs	r3, #0
 80066b6:	9304      	str	r3, [sp, #16]
 80066b8:	e7d0      	b.n	800665c <main+0x474>
	 if(filterData->lastData > 255)
 80066ba:	230a      	movs	r3, #10
		 filterData->lastData = 255;
 80066bc:	ed9f 9a37 	vldr	s18, [pc, #220]	; 800679c <main+0x5b4>
 80066c0:	e7a7      	b.n	8006612 <main+0x42a>
	 if(filterData->lastData > 255)
 80066c2:	230a      	movs	r3, #10
		 filterData->lastData = 255;
 80066c4:	eddf 8a35 	vldr	s17, [pc, #212]	; 800679c <main+0x5b4>
		  midiOutData[0]= 127 * lpfFilter(HAL_ADC_GetValue(&hadc1), &lpfAdc0)/62;
 80066c8:	f889 3000 	strb.w	r3, [r9]
		  if(midiOutData[0] < 64)
 80066cc:	f899 3000 	ldrb.w	r3, [r9]
 80066d0:	2b3f      	cmp	r3, #63	; 0x3f
 80066d2:	f63f aeb4 	bhi.w	800643e <main+0x256>
 80066d6:	4b30      	ldr	r3, [pc, #192]	; (8006798 <main+0x5b0>)
		htim->Instance->CCR6 = pwmValue;
 80066d8:	2000      	movs	r0, #0
		if(outputs[i].htim != NULL)
 80066da:	681a      	ldr	r2, [r3, #0]
 80066dc:	2a00      	cmp	r2, #0
 80066de:	f000 8140 	beq.w	8006962 <main+0x77a>
	switch(timChannel)
 80066e2:	8899      	ldrh	r1, [r3, #4]
 80066e4:	2914      	cmp	r1, #20
 80066e6:	f200 8134 	bhi.w	8006952 <main+0x76a>
 80066ea:	e8df f011 	tbh	[pc, r1, lsl #1]
 80066ee:	0142      	.short	0x0142
 80066f0:	01320132 	.word	0x01320132
 80066f4:	01480132 	.word	0x01480132
 80066f8:	01320132 	.word	0x01320132
 80066fc:	01450132 	.word	0x01450132
 8006700:	01320132 	.word	0x01320132
 8006704:	013f0132 	.word	0x013f0132
 8006708:	01320132 	.word	0x01320132
 800670c:	013c0132 	.word	0x013c0132
 8006710:	01320132 	.word	0x01320132
 8006714:	01300132 	.word	0x01300132
	 if(filterData->lastData > 255)
 8006718:	230a      	movs	r3, #10
		 filterData->lastData = 255;
 800671a:	ed9f 8a20 	vldr	s16, [pc, #128]	; 800679c <main+0x5b4>
		  midiOutData[3]= 127 * lpfFilter(HAL_ADC_GetValue(&hadc1), &lpfAdc2)/62;
 800671e:	f889 3003 	strb.w	r3, [r9, #3]
		  if(midiOutData[3] < 63)
 8006722:	f899 3003 	ldrb.w	r3, [r9, #3]
 8006726:	2b3e      	cmp	r3, #62	; 0x3e
 8006728:	f63f aed6 	bhi.w	80064d8 <main+0x2f0>
 800672c:	4e1a      	ldr	r6, [pc, #104]	; (8006798 <main+0x5b0>)
				outputs[i].outputEnabled = 0;
 800672e:	2700      	movs	r7, #0
 8006730:	e006      	b.n	8006740 <main+0x558>
				HAL_TIM_PWM_Stop(outputs[i].htim,outputs[i].timChannel);
 8006732:	88b1      	ldrh	r1, [r6, #4]
 8006734:	f7fc fa3e 	bl	8002bb4 <HAL_TIM_PWM_Stop>
				outputs[i].outputEnabled = 0;
 8006738:	76b7      	strb	r7, [r6, #26]
 800673a:	361c      	adds	r6, #28
	for(int i = 0; i < 64; ++i)
 800673c:	42a6      	cmp	r6, r4
 800673e:	d00a      	beq.n	8006756 <main+0x56e>
		if(outputs[i].isOutputSetByNoteOn)
 8006740:	7ef3      	ldrb	r3, [r6, #27]
 8006742:	2b00      	cmp	r3, #0
 8006744:	d0f9      	beq.n	800673a <main+0x552>
			if(outputs[i].htim != NULL)
 8006746:	6833      	ldr	r3, [r6, #0]
				HAL_TIM_PWM_Stop(outputs[i].htim,outputs[i].timChannel);
 8006748:	4618      	mov	r0, r3
			if(outputs[i].htim != NULL)
 800674a:	2b00      	cmp	r3, #0
 800674c:	d1f1      	bne.n	8006732 <main+0x54a>
			outputs[i].outputEnabled = 0;
 800674e:	76b3      	strb	r3, [r6, #26]
 8006750:	361c      	adds	r6, #28
	for(int i = 0; i < 64; ++i)
 8006752:	42a6      	cmp	r6, r4
 8006754:	d1f4      	bne.n	8006740 <main+0x558>
			  momentarySwithWasPressed = 1;
 8006756:	2301      	movs	r3, #1
 8006758:	2200      	movs	r2, #0
 800675a:	e9cd 3205 	strd	r3, r2, [sp, #20]
 800675e:	e6bf      	b.n	80064e0 <main+0x2f8>
	if(channel < 65)
 8006760:	2a40      	cmp	r2, #64	; 0x40
 8006762:	f63f ae35 	bhi.w	80063d0 <main+0x1e8>
		outputParams *out = &outputs[channel-1];
 8006766:	3a01      	subs	r2, #1
	if(out->htim != NULL)
 8006768:	4b0b      	ldr	r3, [pc, #44]	; (8006798 <main+0x5b0>)
 800676a:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 800676e:	0096      	lsls	r6, r2, #2
 8006770:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8006774:	4433      	add	r3, r6
 8006776:	2800      	cmp	r0, #0
 8006778:	f000 8136 	beq.w	80069e8 <main+0x800>
		HAL_TIM_PWM_Stop(out->htim,out->timChannel);
 800677c:	8899      	ldrh	r1, [r3, #4]
 800677e:	f7fc fa19 	bl	8002bb4 <HAL_TIM_PWM_Stop>
		out->outputEnabled = 0;
 8006782:	4b07      	ldr	r3, [pc, #28]	; (80067a0 <main+0x5b8>)
 8006784:	441e      	add	r6, r3
 8006786:	2300      	movs	r3, #0
 8006788:	8073      	strh	r3, [r6, #2]
 800678a:	e621      	b.n	80063d0 <main+0x1e8>
 800678c:	40020000 	.word	0x40020000
 8006790:	2000029c 	.word	0x2000029c
 8006794:	84210843 	.word	0x84210843
 8006798:	20000834 	.word	0x20000834
 800679c:	437f0000 	.word	0x437f0000
 80067a0:	2000084c 	.word	0x2000084c
	if(channel < 65)
 80067a4:	2a40      	cmp	r2, #64	; 0x40
 80067a6:	f63f ae13 	bhi.w	80063d0 <main+0x1e8>
		outputParams *out = &outputs[channel-1];
 80067aa:	3a01      	subs	r2, #1
		switch(out->outType)
 80067ac:	49a5      	ldr	r1, [pc, #660]	; (8006a44 <main+0x85c>)
 80067ae:	ebc2 03c2 	rsb	r3, r2, r2, lsl #3
 80067b2:	9308      	str	r3, [sp, #32]
 80067b4:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 80067b8:	9307      	str	r3, [sp, #28]
 80067ba:	7e5b      	ldrb	r3, [r3, #25]
 80067bc:	2b00      	cmp	r3, #0
 80067be:	f000 8122 	beq.w	8006a06 <main+0x81e>
 80067c2:	2b01      	cmp	r3, #1
 80067c4:	f47f ae04 	bne.w	80063d0 <main+0x1e8>
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 80067c8:	f3c2 03c4 	ubfx	r3, r2, #3, #5
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 80067cc:	489e      	ldr	r0, [pc, #632]	; (8006a48 <main+0x860>)
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 80067ce:	9907      	ldr	r1, [sp, #28]
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 80067d0:	4606      	mov	r6, r0
 80067d2:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 80067d6:	9309      	str	r3, [sp, #36]	; 0x24
 80067d8:	4603      	mov	r3, r0
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 80067da:	4630      	mov	r0, r6
 80067dc:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80067de:	8aca      	ldrh	r2, [r1, #22]
 80067e0:	f810 e016 	ldrb.w	lr, [r0, r6, lsl #1]
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 80067e4:	930a      	str	r3, [sp, #40]	; 0x28
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 80067e6:	fa4f fc82 	sxtb.w	ip, r2
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 80067ea:	785b      	ldrb	r3, [r3, #1]
 80067ec:	f342 2607 	sbfx	r6, r2, #8, #8
	i2cOutputsConfig[channel/8][0] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 80067f0:	4a95      	ldr	r2, [pc, #596]	; (8006a48 <main+0x860>)
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 80067f2:	ea6f 000c 	mvn.w	r0, ip
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 80067f6:	930b      	str	r3, [sp, #44]	; 0x2c
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 80067f8:	f02c 0c55 	bic.w	ip, ip, #85	; 0x55
	i2cOutputsConfig[channel/8][0] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 80067fc:	9b09      	ldr	r3, [sp, #36]	; 0x24
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 80067fe:	7b09      	ldrb	r1, [r1, #12]
	i2cOutputsConfig[channel/8][0] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006800:	f812 2013 	ldrb.w	r2, [r2, r3, lsl #1]
 8006804:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006806:	4002      	ands	r2, r0
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 8006808:	ea00 000e 	and.w	r0, r0, lr
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 800680c:	ea6f 0e06 	mvn.w	lr, r6
 8006810:	f026 0655 	bic.w	r6, r6, #85	; 0x55
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 8006814:	ea4c 0000 	orr.w	r0, ip, r0
	i2cOutputsConfig[channel/8][0] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006818:	ea4c 0202 	orr.w	r2, ip, r2
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 800681c:	fa4f fe8e 	sxtb.w	lr, lr
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 8006820:	f04f 0c64 	mov.w	ip, #100	; 0x64
	i2cOutputsConfig[channel/8][0] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 8006824:	b2d2      	uxtb	r2, r2
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 8006826:	f88d 0039 	strb.w	r0, [sp, #57]	; 0x39
	i2cOutputsConfig[channel/8][0] = ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask);
 800682a:	4887      	ldr	r0, [pc, #540]	; (8006a48 <main+0x860>)
 800682c:	f800 2013 	strb.w	r2, [r0, r3, lsl #1]
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 8006830:	b273      	sxtb	r3, r6
	i2cOutputsConfig[channel/8][1] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006832:	9a0a      	ldr	r2, [sp, #40]	; 0x28
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 8006834:	9309      	str	r3, [sp, #36]	; 0x24
 8006836:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	i2cOutputsConfig[channel/8][1] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006838:	7850      	ldrb	r0, [r2, #1]
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 800683a:	ea0e 0203 	and.w	r2, lr, r3
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 800683e:	9b07      	ldr	r3, [sp, #28]
	i2cOutputsConfig[channel/8][1] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006840:	ea0e 0e00 	and.w	lr, lr, r0
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 8006844:	689e      	ldr	r6, [r3, #8]
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 8006846:	9b09      	ldr	r3, [sp, #36]	; 0x24
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 8006848:	f8cd c000 	str.w	ip, [sp]
 800684c:	4630      	mov	r0, r6
												((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8)) };
 800684e:	431a      	orrs	r2, r3
	i2cOutputsConfig[channel/8][1] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006850:	ea43 0c0e 	orr.w	ip, r3, lr
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 8006854:	ae0e      	add	r6, sp, #56	; 0x38
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 8006856:	f04f 0e02 	mov.w	lr, #2
 800685a:	f88d 203a 	strb.w	r2, [sp, #58]	; 0x3a
	i2cOutputsConfig[channel/8][1] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 800685e:	fa5f fc8c 	uxtb.w	ip, ip
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 8006862:	4632      	mov	r2, r6
	i2cOutputsConfig[channel/8][1] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 8006864:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 8006866:	2303      	movs	r3, #3
	uint8_t txBuff[3] = { PCAL6416A_OUTPUT_REG, ((uint8_t)out->dirMask & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][0] & ~(uint8_t)out->dirMask),
 8006868:	f88d e038 	strb.w	lr, [sp, #56]	; 0x38
	i2cOutputsConfig[channel/8][1] = ((uint8_t)(out->dirMask >> 8) & CURRENT_DIRECTION_1) | (i2cOutputsConfig[channel/8][1] & ~(uint8_t)(out->dirMask >> 8));
 800686c:	f886 c001 	strb.w	ip, [r6, #1]
	HAL_I2C_Master_Transmit(out->hi2c,out->deviceAddress,txBuff,ARRAY_SIZE(txBuff),100);
 8006870:	f7fa fb9c 	bl	8000fac <HAL_I2C_Master_Transmit>
	if(out->htim != NULL)
 8006874:	4a73      	ldr	r2, [pc, #460]	; (8006a44 <main+0x85c>)
 8006876:	9808      	ldr	r0, [sp, #32]
 8006878:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]
 800687c:	2b00      	cmp	r3, #0
 800687e:	f000 80d2 	beq.w	8006a26 <main+0x83e>
	switch(timChannel)
 8006882:	9907      	ldr	r1, [sp, #28]
 8006884:	888a      	ldrh	r2, [r1, #4]
 8006886:	2a14      	cmp	r2, #20
 8006888:	f63f ada2 	bhi.w	80063d0 <main+0x1e8>
 800688c:	a101      	add	r1, pc, #4	; (adr r1, 8006894 <main+0x6ac>)
 800688e:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 8006892:	bf00      	nop
 8006894:	08006911 	.word	0x08006911
 8006898:	080063d1 	.word	0x080063d1
 800689c:	080063d1 	.word	0x080063d1
 80068a0:	080063d1 	.word	0x080063d1
 80068a4:	08006909 	.word	0x08006909
 80068a8:	080063d1 	.word	0x080063d1
 80068ac:	080063d1 	.word	0x080063d1
 80068b0:	080063d1 	.word	0x080063d1
 80068b4:	08006901 	.word	0x08006901
 80068b8:	080063d1 	.word	0x080063d1
 80068bc:	080063d1 	.word	0x080063d1
 80068c0:	080063d1 	.word	0x080063d1
 80068c4:	080068f9 	.word	0x080068f9
 80068c8:	080063d1 	.word	0x080063d1
 80068cc:	080063d1 	.word	0x080063d1
 80068d0:	080063d1 	.word	0x080063d1
 80068d4:	080068f1 	.word	0x080068f1
 80068d8:	080063d1 	.word	0x080063d1
 80068dc:	080063d1 	.word	0x080063d1
 80068e0:	080063d1 	.word	0x080063d1
 80068e4:	080068e9 	.word	0x080068e9
		htim->Instance->CCR6 = pwmValue;
 80068e8:	681b      	ldr	r3, [r3, #0]
 80068ea:	9a03      	ldr	r2, [sp, #12]
 80068ec:	65da      	str	r2, [r3, #92]	; 0x5c
 80068ee:	e56f      	b.n	80063d0 <main+0x1e8>
		htim->Instance->CCR5 = pwmValue;
 80068f0:	681b      	ldr	r3, [r3, #0]
 80068f2:	9a03      	ldr	r2, [sp, #12]
 80068f4:	659a      	str	r2, [r3, #88]	; 0x58
 80068f6:	e56b      	b.n	80063d0 <main+0x1e8>
		htim->Instance->CCR4 = pwmValue;
 80068f8:	681b      	ldr	r3, [r3, #0]
 80068fa:	9a03      	ldr	r2, [sp, #12]
 80068fc:	641a      	str	r2, [r3, #64]	; 0x40
 80068fe:	e567      	b.n	80063d0 <main+0x1e8>
		htim->Instance->CCR3 = pwmValue;
 8006900:	681b      	ldr	r3, [r3, #0]
 8006902:	9a03      	ldr	r2, [sp, #12]
 8006904:	63da      	str	r2, [r3, #60]	; 0x3c
 8006906:	e563      	b.n	80063d0 <main+0x1e8>
		htim->Instance->CCR2 = pwmValue;
 8006908:	681b      	ldr	r3, [r3, #0]
 800690a:	9a03      	ldr	r2, [sp, #12]
 800690c:	639a      	str	r2, [r3, #56]	; 0x38
 800690e:	e55f      	b.n	80063d0 <main+0x1e8>
		htim->Instance->CCR1 = pwmValue;
 8006910:	681b      	ldr	r3, [r3, #0]
 8006912:	9a03      	ldr	r2, [sp, #12]
 8006914:	635a      	str	r2, [r3, #52]	; 0x34
 8006916:	e55b      	b.n	80063d0 <main+0x1e8>
	if(channel < 65)
 8006918:	2a40      	cmp	r2, #64	; 0x40
 800691a:	f63f ad59 	bhi.w	80063d0 <main+0x1e8>
		outputParams *out = &outputs[channel-1];
 800691e:	3a01      	subs	r2, #1
 8006920:	4948      	ldr	r1, [pc, #288]	; (8006a44 <main+0x85c>)
 8006922:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 8006926:	0093      	lsls	r3, r2, #2
 8006928:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
 800692c:	18ca      	adds	r2, r1, r3
		if(noteVel)
 800692e:	9903      	ldr	r1, [sp, #12]
 8006930:	2900      	cmp	r1, #0
 8006932:	d05d      	beq.n	80069f0 <main+0x808>
	if(out->htim != NULL)
 8006934:	2800      	cmp	r0, #0
 8006936:	d070      	beq.n	8006a1a <main+0x832>
		HAL_TIM_PWM_Start(out->htim,out->timChannel);
 8006938:	8891      	ldrh	r1, [r2, #4]
 800693a:	9303      	str	r3, [sp, #12]
 800693c:	f7fc f90a 	bl	8002b54 <HAL_TIM_PWM_Start>
		out->outputEnabled = 1;
 8006940:	4a42      	ldr	r2, [pc, #264]	; (8006a4c <main+0x864>)
 8006942:	9b03      	ldr	r3, [sp, #12]
 8006944:	4413      	add	r3, r2
 8006946:	f240 1201 	movw	r2, #257	; 0x101
 800694a:	805a      	strh	r2, [r3, #2]
 800694c:	e540      	b.n	80063d0 <main+0x1e8>
		htim->Instance->CCR6 = pwmValue;
 800694e:	6812      	ldr	r2, [r2, #0]
 8006950:	65d0      	str	r0, [r2, #92]	; 0x5c
 8006952:	331c      	adds	r3, #28
	for(int i = 0; i < 64; ++i)
 8006954:	429c      	cmp	r4, r3
 8006956:	f43f ad72 	beq.w	800643e <main+0x256>
		if(outputs[i].htim != NULL)
 800695a:	681a      	ldr	r2, [r3, #0]
 800695c:	2a00      	cmp	r2, #0
 800695e:	f47f aec0 	bne.w	80066e2 <main+0x4fa>
			outputs[i].pwmFill = 0;
 8006962:	761a      	strb	r2, [r3, #24]
 8006964:	e7f5      	b.n	8006952 <main+0x76a>
		htim->Instance->CCR5 = pwmValue;
 8006966:	6812      	ldr	r2, [r2, #0]
 8006968:	6590      	str	r0, [r2, #88]	; 0x58
 800696a:	e7f2      	b.n	8006952 <main+0x76a>
		htim->Instance->CCR4 = pwmValue;
 800696c:	6812      	ldr	r2, [r2, #0]
 800696e:	6410      	str	r0, [r2, #64]	; 0x40
 8006970:	e7ef      	b.n	8006952 <main+0x76a>
		htim->Instance->CCR1 = pwmValue;
 8006972:	6812      	ldr	r2, [r2, #0]
 8006974:	6350      	str	r0, [r2, #52]	; 0x34
 8006976:	e7ec      	b.n	8006952 <main+0x76a>
		htim->Instance->CCR3 = pwmValue;
 8006978:	6812      	ldr	r2, [r2, #0]
 800697a:	63d0      	str	r0, [r2, #60]	; 0x3c
 800697c:	e7e9      	b.n	8006952 <main+0x76a>
		htim->Instance->CCR2 = pwmValue;
 800697e:	6812      	ldr	r2, [r2, #0]
 8006980:	6390      	str	r0, [r2, #56]	; 0x38
 8006982:	e7e6      	b.n	8006952 <main+0x76a>
 8006984:	4e2f      	ldr	r6, [pc, #188]	; (8006a44 <main+0x85c>)
				outputs[i].outputEnabled = 1;
 8006986:	2701      	movs	r7, #1
 8006988:	e006      	b.n	8006998 <main+0x7b0>
				HAL_TIM_PWM_Start(outputs[i].htim,outputs[i].timChannel);
 800698a:	88b1      	ldrh	r1, [r6, #4]
 800698c:	f7fc f8e2 	bl	8002b54 <HAL_TIM_PWM_Start>
				outputs[i].outputEnabled = 1;
 8006990:	76b7      	strb	r7, [r6, #26]
 8006992:	361c      	adds	r6, #28
	for(int i = 0; i < 64; ++i)
 8006994:	42b4      	cmp	r4, r6
 8006996:	d00a      	beq.n	80069ae <main+0x7c6>
		if(outputs[i].isOutputSetByNoteOn)
 8006998:	7ef3      	ldrb	r3, [r6, #27]
 800699a:	2b00      	cmp	r3, #0
 800699c:	d0f9      	beq.n	8006992 <main+0x7aa>
			if(outputs[i].htim != NULL)
 800699e:	6833      	ldr	r3, [r6, #0]
				HAL_TIM_PWM_Start(outputs[i].htim,outputs[i].timChannel);
 80069a0:	4618      	mov	r0, r3
			if(outputs[i].htim != NULL)
 80069a2:	2b00      	cmp	r3, #0
 80069a4:	d1f1      	bne.n	800698a <main+0x7a2>
				outputs[i].outputEnabled = 1;
 80069a6:	76b7      	strb	r7, [r6, #26]
 80069a8:	361c      	adds	r6, #28
	for(int i = 0; i < 64; ++i)
 80069aa:	42b4      	cmp	r4, r6
 80069ac:	d1f4      	bne.n	8006998 <main+0x7b0>
 80069ae:	9b04      	ldr	r3, [sp, #16]
				  pressedDownFlag = 1;
 80069b0:	9a06      	ldr	r2, [sp, #24]
					  pressedCount = 0;
 80069b2:	9306      	str	r3, [sp, #24]
				  pressedDownFlag = 1;
 80069b4:	9204      	str	r2, [sp, #16]
 80069b6:	e651      	b.n	800665c <main+0x474>
				outputs[i].outputEnabled = 1;
 80069b8:	461f      	mov	r7, r3
 80069ba:	4e22      	ldr	r6, [pc, #136]	; (8006a44 <main+0x85c>)
 80069bc:	e006      	b.n	80069cc <main+0x7e4>
				HAL_TIM_PWM_Start(outputs[i].htim,outputs[i].timChannel);
 80069be:	88b1      	ldrh	r1, [r6, #4]
 80069c0:	f7fc f8c8 	bl	8002b54 <HAL_TIM_PWM_Start>
				outputs[i].outputEnabled = 1;
 80069c4:	76b7      	strb	r7, [r6, #26]
 80069c6:	361c      	adds	r6, #28
	for(int i = 0; i < 64; ++i)
 80069c8:	42b4      	cmp	r4, r6
 80069ca:	d00a      	beq.n	80069e2 <main+0x7fa>
		if(outputs[i].isOutputSetByNoteOn)
 80069cc:	7ef3      	ldrb	r3, [r6, #27]
 80069ce:	2b00      	cmp	r3, #0
 80069d0:	d0f9      	beq.n	80069c6 <main+0x7de>
			if(outputs[i].htim != NULL)
 80069d2:	6833      	ldr	r3, [r6, #0]
				HAL_TIM_PWM_Start(outputs[i].htim,outputs[i].timChannel);
 80069d4:	4618      	mov	r0, r3
			if(outputs[i].htim != NULL)
 80069d6:	2b00      	cmp	r3, #0
 80069d8:	d1f1      	bne.n	80069be <main+0x7d6>
				outputs[i].outputEnabled = 1;
 80069da:	76b7      	strb	r7, [r6, #26]
 80069dc:	361c      	adds	r6, #28
	for(int i = 0; i < 64; ++i)
 80069de:	42b4      	cmp	r4, r6
 80069e0:	d1f4      	bne.n	80069cc <main+0x7e4>
				  momentarySwithWasPressed = 0;
 80069e2:	2300      	movs	r3, #0
 80069e4:	9305      	str	r3, [sp, #20]
 80069e6:	e57b      	b.n	80064e0 <main+0x2f8>
		out->outputEnabled = 0;
 80069e8:	4b18      	ldr	r3, [pc, #96]	; (8006a4c <main+0x864>)
 80069ea:	441e      	add	r6, r3
 80069ec:	8070      	strh	r0, [r6, #2]
 80069ee:	e4ef      	b.n	80063d0 <main+0x1e8>
	if(out->htim != NULL)
 80069f0:	b178      	cbz	r0, 8006a12 <main+0x82a>
		HAL_TIM_PWM_Stop(out->htim,out->timChannel);
 80069f2:	8891      	ldrh	r1, [r2, #4]
 80069f4:	9307      	str	r3, [sp, #28]
 80069f6:	f7fc f8dd 	bl	8002bb4 <HAL_TIM_PWM_Stop>
		out->outputEnabled = 0;
 80069fa:	4a14      	ldr	r2, [pc, #80]	; (8006a4c <main+0x864>)
 80069fc:	9b07      	ldr	r3, [sp, #28]
 80069fe:	4413      	add	r3, r2
 8006a00:	9a03      	ldr	r2, [sp, #12]
 8006a02:	805a      	strh	r2, [r3, #2]
 8006a04:	e4e4      	b.n	80063d0 <main+0x1e8>
			setBidirectionalPWM(out, pwm, channel-1);
 8006a06:	b2d2      	uxtb	r2, r2
 8006a08:	9903      	ldr	r1, [sp, #12]
 8006a0a:	9807      	ldr	r0, [sp, #28]
 8006a0c:	f7ff fae0 	bl	8005fd0 <setBidirectionalPWM>
 8006a10:	e4de      	b.n	80063d0 <main+0x1e8>
		out->outputEnabled = 0;
 8006a12:	4a0e      	ldr	r2, [pc, #56]	; (8006a4c <main+0x864>)
 8006a14:	4413      	add	r3, r2
 8006a16:	8058      	strh	r0, [r3, #2]
 8006a18:	e4da      	b.n	80063d0 <main+0x1e8>
		out->outputEnabled = 1;
 8006a1a:	4a0c      	ldr	r2, [pc, #48]	; (8006a4c <main+0x864>)
 8006a1c:	4413      	add	r3, r2
 8006a1e:	f240 1201 	movw	r2, #257	; 0x101
 8006a22:	805a      	strh	r2, [r3, #2]
 8006a24:	e4d4      	b.n	80063d0 <main+0x1e8>
		out->pwmFill = MAX_SOFT_PWM_VAL * pwmValue/127;
 8006a26:	9b03      	ldr	r3, [sp, #12]
 8006a28:	eb03 0643 	add.w	r6, r3, r3, lsl #1
 8006a2c:	4b08      	ldr	r3, [pc, #32]	; (8006a50 <main+0x868>)
 8006a2e:	00b2      	lsls	r2, r6, #2
 8006a30:	fba3 1302 	umull	r1, r3, r3, r2
 8006a34:	1ad2      	subs	r2, r2, r3
 8006a36:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 8006a3a:	9a07      	ldr	r2, [sp, #28]
 8006a3c:	099b      	lsrs	r3, r3, #6
 8006a3e:	7613      	strb	r3, [r2, #24]
 8006a40:	e4c6      	b.n	80063d0 <main+0x1e8>
 8006a42:	bf00      	nop
 8006a44:	20000834 	.word	0x20000834
 8006a48:	20000810 	.word	0x20000810
 8006a4c:	2000084c 	.word	0x2000084c
 8006a50:	02040811 	.word	0x02040811

08006a54 <HAL_TIM_PeriodElapsedCallback>:

/* USER CODE BEGIN 4 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8006a54:	b4f0      	push	{r4, r5, r6, r7}
 8006a56:	4b13      	ldr	r3, [pc, #76]	; (8006aa4 <HAL_TIM_PeriodElapsedCallback+0x50>)
	static int i;
    static uint8_t count = 0;

	for(i = 0; i < 64; ++i)
 8006a58:	4e13      	ldr	r6, [pc, #76]	; (8006aa8 <HAL_TIM_PeriodElapsedCallback+0x54>)
 8006a5a:	f503 65e0 	add.w	r5, r3, #1792	; 0x700
	{
		if(outputs[i].gpio != NULL)
		{
			if(outputs[i].pwmFill > count && outputs[i].outputEnabled)
 8006a5e:	7931      	ldrb	r1, [r6, #4]
 8006a60:	e005      	b.n	8006a6e <HAL_TIM_PeriodElapsedCallback+0x1a>
 8006a62:	7e9f      	ldrb	r7, [r3, #26]
 8006a64:	b167      	cbz	r7, 8006a80 <HAL_TIM_PeriodElapsedCallback+0x2c>
			{
				outputs[i].gpio->BSRR = outputs[i].pin;
 8006a66:	6190      	str	r0, [r2, #24]
 8006a68:	331c      	adds	r3, #28
	for(i = 0; i < 64; ++i)
 8006a6a:	42ab      	cmp	r3, r5
 8006a6c:	d00c      	beq.n	8006a88 <HAL_TIM_PeriodElapsedCallback+0x34>
		if(outputs[i].gpio != NULL)
 8006a6e:	691a      	ldr	r2, [r3, #16]
 8006a70:	2a00      	cmp	r2, #0
 8006a72:	d0f9      	beq.n	8006a68 <HAL_TIM_PeriodElapsedCallback+0x14>
			if(outputs[i].pwmFill > count && outputs[i].outputEnabled)
 8006a74:	7e1c      	ldrb	r4, [r3, #24]
 8006a76:	8a98      	ldrh	r0, [r3, #20]
 8006a78:	428c      	cmp	r4, r1
			}
			else
			{
				outputs[i].gpio->BSRR = (uint32_t)outputs[i].pin << 16;
 8006a7a:	ea4f 4400 	mov.w	r4, r0, lsl #16
			if(outputs[i].pwmFill > count && outputs[i].outputEnabled)
 8006a7e:	d8f0      	bhi.n	8006a62 <HAL_TIM_PeriodElapsedCallback+0xe>
 8006a80:	331c      	adds	r3, #28
				outputs[i].gpio->BSRR = (uint32_t)outputs[i].pin << 16;
 8006a82:	6194      	str	r4, [r2, #24]
	for(i = 0; i < 64; ++i)
 8006a84:	42ab      	cmp	r3, r5
 8006a86:	d1f2      	bne.n	8006a6e <HAL_TIM_PeriodElapsedCallback+0x1a>
			}
		}
	}

	++count;
 8006a88:	3101      	adds	r1, #1
 8006a8a:	2340      	movs	r3, #64	; 0x40
 8006a8c:	b2c9      	uxtb	r1, r1
 8006a8e:	6033      	str	r3, [r6, #0]
	if(count > MAX_SOFT_PWM_VAL)
 8006a90:	290c      	cmp	r1, #12
 8006a92:	d903      	bls.n	8006a9c <HAL_TIM_PeriodElapsedCallback+0x48>
	{
		count = 0;
 8006a94:	2300      	movs	r3, #0
 8006a96:	7133      	strb	r3, [r6, #4]
	}
}
 8006a98:	bcf0      	pop	{r4, r5, r6, r7}
 8006a9a:	4770      	bx	lr
	++count;
 8006a9c:	7131      	strb	r1, [r6, #4]
}
 8006a9e:	bcf0      	pop	{r4, r5, r6, r7}
 8006aa0:	4770      	bx	lr
 8006aa2:	bf00      	nop
 8006aa4:	20000834 	.word	0x20000834
 8006aa8:	2000027c 	.word	0x2000027c

08006aac <HAL_UART_RxCpltCallback>:

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 8006aac:	b570      	push	{r4, r5, r6, lr}
	static midiData_t midiFrame;
	static uint8_t frameFlag = 0;
	if(frameFlag == 3)
 8006aae:	4c21      	ldr	r4, [pc, #132]	; (8006b34 <HAL_UART_RxCpltCallback+0x88>)
{
 8006ab0:	4606      	mov	r6, r0
 8006ab2:	4d21      	ldr	r5, [pc, #132]	; (8006b38 <HAL_UART_RxCpltCallback+0x8c>)
	if(frameFlag == 3)
 8006ab4:	7962      	ldrb	r2, [r4, #5]
 8006ab6:	782b      	ldrb	r3, [r5, #0]
 8006ab8:	2a03      	cmp	r2, #3
 8006aba:	d02e      	beq.n	8006b1a <HAL_UART_RxCpltCallback+0x6e>
	{
		midiFrame.data2 = rxBuff;
		push(&fifo,&midiFrame);
		frameFlag = 0;
	}
	if(frameFlag == 2)
 8006abc:	2a02      	cmp	r2, #2
 8006abe:	d01f      	beq.n	8006b00 <HAL_UART_RxCpltCallback+0x54>
	{
		midiFrame.data1 = rxBuff;
		frameFlag = 3;
	}
	if(frameFlag == 1)
 8006ac0:	2a01      	cmp	r2, #1
 8006ac2:	d105      	bne.n	8006ad0 <HAL_UART_RxCpltCallback+0x24>
	{
		if(midiFrame.channel == (rxBuff << 4))
 8006ac4:	7a62      	ldrb	r2, [r4, #9]
 8006ac6:	ebb2 1f03 	cmp.w	r2, r3, lsl #4
 8006aca:	d030      	beq.n	8006b2e <HAL_UART_RxCpltCallback+0x82>
		{
			frameFlag = 2;
		}
		else
		{
			midiFrame.status = 0;
 8006acc:	2200      	movs	r2, #0
 8006ace:	8122      	strh	r2, [r4, #8]
			midiFrame.channel = 0;
		}
	}
	if(rxBuff == MIDI_STATUS_CC || rxBuff == MIDI_STATUS_NOTE_ON || rxBuff == MIDI_STATUS_NOTE_OFF)
 8006ad0:	f1a3 0208 	sub.w	r2, r3, #8
 8006ad4:	2a01      	cmp	r2, #1
 8006ad6:	d91a      	bls.n	8006b0e <HAL_UART_RxCpltCallback+0x62>
 8006ad8:	2b0b      	cmp	r3, #11
 8006ada:	d018      	beq.n	8006b0e <HAL_UART_RxCpltCallback+0x62>
	{
		midiFrame.status = rxBuff;
		midiFrame.channel = rxBuff<<4;
		frameFlag = 1;
	}
	else if(rxBuff >> 4 == MIDI_STATUS_CC || rxBuff >> 4 == MIDI_STATUS_NOTE_ON || rxBuff >> 4 == MIDI_STATUS_NOTE_OFF)
 8006adc:	091a      	lsrs	r2, r3, #4
 8006ade:	f1a2 0108 	sub.w	r1, r2, #8
 8006ae2:	2901      	cmp	r1, #1
 8006ae4:	d901      	bls.n	8006aea <HAL_UART_RxCpltCallback+0x3e>
 8006ae6:	2a0b      	cmp	r2, #11
 8006ae8:	d103      	bne.n	8006af2 <HAL_UART_RxCpltCallback+0x46>
	{
		midiFrame.status = rxBuff >> 4;
		midiFrame.channel = rxBuff;
		frameFlag = 2;
 8006aea:	2102      	movs	r1, #2
		midiFrame.status = rxBuff >> 4;
 8006aec:	7222      	strb	r2, [r4, #8]
		midiFrame.channel = rxBuff;
 8006aee:	7263      	strb	r3, [r4, #9]
		frameFlag = 2;
 8006af0:	7161      	strb	r1, [r4, #5]
	}
	HAL_UART_Receive_IT(huart,&rxBuff,1);
 8006af2:	4630      	mov	r0, r6
 8006af4:	2201      	movs	r2, #1
 8006af6:	4910      	ldr	r1, [pc, #64]	; (8006b38 <HAL_UART_RxCpltCallback+0x8c>)
}
 8006af8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	HAL_UART_Receive_IT(huart,&rxBuff,1);
 8006afc:	f7fc bb62 	b.w	80031c4 <HAL_UART_Receive_IT>
		frameFlag = 3;
 8006b00:	2203      	movs	r2, #3
		midiFrame.data1 = rxBuff;
 8006b02:	72a3      	strb	r3, [r4, #10]
		frameFlag = 3;
 8006b04:	7162      	strb	r2, [r4, #5]
	if(rxBuff == MIDI_STATUS_CC || rxBuff == MIDI_STATUS_NOTE_ON || rxBuff == MIDI_STATUS_NOTE_OFF)
 8006b06:	f1a3 0208 	sub.w	r2, r3, #8
 8006b0a:	2a01      	cmp	r2, #1
 8006b0c:	d8e4      	bhi.n	8006ad8 <HAL_UART_RxCpltCallback+0x2c>
		midiFrame.channel = rxBuff<<4;
 8006b0e:	0119      	lsls	r1, r3, #4
		frameFlag = 1;
 8006b10:	2201      	movs	r2, #1
		midiFrame.status = rxBuff;
 8006b12:	7223      	strb	r3, [r4, #8]
		midiFrame.channel = rxBuff<<4;
 8006b14:	7261      	strb	r1, [r4, #9]
		frameFlag = 1;
 8006b16:	7162      	strb	r2, [r4, #5]
 8006b18:	e7eb      	b.n	8006af2 <HAL_UART_RxCpltCallback+0x46>
		push(&fifo,&midiFrame);
 8006b1a:	f104 0108 	add.w	r1, r4, #8
 8006b1e:	4807      	ldr	r0, [pc, #28]	; (8006b3c <HAL_UART_RxCpltCallback+0x90>)
		midiFrame.data2 = rxBuff;
 8006b20:	72e3      	strb	r3, [r4, #11]
		push(&fifo,&midiFrame);
 8006b22:	f7fe fa53 	bl	8004fcc <push>
		frameFlag = 0;
 8006b26:	2200      	movs	r2, #0
 8006b28:	782b      	ldrb	r3, [r5, #0]
 8006b2a:	7162      	strb	r2, [r4, #5]
 8006b2c:	e7d0      	b.n	8006ad0 <HAL_UART_RxCpltCallback+0x24>
			frameFlag = 2;
 8006b2e:	2202      	movs	r2, #2
 8006b30:	7162      	strb	r2, [r4, #5]
 8006b32:	e7cd      	b.n	8006ad0 <HAL_UART_RxCpltCallback+0x24>
 8006b34:	2000027c 	.word	0x2000027c
 8006b38:	20000f34 	.word	0x20000f34
 8006b3c:	20000828 	.word	0x20000828

08006b40 <Error_Handler>:
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 8006b40:	4770      	bx	lr
 8006b42:	bf00      	nop

08006b44 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 8006b44:	4b0a      	ldr	r3, [pc, #40]	; (8006b70 <HAL_MspInit+0x2c>)
{
 8006b46:	b082      	sub	sp, #8
  __HAL_RCC_PWR_CLK_ENABLE();
 8006b48:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006b4a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8006b4e:	641a      	str	r2, [r3, #64]	; 0x40
 8006b50:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006b52:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8006b56:	9200      	str	r2, [sp, #0]
 8006b58:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8006b5a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8006b5c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8006b60:	645a      	str	r2, [r3, #68]	; 0x44
 8006b62:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8006b64:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8006b68:	9301      	str	r3, [sp, #4]
 8006b6a:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8006b6c:	b002      	add	sp, #8
 8006b6e:	4770      	bx	lr
 8006b70:	40023800 	.word	0x40023800

08006b74 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8006b74:	4770      	bx	lr
 8006b76:	bf00      	nop

08006b78 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8006b78:	e7fe      	b.n	8006b78 <HardFault_Handler>
 8006b7a:	bf00      	nop

08006b7c <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8006b7c:	e7fe      	b.n	8006b7c <MemManage_Handler>
 8006b7e:	bf00      	nop

08006b80 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8006b80:	e7fe      	b.n	8006b80 <BusFault_Handler>
 8006b82:	bf00      	nop

08006b84 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8006b84:	e7fe      	b.n	8006b84 <UsageFault_Handler>
 8006b86:	bf00      	nop

08006b88 <SVC_Handler>:
 8006b88:	4770      	bx	lr
 8006b8a:	bf00      	nop

08006b8c <DebugMon_Handler>:
 8006b8c:	4770      	bx	lr
 8006b8e:	bf00      	nop

08006b90 <PendSV_Handler>:
 8006b90:	4770      	bx	lr
 8006b92:	bf00      	nop

08006b94 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8006b94:	f7f9 bcea 	b.w	800056c <HAL_IncTick>

08006b98 <TIM6_DAC_IRQHandler>:
void TIM6_DAC_IRQHandler(void)
{
  /* USER CODE BEGIN TIM5_IRQn 0 */

  /* USER CODE END TIM5_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 8006b98:	4801      	ldr	r0, [pc, #4]	; (8006ba0 <TIM6_DAC_IRQHandler+0x8>)
 8006b9a:	f7fc b9dd 	b.w	8002f58 <HAL_TIM_IRQHandler>
 8006b9e:	bf00      	nop
 8006ba0:	200010fc 	.word	0x200010fc

08006ba4 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8006ba4:	4801      	ldr	r0, [pc, #4]	; (8006bac <OTG_FS_IRQHandler+0x8>)
 8006ba6:	f7fa bbcd 	b.w	8001344 <HAL_PCD_IRQHandler>
 8006baa:	bf00      	nop
 8006bac:	20001598 	.word	0x20001598

08006bb0 <UART8_IRQHandler>:
void UART8_IRQHandler(void)
{
  /* USER CODE BEGIN UART8_IRQn 0 */

  /* USER CODE END UART8_IRQn 0 */
  HAL_UART_IRQHandler(&huart8);
 8006bb0:	4801      	ldr	r0, [pc, #4]	; (8006bb8 <UART8_IRQHandler+0x8>)
 8006bb2:	f7fc bbd5 	b.w	8003360 <HAL_UART_IRQHandler>
 8006bb6:	bf00      	nop
 8006bb8:	2000127c 	.word	0x2000127c

08006bbc <_sbrk>:
{
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 8006bbc:	4a0c      	ldr	r2, [pc, #48]	; (8006bf0 <_sbrk+0x34>)
{
 8006bbe:	b508      	push	{r3, lr}
	if (heap_end == 0)
 8006bc0:	6813      	ldr	r3, [r2, #0]
 8006bc2:	b133      	cbz	r3, 8006bd2 <_sbrk+0x16>
		heap_end = &end;

	prev_heap_end = heap_end;
	if (heap_end + incr > stack_ptr)
 8006bc4:	4418      	add	r0, r3
 8006bc6:	4669      	mov	r1, sp
 8006bc8:	4288      	cmp	r0, r1
 8006bca:	d809      	bhi.n	8006be0 <_sbrk+0x24>
//		abort();
		errno = ENOMEM;
		return (caddr_t) -1;
	}

	heap_end += incr;
 8006bcc:	6010      	str	r0, [r2, #0]

	return (caddr_t) prev_heap_end;
}
 8006bce:	4618      	mov	r0, r3
 8006bd0:	bd08      	pop	{r3, pc}
		heap_end = &end;
 8006bd2:	4908      	ldr	r1, [pc, #32]	; (8006bf4 <_sbrk+0x38>)
 8006bd4:	460b      	mov	r3, r1
 8006bd6:	6011      	str	r1, [r2, #0]
	if (heap_end + incr > stack_ptr)
 8006bd8:	4669      	mov	r1, sp
 8006bda:	4418      	add	r0, r3
 8006bdc:	4288      	cmp	r0, r1
 8006bde:	d9f5      	bls.n	8006bcc <_sbrk+0x10>
		errno = ENOMEM;
 8006be0:	f002 fa1e 	bl	8009020 <__errno>
 8006be4:	220c      	movs	r2, #12
		return (caddr_t) -1;
 8006be6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
		errno = ENOMEM;
 8006bea:	6002      	str	r2, [r0, #0]
}
 8006bec:	4618      	mov	r0, r3
 8006bee:	bd08      	pop	{r3, pc}
 8006bf0:	20000288 	.word	0x20000288
 8006bf4:	20002ba0 	.word	0x20002ba0

08006bf8 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006bf8:	4a0f      	ldr	r2, [pc, #60]	; (8006c38 <SystemInit+0x40>)
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8006bfa:	4b10      	ldr	r3, [pc, #64]	; (8006c3c <SystemInit+0x44>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006bfc:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8006c00:	490f      	ldr	r1, [pc, #60]	; (8006c40 <SystemInit+0x48>)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006c02:	f440 0070 	orr.w	r0, r0, #15728640	; 0xf00000
{
 8006c06:	b470      	push	{r4, r5, r6}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006c08:	f8c2 0088 	str.w	r0, [r2, #136]	; 0x88
  RCC->CFGR = 0x00000000;
 8006c0c:	2400      	movs	r4, #0
  RCC->CR |= (uint32_t)0x00000001;
 8006c0e:	6818      	ldr	r0, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8006c10:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
  RCC->PLLCFGR = 0x24003010;
 8006c14:	4e0b      	ldr	r6, [pc, #44]	; (8006c44 <SystemInit+0x4c>)
  RCC->CR |= (uint32_t)0x00000001;
 8006c16:	f040 0001 	orr.w	r0, r0, #1
 8006c1a:	6018      	str	r0, [r3, #0]
  RCC->CFGR = 0x00000000;
 8006c1c:	609c      	str	r4, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8006c1e:	6818      	ldr	r0, [r3, #0]
 8006c20:	4001      	ands	r1, r0
 8006c22:	6019      	str	r1, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 8006c24:	605e      	str	r6, [r3, #4]
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8006c26:	6819      	ldr	r1, [r3, #0]
 8006c28:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8006c2c:	6019      	str	r1, [r3, #0]
  RCC->CIR = 0x00000000;
 8006c2e:	60dc      	str	r4, [r3, #12]
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8006c30:	6095      	str	r5, [r2, #8]
#endif
}
 8006c32:	bc70      	pop	{r4, r5, r6}
 8006c34:	4770      	bx	lr
 8006c36:	bf00      	nop
 8006c38:	e000ed00 	.word	0xe000ed00
 8006c3c:	40023800 	.word	0x40023800
 8006c40:	fef6ffff 	.word	0xfef6ffff
 8006c44:	24003010 	.word	0x24003010

08006c48 <MX_TIM1_Init>:
TIM_HandleTypeDef htim13;
TIM_HandleTypeDef htim14;

/* TIM1 init function */
void MX_TIM1_Init(void)
{
 8006c48:	b570      	push	{r4, r5, r6, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};

  htim1.Instance = TIM1;
 8006c4a:	489f      	ldr	r0, [pc, #636]	; (8006ec8 <MX_TIM1_Init+0x280>)
  htim1.Init.Prescaler = 112;
 8006c4c:	2170      	movs	r1, #112	; 0x70
  htim1.Instance = TIM1;
 8006c4e:	4c9f      	ldr	r4, [pc, #636]	; (8006ecc <MX_TIM1_Init+0x284>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006c50:	2300      	movs	r3, #0
{
 8006c52:	b09a      	sub	sp, #104	; 0x68
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 127;
 8006c54:	227f      	movs	r2, #127	; 0x7f
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8006c56:	61a3      	str	r3, [r4, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006c58:	930b      	str	r3, [sp, #44]	; 0x2c
  TIM_OC_InitTypeDef sConfigOC = {0};
 8006c5a:	9313      	str	r3, [sp, #76]	; 0x4c
  htim1.Init.Prescaler = 112;
 8006c5c:	e9c4 0100 	strd	r0, r1, [r4]
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8006c60:	4620      	mov	r0, r4
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8006c62:	e9c4 3202 	strd	r3, r2, [r4, #8]
  htim1.Init.RepetitionCounter = 0;
 8006c66:	e9c4 3304 	strd	r3, r3, [r4, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006c6a:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  TIM_OC_InitTypeDef sConfigOC = {0};
 8006c6e:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
 8006c72:	e9cd 3316 	strd	r3, r3, [sp, #88]	; 0x58
 8006c76:	e9cd 3318 	strd	r3, r3, [sp, #96]	; 0x60
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8006c7a:	f7fb fee7 	bl	8002a4c <HAL_TIM_PWM_Init>
 8006c7e:	2800      	cmp	r0, #0
 8006c80:	d168      	bne.n	8006d54 <MX_TIM1_Init+0x10c>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006c82:	2300      	movs	r3, #0
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8006c84:	a90b      	add	r1, sp, #44	; 0x2c
 8006c86:	4891      	ldr	r0, [pc, #580]	; (8006ecc <MX_TIM1_Init+0x284>)
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8006c88:	930d      	str	r3, [sp, #52]	; 0x34
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 8006c8a:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8006c8e:	f7fc fa1b 	bl	80030c8 <HAL_TIMEx_MasterConfigSynchronization>
 8006c92:	2800      	cmp	r0, #0
 8006c94:	d15b      	bne.n	8006d4e <MX_TIM1_Init+0x106>
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
 8006c96:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8006c98:	2560      	movs	r5, #96	; 0x60
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8006c9a:	a913      	add	r1, sp, #76	; 0x4c
 8006c9c:	488b      	ldr	r0, [pc, #556]	; (8006ecc <MX_TIM1_Init+0x284>)
 8006c9e:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
 8006ca0:	9314      	str	r3, [sp, #80]	; 0x50
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8006ca2:	9319      	str	r3, [sp, #100]	; 0x64
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8006ca4:	9513      	str	r5, [sp, #76]	; 0x4c
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8006ca6:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8006caa:	e9cd 3317 	strd	r3, r3, [sp, #92]	; 0x5c
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8006cae:	f7fb ffbd 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 8006cb2:	2800      	cmp	r0, #0
 8006cb4:	d148      	bne.n	8006d48 <MX_TIM1_Init+0x100>
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8006cb6:	2204      	movs	r2, #4
 8006cb8:	a913      	add	r1, sp, #76	; 0x4c
 8006cba:	4884      	ldr	r0, [pc, #528]	; (8006ecc <MX_TIM1_Init+0x284>)
 8006cbc:	f7fb ffb6 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 8006cc0:	2800      	cmp	r0, #0
 8006cc2:	d13e      	bne.n	8006d42 <MX_TIM1_Init+0xfa>
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 8006cc4:	2208      	movs	r2, #8
 8006cc6:	a913      	add	r1, sp, #76	; 0x4c
 8006cc8:	4880      	ldr	r0, [pc, #512]	; (8006ecc <MX_TIM1_Init+0x284>)
 8006cca:	f7fb ffaf 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 8006cce:	2800      	cmp	r0, #0
 8006cd0:	d134      	bne.n	8006d3c <MX_TIM1_Init+0xf4>
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8006cd2:	a913      	add	r1, sp, #76	; 0x4c
 8006cd4:	220c      	movs	r2, #12
 8006cd6:	487d      	ldr	r0, [pc, #500]	; (8006ecc <MX_TIM1_Init+0x284>)
 8006cd8:	f7fb ffa8 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 8006cdc:	b108      	cbz	r0, 8006ce2 <MX_TIM1_Init+0x9a>
  {
    Error_Handler();
 8006cde:	f7ff ff2f 	bl	8006b40 <Error_Handler>
}
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM1)
 8006ce2:	6823      	ldr	r3, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006ce4:	2400      	movs	r4, #0
  if(timHandle->Instance==TIM1)
 8006ce6:	4a78      	ldr	r2, [pc, #480]	; (8006ec8 <MX_TIM1_Init+0x280>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006ce8:	9412      	str	r4, [sp, #72]	; 0x48
  if(timHandle->Instance==TIM1)
 8006cea:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006cec:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
 8006cf0:	e9cd 4410 	strd	r4, r4, [sp, #64]	; 0x40
  if(timHandle->Instance==TIM1)
 8006cf4:	d045      	beq.n	8006d82 <MX_TIM1_Init+0x13a>

  /* USER CODE BEGIN TIM1_MspPostInit 1 */

  /* USER CODE END TIM1_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM2)
 8006cf6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006cfa:	d059      	beq.n	8006db0 <MX_TIM1_Init+0x168>

  /* USER CODE BEGIN TIM2_MspPostInit 1 */

  /* USER CODE END TIM2_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM3)
 8006cfc:	4a74      	ldr	r2, [pc, #464]	; (8006ed0 <MX_TIM1_Init+0x288>)
 8006cfe:	4293      	cmp	r3, r2
 8006d00:	d07b      	beq.n	8006dfa <MX_TIM1_Init+0x1b2>

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM4)
 8006d02:	4a74      	ldr	r2, [pc, #464]	; (8006ed4 <MX_TIM1_Init+0x28c>)
 8006d04:	4293      	cmp	r3, r2
 8006d06:	f000 808b 	beq.w	8006e20 <MX_TIM1_Init+0x1d8>

  /* USER CODE BEGIN TIM4_MspPostInit 1 */

  /* USER CODE END TIM4_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM5)
 8006d0a:	4a73      	ldr	r2, [pc, #460]	; (8006ed8 <MX_TIM1_Init+0x290>)
 8006d0c:	4293      	cmp	r3, r2
 8006d0e:	d024      	beq.n	8006d5a <MX_TIM1_Init+0x112>

  /* USER CODE BEGIN TIM4_MspPostInit 1 */

  /* USER CODE END TIM4_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM8)
 8006d10:	4a72      	ldr	r2, [pc, #456]	; (8006edc <MX_TIM1_Init+0x294>)
 8006d12:	4293      	cmp	r3, r2
 8006d14:	f000 8099 	beq.w	8006e4a <MX_TIM1_Init+0x202>

  /* USER CODE BEGIN TIM8_MspPostInit 1 */

  /* USER CODE END TIM8_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM9)
 8006d18:	4a71      	ldr	r2, [pc, #452]	; (8006ee0 <MX_TIM1_Init+0x298>)
 8006d1a:	4293      	cmp	r3, r2
 8006d1c:	f000 80ab 	beq.w	8006e76 <MX_TIM1_Init+0x22e>

  /* USER CODE BEGIN TIM9_MspPostInit 1 */

  /* USER CODE END TIM9_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM10)
 8006d20:	4a70      	ldr	r2, [pc, #448]	; (8006ee4 <MX_TIM1_Init+0x29c>)
 8006d22:	4293      	cmp	r3, r2
 8006d24:	f000 80f0 	beq.w	8006f08 <MX_TIM1_Init+0x2c0>

  /* USER CODE BEGIN TIM10_MspPostInit 1 */

  /* USER CODE END TIM10_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM11)
 8006d28:	4a6f      	ldr	r2, [pc, #444]	; (8006ee8 <MX_TIM1_Init+0x2a0>)
 8006d2a:	4293      	cmp	r3, r2
 8006d2c:	f000 8100 	beq.w	8006f30 <MX_TIM1_Init+0x2e8>

  /* USER CODE BEGIN TIM11_MspPostInit 1 */

  /* USER CODE END TIM11_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM12)
 8006d30:	4a6e      	ldr	r2, [pc, #440]	; (8006eec <MX_TIM1_Init+0x2a4>)
 8006d32:	4293      	cmp	r3, r2
 8006d34:	f000 80b4 	beq.w	8006ea0 <MX_TIM1_Init+0x258>
}
 8006d38:	b01a      	add	sp, #104	; 0x68
 8006d3a:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 8006d3c:	f7ff ff00 	bl	8006b40 <Error_Handler>
 8006d40:	e7c7      	b.n	8006cd2 <MX_TIM1_Init+0x8a>
    Error_Handler();
 8006d42:	f7ff fefd 	bl	8006b40 <Error_Handler>
 8006d46:	e7bd      	b.n	8006cc4 <MX_TIM1_Init+0x7c>
    Error_Handler();
 8006d48:	f7ff fefa 	bl	8006b40 <Error_Handler>
 8006d4c:	e7b3      	b.n	8006cb6 <MX_TIM1_Init+0x6e>
    Error_Handler();
 8006d4e:	f7ff fef7 	bl	8006b40 <Error_Handler>
 8006d52:	e7a0      	b.n	8006c96 <MX_TIM1_Init+0x4e>
    Error_Handler();
 8006d54:	f7ff fef4 	bl	8006b40 <Error_Handler>
 8006d58:	e793      	b.n	8006c82 <MX_TIM1_Init+0x3a>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006d5a:	4b65      	ldr	r3, [pc, #404]	; (8006ef0 <MX_TIM1_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006d5c:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8006d5e:	250f      	movs	r5, #15
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006d60:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006d62:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006d64:	4863      	ldr	r0, [pc, #396]	; (8006ef4 <MX_TIM1_Init+0x2ac>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006d66:	f042 0201 	orr.w	r2, r2, #1
 8006d6a:	631a      	str	r2, [r3, #48]	; 0x30
 8006d6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8006d6e:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006d70:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006d74:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 8006d76:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006d78:	9305      	str	r3, [sp, #20]
 8006d7a:	9b05      	ldr	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8006d7c:	f7f9 fee8 	bl	8000b50 <HAL_GPIO_Init>
 8006d80:	e7da      	b.n	8006d38 <MX_TIM1_Init+0xf0>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006d82:	4b5b      	ldr	r3, [pc, #364]	; (8006ef0 <MX_TIM1_Init+0x2a8>)
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8006d84:	f44f 46d4 	mov.w	r6, #27136	; 0x6a00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006d88:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8006d8a:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006d8c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8006d8e:	2401      	movs	r4, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8006d90:	4859      	ldr	r0, [pc, #356]	; (8006ef8 <MX_TIM1_Init+0x2b0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006d92:	f042 0210 	orr.w	r2, r2, #16
 8006d96:	631a      	str	r2, [r3, #48]	; 0x30
 8006d98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8006d9a:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006d9c:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006da0:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8006da2:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006da4:	9300      	str	r3, [sp, #0]
 8006da6:	9b00      	ldr	r3, [sp, #0]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8006da8:	f7f9 fed2 	bl	8000b50 <HAL_GPIO_Init>
}
 8006dac:	b01a      	add	sp, #104	; 0x68
 8006dae:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006db0:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8006db4:	2601      	movs	r6, #1
    GPIO_InitStruct.Pin = PWM14_Pin;
 8006db6:	2502      	movs	r5, #2
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8006db8:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006dba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8006dbc:	484d      	ldr	r0, [pc, #308]	; (8006ef4 <MX_TIM1_Init+0x2ac>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8006dbe:	4332      	orrs	r2, r6
 8006dc0:	631a      	str	r2, [r3, #48]	; 0x30
 8006dc2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006dc4:	4032      	ands	r2, r6
 8006dc6:	9201      	str	r2, [sp, #4]
 8006dc8:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006dca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8006dcc:	432a      	orrs	r2, r5
 8006dce:	631a      	str	r2, [r3, #48]	; 0x30
 8006dd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM14_Pin;
 8006dd2:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006dd4:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006dd6:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8006dd8:	9612      	str	r6, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006dda:	9302      	str	r3, [sp, #8]
 8006ddc:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8006dde:	f7f9 feb7 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = PWM58_Pin;
 8006de2:	2308      	movs	r3, #8
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8006de4:	a90e      	add	r1, sp, #56	; 0x38
 8006de6:	4845      	ldr	r0, [pc, #276]	; (8006efc <MX_TIM1_Init+0x2b4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006de8:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8006dea:	9612      	str	r6, [sp, #72]	; 0x48
    GPIO_InitStruct.Pin = PWM58_Pin;
 8006dec:	930e      	str	r3, [sp, #56]	; 0x38
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8006dee:	e9cd 4410 	strd	r4, r4, [sp, #64]	; 0x40
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8006df2:	f7f9 fead 	bl	8000b50 <HAL_GPIO_Init>
}
 8006df6:	b01a      	add	sp, #104	; 0x68
 8006df8:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006dfa:	4b3d      	ldr	r3, [pc, #244]	; (8006ef0 <MX_TIM1_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006dfc:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 8006dfe:	2533      	movs	r5, #51	; 0x33
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006e00:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006e02:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006e04:	483d      	ldr	r0, [pc, #244]	; (8006efc <MX_TIM1_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006e06:	4322      	orrs	r2, r4
 8006e08:	631a      	str	r2, [r3, #48]	; 0x30
 8006e0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 8006e0c:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006e0e:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006e10:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8006e12:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006e14:	9303      	str	r3, [sp, #12]
 8006e16:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006e18:	f7f9 fe9a 	bl	8000b50 <HAL_GPIO_Init>
}
 8006e1c:	b01a      	add	sp, #104	; 0x68
 8006e1e:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8006e20:	4b33      	ldr	r3, [pc, #204]	; (8006ef0 <MX_TIM1_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006e22:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8006e24:	f44f 4540 	mov.w	r5, #49152	; 0xc000
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8006e28:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8006e2a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8006e2c:	4834      	ldr	r0, [pc, #208]	; (8006f00 <MX_TIM1_Init+0x2b8>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8006e2e:	f042 0208 	orr.w	r2, r2, #8
 8006e32:	631a      	str	r2, [r3, #48]	; 0x30
 8006e34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8006e36:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8006e38:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006e3c:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 8006e3e:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8006e40:	9304      	str	r3, [sp, #16]
 8006e42:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8006e44:	f7f9 fe84 	bl	8000b50 <HAL_GPIO_Init>
 8006e48:	e776      	b.n	8006d38 <MX_TIM1_Init+0xf0>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006e4a:	4b29      	ldr	r3, [pc, #164]	; (8006ef0 <MX_TIM1_Init+0x2a8>)
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8006e4c:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006e50:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8006e52:	2403      	movs	r4, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006e54:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006e56:	a90e      	add	r1, sp, #56	; 0x38
 8006e58:	482a      	ldr	r0, [pc, #168]	; (8006f04 <MX_TIM1_Init+0x2bc>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006e5a:	f042 0204 	orr.w	r2, r2, #4
 8006e5e:	631a      	str	r2, [r3, #48]	; 0x30
 8006e60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8006e62:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006e64:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006e68:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8006e6a:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8006e6c:	9306      	str	r3, [sp, #24]
 8006e6e:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8006e70:	f7f9 fe6e 	bl	8000b50 <HAL_GPIO_Init>
 8006e74:	e760      	b.n	8006d38 <MX_TIM1_Init+0xf0>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006e76:	4b1e      	ldr	r3, [pc, #120]	; (8006ef0 <MX_TIM1_Init+0x2a8>)
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8006e78:	2660      	movs	r6, #96	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006e7a:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8006e7c:	2403      	movs	r4, #3
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006e7e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8006e80:	a90e      	add	r1, sp, #56	; 0x38
 8006e82:	481d      	ldr	r0, [pc, #116]	; (8006ef8 <MX_TIM1_Init+0x2b0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006e84:	f042 0210 	orr.w	r2, r2, #16
 8006e88:	631a      	str	r2, [r3, #48]	; 0x30
 8006e8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8006e8c:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006e8e:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006e92:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8006e94:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8006e96:	9307      	str	r3, [sp, #28]
 8006e98:	9b07      	ldr	r3, [sp, #28]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8006e9a:	f7f9 fe59 	bl	8000b50 <HAL_GPIO_Init>
 8006e9e:	e74b      	b.n	8006d38 <MX_TIM1_Init+0xf0>
  {
  /* USER CODE BEGIN TIM12_MspPostInit 0 */

  /* USER CODE END TIM12_MspPostInit 0 */
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006ea0:	4b13      	ldr	r3, [pc, #76]	; (8006ef0 <MX_TIM1_Init+0x2a8>)
    /**TIM12 GPIO Configuration    
    PB14     ------> TIM12_CH1
    PB15     ------> TIM12_CH2 
    */
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006ea2:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 8006ea4:	f44f 4640 	mov.w	r6, #49152	; 0xc000
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8006ea8:	2409      	movs	r4, #9
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006eaa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006eac:	a90e      	add	r1, sp, #56	; 0x38
 8006eae:	4813      	ldr	r0, [pc, #76]	; (8006efc <MX_TIM1_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006eb0:	432a      	orrs	r2, r5
 8006eb2:	631a      	str	r2, [r3, #48]	; 0x30
 8006eb4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 8006eb6:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006eb8:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006eba:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8006ebc:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006ebe:	930a      	str	r3, [sp, #40]	; 0x28
 8006ec0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8006ec2:	f7f9 fe45 	bl	8000b50 <HAL_GPIO_Init>
}
 8006ec6:	e737      	b.n	8006d38 <MX_TIM1_Init+0xf0>
 8006ec8:	40010000 	.word	0x40010000
 8006ecc:	2000113c 	.word	0x2000113c
 8006ed0:	40000400 	.word	0x40000400
 8006ed4:	40000800 	.word	0x40000800
 8006ed8:	40000c00 	.word	0x40000c00
 8006edc:	40010400 	.word	0x40010400
 8006ee0:	40014000 	.word	0x40014000
 8006ee4:	40014400 	.word	0x40014400
 8006ee8:	40014800 	.word	0x40014800
 8006eec:	40001800 	.word	0x40001800
 8006ef0:	40023800 	.word	0x40023800
 8006ef4:	40020000 	.word	0x40020000
 8006ef8:	40021000 	.word	0x40021000
 8006efc:	40020400 	.word	0x40020400
 8006f00:	40020c00 	.word	0x40020c00
 8006f04:	40020800 	.word	0x40020800
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f08:	4b13      	ldr	r3, [pc, #76]	; (8006f58 <MX_TIM1_Init+0x310>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006f0a:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM61_Pin;
 8006f0c:	f44f 7680 	mov.w	r6, #256	; 0x100
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8006f10:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f12:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 8006f14:	a90e      	add	r1, sp, #56	; 0x38
 8006f16:	4811      	ldr	r0, [pc, #68]	; (8006f5c <MX_TIM1_Init+0x314>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f18:	432a      	orrs	r2, r5
 8006f1a:	631a      	str	r2, [r3, #48]	; 0x30
 8006f1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM61_Pin;
 8006f1e:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f20:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006f22:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8006f24:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f26:	9308      	str	r3, [sp, #32]
 8006f28:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 8006f2a:	f7f9 fe11 	bl	8000b50 <HAL_GPIO_Init>
 8006f2e:	e703      	b.n	8006d38 <MX_TIM1_Init+0xf0>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f30:	4b09      	ldr	r3, [pc, #36]	; (8006f58 <MX_TIM1_Init+0x310>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006f32:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM62_Pin;
 8006f34:	f44f 7600 	mov.w	r6, #512	; 0x200
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 8006f38:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f3a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8006f3c:	a90e      	add	r1, sp, #56	; 0x38
 8006f3e:	4807      	ldr	r0, [pc, #28]	; (8006f5c <MX_TIM1_Init+0x314>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f40:	432a      	orrs	r2, r5
 8006f42:	631a      	str	r2, [r3, #48]	; 0x30
 8006f44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM62_Pin;
 8006f46:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f48:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8006f4a:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 8006f4c:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8006f4e:	9309      	str	r3, [sp, #36]	; 0x24
 8006f50:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8006f52:	f7f9 fdfd 	bl	8000b50 <HAL_GPIO_Init>
 8006f56:	e6ef      	b.n	8006d38 <MX_TIM1_Init+0xf0>
 8006f58:	40023800 	.word	0x40023800
 8006f5c:	40020400 	.word	0x40020400

08006f60 <MX_TIM2_Init>:
{
 8006f60:	b570      	push	{r4, r5, r6, lr}
  htim2.Instance = TIM2;
 8006f62:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8006f66:	4ca6      	ldr	r4, [pc, #664]	; (8007200 <MX_TIM2_Init+0x2a0>)
  htim2.Init.Prescaler = 56;
 8006f68:	2138      	movs	r1, #56	; 0x38
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006f6a:	2300      	movs	r3, #0
{
 8006f6c:	b09a      	sub	sp, #104	; 0x68
  htim2.Init.Period = 127;
 8006f6e:	227f      	movs	r2, #127	; 0x7f
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8006f70:	6123      	str	r3, [r4, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006f72:	930b      	str	r3, [sp, #44]	; 0x2c
  TIM_OC_InitTypeDef sConfigOC = {0};
 8006f74:	9313      	str	r3, [sp, #76]	; 0x4c
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8006f76:	61a3      	str	r3, [r4, #24]
  htim2.Init.Prescaler = 56;
 8006f78:	e9c4 0100 	strd	r0, r1, [r4]
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 8006f7c:	4620      	mov	r0, r4
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8006f7e:	e9c4 3202 	strd	r3, r2, [r4, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8006f82:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  TIM_OC_InitTypeDef sConfigOC = {0};
 8006f86:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
 8006f8a:	e9cd 3316 	strd	r3, r3, [sp, #88]	; 0x58
 8006f8e:	e9cd 3318 	strd	r3, r3, [sp, #96]	; 0x60
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 8006f92:	f7fb fd5b 	bl	8002a4c <HAL_TIM_PWM_Init>
 8006f96:	2800      	cmp	r0, #0
 8006f98:	d150      	bne.n	800703c <MX_TIM2_Init+0xdc>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006f9a:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8006f9c:	a90b      	add	r1, sp, #44	; 0x2c
 8006f9e:	4898      	ldr	r0, [pc, #608]	; (8007200 <MX_TIM2_Init+0x2a0>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8006fa0:	930b      	str	r3, [sp, #44]	; 0x2c
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8006fa2:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8006fa4:	f7fc f890 	bl	80030c8 <HAL_TIMEx_MasterConfigSynchronization>
 8006fa8:	2800      	cmp	r0, #0
 8006faa:	d144      	bne.n	8007036 <MX_TIM2_Init+0xd6>
  sConfigOC.Pulse = 0;
 8006fac:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8006fae:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8006fb0:	a913      	add	r1, sp, #76	; 0x4c
 8006fb2:	4893      	ldr	r0, [pc, #588]	; (8007200 <MX_TIM2_Init+0x2a0>)
 8006fb4:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
 8006fb6:	9314      	str	r3, [sp, #80]	; 0x50
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8006fb8:	9315      	str	r3, [sp, #84]	; 0x54
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8006fba:	9317      	str	r3, [sp, #92]	; 0x5c
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8006fbc:	9513      	str	r5, [sp, #76]	; 0x4c
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8006fbe:	f7fb fe35 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 8006fc2:	2800      	cmp	r0, #0
 8006fc4:	d134      	bne.n	8007030 <MX_TIM2_Init+0xd0>
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8006fc6:	a913      	add	r1, sp, #76	; 0x4c
 8006fc8:	2204      	movs	r2, #4
 8006fca:	488d      	ldr	r0, [pc, #564]	; (8007200 <MX_TIM2_Init+0x2a0>)
 8006fcc:	f7fb fe2e 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 8006fd0:	b108      	cbz	r0, 8006fd6 <MX_TIM2_Init+0x76>
    Error_Handler();
 8006fd2:	f7ff fdb5 	bl	8006b40 <Error_Handler>
  if(timHandle->Instance==TIM1)
 8006fd6:	6823      	ldr	r3, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006fd8:	2400      	movs	r4, #0
  if(timHandle->Instance==TIM1)
 8006fda:	4a8a      	ldr	r2, [pc, #552]	; (8007204 <MX_TIM2_Init+0x2a4>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006fdc:	9412      	str	r4, [sp, #72]	; 0x48
  if(timHandle->Instance==TIM1)
 8006fde:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006fe0:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
 8006fe4:	e9cd 4410 	strd	r4, r4, [sp, #64]	; 0x40
  if(timHandle->Instance==TIM1)
 8006fe8:	d03f      	beq.n	800706a <MX_TIM2_Init+0x10a>
  else if(timHandle->Instance==TIM2)
 8006fea:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006fee:	d053      	beq.n	8007098 <MX_TIM2_Init+0x138>
  else if(timHandle->Instance==TIM3)
 8006ff0:	4a85      	ldr	r2, [pc, #532]	; (8007208 <MX_TIM2_Init+0x2a8>)
 8006ff2:	4293      	cmp	r3, r2
 8006ff4:	d075      	beq.n	80070e2 <MX_TIM2_Init+0x182>
  else if(timHandle->Instance==TIM4)
 8006ff6:	4a85      	ldr	r2, [pc, #532]	; (800720c <MX_TIM2_Init+0x2ac>)
 8006ff8:	4293      	cmp	r3, r2
 8006ffa:	f000 8085 	beq.w	8007108 <MX_TIM2_Init+0x1a8>
  else if(timHandle->Instance==TIM5)
 8006ffe:	4a84      	ldr	r2, [pc, #528]	; (8007210 <MX_TIM2_Init+0x2b0>)
 8007000:	4293      	cmp	r3, r2
 8007002:	d01e      	beq.n	8007042 <MX_TIM2_Init+0xe2>
  else if(timHandle->Instance==TIM8)
 8007004:	4a83      	ldr	r2, [pc, #524]	; (8007214 <MX_TIM2_Init+0x2b4>)
 8007006:	4293      	cmp	r3, r2
 8007008:	f000 8093 	beq.w	8007132 <MX_TIM2_Init+0x1d2>
  else if(timHandle->Instance==TIM9)
 800700c:	4a82      	ldr	r2, [pc, #520]	; (8007218 <MX_TIM2_Init+0x2b8>)
 800700e:	4293      	cmp	r3, r2
 8007010:	f000 80a5 	beq.w	800715e <MX_TIM2_Init+0x1fe>
  else if(timHandle->Instance==TIM10)
 8007014:	4a81      	ldr	r2, [pc, #516]	; (800721c <MX_TIM2_Init+0x2bc>)
 8007016:	4293      	cmp	r3, r2
 8007018:	f000 80ca 	beq.w	80071b0 <MX_TIM2_Init+0x250>
  else if(timHandle->Instance==TIM11)
 800701c:	4a80      	ldr	r2, [pc, #512]	; (8007220 <MX_TIM2_Init+0x2c0>)
 800701e:	4293      	cmp	r3, r2
 8007020:	f000 80da 	beq.w	80071d8 <MX_TIM2_Init+0x278>
  else if(timHandle->Instance==TIM12)
 8007024:	4a7f      	ldr	r2, [pc, #508]	; (8007224 <MX_TIM2_Init+0x2c4>)
 8007026:	4293      	cmp	r3, r2
 8007028:	f000 80ae 	beq.w	8007188 <MX_TIM2_Init+0x228>
}
 800702c:	b01a      	add	sp, #104	; 0x68
 800702e:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 8007030:	f7ff fd86 	bl	8006b40 <Error_Handler>
 8007034:	e7c7      	b.n	8006fc6 <MX_TIM2_Init+0x66>
    Error_Handler();
 8007036:	f7ff fd83 	bl	8006b40 <Error_Handler>
 800703a:	e7b7      	b.n	8006fac <MX_TIM2_Init+0x4c>
    Error_Handler();
 800703c:	f7ff fd80 	bl	8006b40 <Error_Handler>
 8007040:	e7ab      	b.n	8006f9a <MX_TIM2_Init+0x3a>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007042:	4b79      	ldr	r3, [pc, #484]	; (8007228 <MX_TIM2_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007044:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8007046:	250f      	movs	r5, #15
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007048:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800704a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800704c:	4877      	ldr	r0, [pc, #476]	; (800722c <MX_TIM2_Init+0x2cc>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800704e:	f042 0201 	orr.w	r2, r2, #1
 8007052:	631a      	str	r2, [r3, #48]	; 0x30
 8007054:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8007056:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007058:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800705c:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 800705e:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007060:	9305      	str	r3, [sp, #20]
 8007062:	9b05      	ldr	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007064:	f7f9 fd74 	bl	8000b50 <HAL_GPIO_Init>
 8007068:	e7e0      	b.n	800702c <MX_TIM2_Init+0xcc>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800706a:	4b6f      	ldr	r3, [pc, #444]	; (8007228 <MX_TIM2_Init+0x2c8>)
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 800706c:	f44f 46d4 	mov.w	r6, #27136	; 0x6a00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007070:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007072:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007074:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8007076:	2401      	movs	r4, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007078:	486d      	ldr	r0, [pc, #436]	; (8007230 <MX_TIM2_Init+0x2d0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800707a:	f042 0210 	orr.w	r2, r2, #16
 800707e:	631a      	str	r2, [r3, #48]	; 0x30
 8007080:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8007082:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007084:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007088:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 800708a:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800708c:	9300      	str	r3, [sp, #0]
 800708e:	9b00      	ldr	r3, [sp, #0]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007090:	f7f9 fd5e 	bl	8000b50 <HAL_GPIO_Init>
}
 8007094:	b01a      	add	sp, #104	; 0x68
 8007096:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007098:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 800709c:	2601      	movs	r6, #1
    GPIO_InitStruct.Pin = PWM14_Pin;
 800709e:	2502      	movs	r5, #2
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80070a0:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80070a2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80070a4:	4861      	ldr	r0, [pc, #388]	; (800722c <MX_TIM2_Init+0x2cc>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80070a6:	4332      	orrs	r2, r6
 80070a8:	631a      	str	r2, [r3, #48]	; 0x30
 80070aa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80070ac:	4032      	ands	r2, r6
 80070ae:	9201      	str	r2, [sp, #4]
 80070b0:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80070b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80070b4:	432a      	orrs	r2, r5
 80070b6:	631a      	str	r2, [r3, #48]	; 0x30
 80070b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM14_Pin;
 80070ba:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80070bc:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80070be:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80070c0:	9612      	str	r6, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80070c2:	9302      	str	r3, [sp, #8]
 80070c4:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80070c6:	f7f9 fd43 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = PWM58_Pin;
 80070ca:	2308      	movs	r3, #8
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 80070cc:	a90e      	add	r1, sp, #56	; 0x38
 80070ce:	4859      	ldr	r0, [pc, #356]	; (8007234 <MX_TIM2_Init+0x2d4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80070d0:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80070d2:	9612      	str	r6, [sp, #72]	; 0x48
    GPIO_InitStruct.Pin = PWM58_Pin;
 80070d4:	930e      	str	r3, [sp, #56]	; 0x38
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80070d6:	e9cd 4410 	strd	r4, r4, [sp, #64]	; 0x40
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 80070da:	f7f9 fd39 	bl	8000b50 <HAL_GPIO_Init>
}
 80070de:	b01a      	add	sp, #104	; 0x68
 80070e0:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80070e2:	4b51      	ldr	r3, [pc, #324]	; (8007228 <MX_TIM2_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80070e4:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 80070e6:	2533      	movs	r5, #51	; 0x33
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80070e8:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80070ea:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80070ec:	4851      	ldr	r0, [pc, #324]	; (8007234 <MX_TIM2_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80070ee:	4322      	orrs	r2, r4
 80070f0:	631a      	str	r2, [r3, #48]	; 0x30
 80070f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 80070f4:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80070f6:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80070f8:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 80070fa:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80070fc:	9303      	str	r3, [sp, #12]
 80070fe:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007100:	f7f9 fd26 	bl	8000b50 <HAL_GPIO_Init>
}
 8007104:	b01a      	add	sp, #104	; 0x68
 8007106:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007108:	4b47      	ldr	r3, [pc, #284]	; (8007228 <MX_TIM2_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800710a:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 800710c:	f44f 4540 	mov.w	r5, #49152	; 0xc000
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007110:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007112:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007114:	4848      	ldr	r0, [pc, #288]	; (8007238 <MX_TIM2_Init+0x2d8>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007116:	f042 0208 	orr.w	r2, r2, #8
 800711a:	631a      	str	r2, [r3, #48]	; 0x30
 800711c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 800711e:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007120:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007124:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 8007126:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007128:	9304      	str	r3, [sp, #16]
 800712a:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800712c:	f7f9 fd10 	bl	8000b50 <HAL_GPIO_Init>
 8007130:	e77c      	b.n	800702c <MX_TIM2_Init+0xcc>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007132:	4b3d      	ldr	r3, [pc, #244]	; (8007228 <MX_TIM2_Init+0x2c8>)
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8007134:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007138:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 800713a:	2403      	movs	r4, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800713c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800713e:	a90e      	add	r1, sp, #56	; 0x38
 8007140:	483e      	ldr	r0, [pc, #248]	; (800723c <MX_TIM2_Init+0x2dc>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007142:	f042 0204 	orr.w	r2, r2, #4
 8007146:	631a      	str	r2, [r3, #48]	; 0x30
 8007148:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 800714a:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800714c:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007150:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8007152:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007154:	9306      	str	r3, [sp, #24]
 8007156:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007158:	f7f9 fcfa 	bl	8000b50 <HAL_GPIO_Init>
 800715c:	e766      	b.n	800702c <MX_TIM2_Init+0xcc>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800715e:	4b32      	ldr	r3, [pc, #200]	; (8007228 <MX_TIM2_Init+0x2c8>)
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8007160:	2660      	movs	r6, #96	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007162:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8007164:	2403      	movs	r4, #3
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007166:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007168:	a90e      	add	r1, sp, #56	; 0x38
 800716a:	4831      	ldr	r0, [pc, #196]	; (8007230 <MX_TIM2_Init+0x2d0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800716c:	f042 0210 	orr.w	r2, r2, #16
 8007170:	631a      	str	r2, [r3, #48]	; 0x30
 8007172:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8007174:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007176:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800717a:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 800717c:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800717e:	9307      	str	r3, [sp, #28]
 8007180:	9b07      	ldr	r3, [sp, #28]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007182:	f7f9 fce5 	bl	8000b50 <HAL_GPIO_Init>
 8007186:	e751      	b.n	800702c <MX_TIM2_Init+0xcc>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007188:	4b27      	ldr	r3, [pc, #156]	; (8007228 <MX_TIM2_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800718a:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 800718c:	f44f 4640 	mov.w	r6, #49152	; 0xc000
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8007190:	2409      	movs	r4, #9
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007192:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007194:	a90e      	add	r1, sp, #56	; 0x38
 8007196:	4827      	ldr	r0, [pc, #156]	; (8007234 <MX_TIM2_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007198:	432a      	orrs	r2, r5
 800719a:	631a      	str	r2, [r3, #48]	; 0x30
 800719c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 800719e:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071a0:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80071a2:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 80071a4:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071a6:	930a      	str	r3, [sp, #40]	; 0x28
 80071a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80071aa:	f7f9 fcd1 	bl	8000b50 <HAL_GPIO_Init>
}
 80071ae:	e73d      	b.n	800702c <MX_TIM2_Init+0xcc>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071b0:	4b1d      	ldr	r3, [pc, #116]	; (8007228 <MX_TIM2_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80071b2:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM61_Pin;
 80071b4:	f44f 7680 	mov.w	r6, #256	; 0x100
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 80071b8:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071ba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 80071bc:	a90e      	add	r1, sp, #56	; 0x38
 80071be:	481d      	ldr	r0, [pc, #116]	; (8007234 <MX_TIM2_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071c0:	432a      	orrs	r2, r5
 80071c2:	631a      	str	r2, [r3, #48]	; 0x30
 80071c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM61_Pin;
 80071c6:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071c8:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80071ca:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 80071cc:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071ce:	9308      	str	r3, [sp, #32]
 80071d0:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 80071d2:	f7f9 fcbd 	bl	8000b50 <HAL_GPIO_Init>
 80071d6:	e729      	b.n	800702c <MX_TIM2_Init+0xcc>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071d8:	4b13      	ldr	r3, [pc, #76]	; (8007228 <MX_TIM2_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80071da:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM62_Pin;
 80071dc:	f44f 7600 	mov.w	r6, #512	; 0x200
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 80071e0:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 80071e4:	a90e      	add	r1, sp, #56	; 0x38
 80071e6:	4813      	ldr	r0, [pc, #76]	; (8007234 <MX_TIM2_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071e8:	432a      	orrs	r2, r5
 80071ea:	631a      	str	r2, [r3, #48]	; 0x30
 80071ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM62_Pin;
 80071ee:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071f0:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80071f2:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 80071f4:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80071f6:	9309      	str	r3, [sp, #36]	; 0x24
 80071f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 80071fa:	f7f9 fca9 	bl	8000b50 <HAL_GPIO_Init>
 80071fe:	e715      	b.n	800702c <MX_TIM2_Init+0xcc>
 8007200:	200011bc 	.word	0x200011bc
 8007204:	40010000 	.word	0x40010000
 8007208:	40000400 	.word	0x40000400
 800720c:	40000800 	.word	0x40000800
 8007210:	40000c00 	.word	0x40000c00
 8007214:	40010400 	.word	0x40010400
 8007218:	40014000 	.word	0x40014000
 800721c:	40014400 	.word	0x40014400
 8007220:	40014800 	.word	0x40014800
 8007224:	40001800 	.word	0x40001800
 8007228:	40023800 	.word	0x40023800
 800722c:	40020000 	.word	0x40020000
 8007230:	40021000 	.word	0x40021000
 8007234:	40020400 	.word	0x40020400
 8007238:	40020c00 	.word	0x40020c00
 800723c:	40020800 	.word	0x40020800

08007240 <MX_TIM3_Init>:
{
 8007240:	b570      	push	{r4, r5, r6, lr}
  htim3.Instance = TIM3;
 8007242:	48a7      	ldr	r0, [pc, #668]	; (80074e0 <MX_TIM3_Init+0x2a0>)
  htim3.Init.Prescaler = 56;
 8007244:	2138      	movs	r1, #56	; 0x38
  htim3.Instance = TIM3;
 8007246:	4ca7      	ldr	r4, [pc, #668]	; (80074e4 <MX_TIM3_Init+0x2a4>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007248:	2300      	movs	r3, #0
{
 800724a:	b09a      	sub	sp, #104	; 0x68
  htim3.Init.Period = 127;
 800724c:	227f      	movs	r2, #127	; 0x7f
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800724e:	6123      	str	r3, [r4, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007250:	930b      	str	r3, [sp, #44]	; 0x2c
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007252:	9313      	str	r3, [sp, #76]	; 0x4c
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8007254:	61a3      	str	r3, [r4, #24]
  htim3.Init.Prescaler = 56;
 8007256:	e9c4 0100 	strd	r0, r1, [r4]
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 800725a:	4620      	mov	r0, r4
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 800725c:	e9c4 3202 	strd	r3, r2, [r4, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007260:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007264:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
 8007268:	e9cd 3316 	strd	r3, r3, [sp, #88]	; 0x58
 800726c:	e9cd 3318 	strd	r3, r3, [sp, #96]	; 0x60
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 8007270:	f7fb fbec 	bl	8002a4c <HAL_TIM_PWM_Init>
 8007274:	2800      	cmp	r0, #0
 8007276:	d164      	bne.n	8007342 <MX_TIM3_Init+0x102>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8007278:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 800727a:	a90b      	add	r1, sp, #44	; 0x2c
 800727c:	4899      	ldr	r0, [pc, #612]	; (80074e4 <MX_TIM3_Init+0x2a4>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800727e:	930b      	str	r3, [sp, #44]	; 0x2c
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8007280:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8007282:	f7fb ff21 	bl	80030c8 <HAL_TIMEx_MasterConfigSynchronization>
 8007286:	2800      	cmp	r0, #0
 8007288:	d158      	bne.n	800733c <MX_TIM3_Init+0xfc>
  sConfigOC.Pulse = 0;
 800728a:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800728c:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800728e:	a913      	add	r1, sp, #76	; 0x4c
 8007290:	4894      	ldr	r0, [pc, #592]	; (80074e4 <MX_TIM3_Init+0x2a4>)
 8007292:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
 8007294:	9314      	str	r3, [sp, #80]	; 0x50
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8007296:	9315      	str	r3, [sp, #84]	; 0x54
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8007298:	9317      	str	r3, [sp, #92]	; 0x5c
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800729a:	9513      	str	r5, [sp, #76]	; 0x4c
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800729c:	f7fb fcc6 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80072a0:	2800      	cmp	r0, #0
 80072a2:	d148      	bne.n	8007336 <MX_TIM3_Init+0xf6>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80072a4:	2204      	movs	r2, #4
 80072a6:	a913      	add	r1, sp, #76	; 0x4c
 80072a8:	488e      	ldr	r0, [pc, #568]	; (80074e4 <MX_TIM3_Init+0x2a4>)
 80072aa:	f7fb fcbf 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80072ae:	2800      	cmp	r0, #0
 80072b0:	d13e      	bne.n	8007330 <MX_TIM3_Init+0xf0>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 80072b2:	2208      	movs	r2, #8
 80072b4:	a913      	add	r1, sp, #76	; 0x4c
 80072b6:	488b      	ldr	r0, [pc, #556]	; (80074e4 <MX_TIM3_Init+0x2a4>)
 80072b8:	f7fb fcb8 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80072bc:	2800      	cmp	r0, #0
 80072be:	d134      	bne.n	800732a <MX_TIM3_Init+0xea>
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 80072c0:	a913      	add	r1, sp, #76	; 0x4c
 80072c2:	220c      	movs	r2, #12
 80072c4:	4887      	ldr	r0, [pc, #540]	; (80074e4 <MX_TIM3_Init+0x2a4>)
 80072c6:	f7fb fcb1 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80072ca:	b108      	cbz	r0, 80072d0 <MX_TIM3_Init+0x90>
    Error_Handler();
 80072cc:	f7ff fc38 	bl	8006b40 <Error_Handler>
  if(timHandle->Instance==TIM1)
 80072d0:	6823      	ldr	r3, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80072d2:	2400      	movs	r4, #0
  if(timHandle->Instance==TIM1)
 80072d4:	4a84      	ldr	r2, [pc, #528]	; (80074e8 <MX_TIM3_Init+0x2a8>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80072d6:	9412      	str	r4, [sp, #72]	; 0x48
  if(timHandle->Instance==TIM1)
 80072d8:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80072da:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
 80072de:	e9cd 4410 	strd	r4, r4, [sp, #64]	; 0x40
  if(timHandle->Instance==TIM1)
 80072e2:	d045      	beq.n	8007370 <MX_TIM3_Init+0x130>
  else if(timHandle->Instance==TIM2)
 80072e4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80072e8:	d059      	beq.n	800739e <MX_TIM3_Init+0x15e>
  else if(timHandle->Instance==TIM3)
 80072ea:	4a7d      	ldr	r2, [pc, #500]	; (80074e0 <MX_TIM3_Init+0x2a0>)
 80072ec:	4293      	cmp	r3, r2
 80072ee:	d07b      	beq.n	80073e8 <MX_TIM3_Init+0x1a8>
  else if(timHandle->Instance==TIM4)
 80072f0:	4a7e      	ldr	r2, [pc, #504]	; (80074ec <MX_TIM3_Init+0x2ac>)
 80072f2:	4293      	cmp	r3, r2
 80072f4:	f000 808b 	beq.w	800740e <MX_TIM3_Init+0x1ce>
  else if(timHandle->Instance==TIM5)
 80072f8:	4a7d      	ldr	r2, [pc, #500]	; (80074f0 <MX_TIM3_Init+0x2b0>)
 80072fa:	4293      	cmp	r3, r2
 80072fc:	d024      	beq.n	8007348 <MX_TIM3_Init+0x108>
  else if(timHandle->Instance==TIM8)
 80072fe:	4a7d      	ldr	r2, [pc, #500]	; (80074f4 <MX_TIM3_Init+0x2b4>)
 8007300:	4293      	cmp	r3, r2
 8007302:	f000 8099 	beq.w	8007438 <MX_TIM3_Init+0x1f8>
  else if(timHandle->Instance==TIM9)
 8007306:	4a7c      	ldr	r2, [pc, #496]	; (80074f8 <MX_TIM3_Init+0x2b8>)
 8007308:	4293      	cmp	r3, r2
 800730a:	f000 80ab 	beq.w	8007464 <MX_TIM3_Init+0x224>
  else if(timHandle->Instance==TIM10)
 800730e:	4a7b      	ldr	r2, [pc, #492]	; (80074fc <MX_TIM3_Init+0x2bc>)
 8007310:	4293      	cmp	r3, r2
 8007312:	f000 80d0 	beq.w	80074b6 <MX_TIM3_Init+0x276>
  else if(timHandle->Instance==TIM11)
 8007316:	4a7a      	ldr	r2, [pc, #488]	; (8007500 <MX_TIM3_Init+0x2c0>)
 8007318:	4293      	cmp	r3, r2
 800731a:	f000 8101 	beq.w	8007520 <MX_TIM3_Init+0x2e0>
  else if(timHandle->Instance==TIM12)
 800731e:	4a79      	ldr	r2, [pc, #484]	; (8007504 <MX_TIM3_Init+0x2c4>)
 8007320:	4293      	cmp	r3, r2
 8007322:	f000 80b4 	beq.w	800748e <MX_TIM3_Init+0x24e>
}
 8007326:	b01a      	add	sp, #104	; 0x68
 8007328:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 800732a:	f7ff fc09 	bl	8006b40 <Error_Handler>
 800732e:	e7c7      	b.n	80072c0 <MX_TIM3_Init+0x80>
    Error_Handler();
 8007330:	f7ff fc06 	bl	8006b40 <Error_Handler>
 8007334:	e7bd      	b.n	80072b2 <MX_TIM3_Init+0x72>
    Error_Handler();
 8007336:	f7ff fc03 	bl	8006b40 <Error_Handler>
 800733a:	e7b3      	b.n	80072a4 <MX_TIM3_Init+0x64>
    Error_Handler();
 800733c:	f7ff fc00 	bl	8006b40 <Error_Handler>
 8007340:	e7a3      	b.n	800728a <MX_TIM3_Init+0x4a>
    Error_Handler();
 8007342:	f7ff fbfd 	bl	8006b40 <Error_Handler>
 8007346:	e797      	b.n	8007278 <MX_TIM3_Init+0x38>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007348:	4b6f      	ldr	r3, [pc, #444]	; (8007508 <MX_TIM3_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800734a:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 800734c:	250f      	movs	r5, #15
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800734e:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007350:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007352:	486e      	ldr	r0, [pc, #440]	; (800750c <MX_TIM3_Init+0x2cc>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007354:	f042 0201 	orr.w	r2, r2, #1
 8007358:	631a      	str	r2, [r3, #48]	; 0x30
 800735a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 800735c:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800735e:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007362:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 8007364:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007366:	9305      	str	r3, [sp, #20]
 8007368:	9b05      	ldr	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800736a:	f7f9 fbf1 	bl	8000b50 <HAL_GPIO_Init>
 800736e:	e7da      	b.n	8007326 <MX_TIM3_Init+0xe6>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007370:	4b65      	ldr	r3, [pc, #404]	; (8007508 <MX_TIM3_Init+0x2c8>)
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8007372:	f44f 46d4 	mov.w	r6, #27136	; 0x6a00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007376:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007378:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800737a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 800737c:	2401      	movs	r4, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800737e:	4864      	ldr	r0, [pc, #400]	; (8007510 <MX_TIM3_Init+0x2d0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007380:	f042 0210 	orr.w	r2, r2, #16
 8007384:	631a      	str	r2, [r3, #48]	; 0x30
 8007386:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8007388:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800738a:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800738e:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8007390:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007392:	9300      	str	r3, [sp, #0]
 8007394:	9b00      	ldr	r3, [sp, #0]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007396:	f7f9 fbdb 	bl	8000b50 <HAL_GPIO_Init>
}
 800739a:	b01a      	add	sp, #104	; 0x68
 800739c:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800739e:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80073a2:	2601      	movs	r6, #1
    GPIO_InitStruct.Pin = PWM14_Pin;
 80073a4:	2502      	movs	r5, #2
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80073a6:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80073a8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80073aa:	4858      	ldr	r0, [pc, #352]	; (800750c <MX_TIM3_Init+0x2cc>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80073ac:	4332      	orrs	r2, r6
 80073ae:	631a      	str	r2, [r3, #48]	; 0x30
 80073b0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80073b2:	4032      	ands	r2, r6
 80073b4:	9201      	str	r2, [sp, #4]
 80073b6:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80073b8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80073ba:	432a      	orrs	r2, r5
 80073bc:	631a      	str	r2, [r3, #48]	; 0x30
 80073be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM14_Pin;
 80073c0:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80073c2:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80073c4:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80073c6:	9612      	str	r6, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80073c8:	9302      	str	r3, [sp, #8]
 80073ca:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80073cc:	f7f9 fbc0 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = PWM58_Pin;
 80073d0:	2308      	movs	r3, #8
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 80073d2:	a90e      	add	r1, sp, #56	; 0x38
 80073d4:	484f      	ldr	r0, [pc, #316]	; (8007514 <MX_TIM3_Init+0x2d4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80073d6:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80073d8:	9612      	str	r6, [sp, #72]	; 0x48
    GPIO_InitStruct.Pin = PWM58_Pin;
 80073da:	930e      	str	r3, [sp, #56]	; 0x38
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80073dc:	e9cd 4410 	strd	r4, r4, [sp, #64]	; 0x40
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 80073e0:	f7f9 fbb6 	bl	8000b50 <HAL_GPIO_Init>
}
 80073e4:	b01a      	add	sp, #104	; 0x68
 80073e6:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80073e8:	4b47      	ldr	r3, [pc, #284]	; (8007508 <MX_TIM3_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80073ea:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 80073ec:	2533      	movs	r5, #51	; 0x33
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80073ee:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80073f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80073f2:	4848      	ldr	r0, [pc, #288]	; (8007514 <MX_TIM3_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80073f4:	4322      	orrs	r2, r4
 80073f6:	631a      	str	r2, [r3, #48]	; 0x30
 80073f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 80073fa:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80073fc:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80073fe:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8007400:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007402:	9303      	str	r3, [sp, #12]
 8007404:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007406:	f7f9 fba3 	bl	8000b50 <HAL_GPIO_Init>
}
 800740a:	b01a      	add	sp, #104	; 0x68
 800740c:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800740e:	4b3e      	ldr	r3, [pc, #248]	; (8007508 <MX_TIM3_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007410:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8007412:	f44f 4540 	mov.w	r5, #49152	; 0xc000
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007416:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007418:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800741a:	483f      	ldr	r0, [pc, #252]	; (8007518 <MX_TIM3_Init+0x2d8>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800741c:	f042 0208 	orr.w	r2, r2, #8
 8007420:	631a      	str	r2, [r3, #48]	; 0x30
 8007422:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8007424:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007426:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800742a:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 800742c:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800742e:	9304      	str	r3, [sp, #16]
 8007430:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007432:	f7f9 fb8d 	bl	8000b50 <HAL_GPIO_Init>
 8007436:	e776      	b.n	8007326 <MX_TIM3_Init+0xe6>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007438:	4b33      	ldr	r3, [pc, #204]	; (8007508 <MX_TIM3_Init+0x2c8>)
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 800743a:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800743e:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8007440:	2403      	movs	r4, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007442:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007444:	a90e      	add	r1, sp, #56	; 0x38
 8007446:	4835      	ldr	r0, [pc, #212]	; (800751c <MX_TIM3_Init+0x2dc>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007448:	f042 0204 	orr.w	r2, r2, #4
 800744c:	631a      	str	r2, [r3, #48]	; 0x30
 800744e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8007450:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007452:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007456:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8007458:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800745a:	9306      	str	r3, [sp, #24]
 800745c:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800745e:	f7f9 fb77 	bl	8000b50 <HAL_GPIO_Init>
 8007462:	e760      	b.n	8007326 <MX_TIM3_Init+0xe6>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007464:	4b28      	ldr	r3, [pc, #160]	; (8007508 <MX_TIM3_Init+0x2c8>)
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8007466:	2660      	movs	r6, #96	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007468:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 800746a:	2403      	movs	r4, #3
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800746c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800746e:	a90e      	add	r1, sp, #56	; 0x38
 8007470:	4827      	ldr	r0, [pc, #156]	; (8007510 <MX_TIM3_Init+0x2d0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007472:	f042 0210 	orr.w	r2, r2, #16
 8007476:	631a      	str	r2, [r3, #48]	; 0x30
 8007478:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 800747a:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800747c:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007480:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8007482:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007484:	9307      	str	r3, [sp, #28]
 8007486:	9b07      	ldr	r3, [sp, #28]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007488:	f7f9 fb62 	bl	8000b50 <HAL_GPIO_Init>
 800748c:	e74b      	b.n	8007326 <MX_TIM3_Init+0xe6>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800748e:	4b1e      	ldr	r3, [pc, #120]	; (8007508 <MX_TIM3_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007490:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 8007492:	f44f 4640 	mov.w	r6, #49152	; 0xc000
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8007496:	2409      	movs	r4, #9
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007498:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800749a:	a90e      	add	r1, sp, #56	; 0x38
 800749c:	481d      	ldr	r0, [pc, #116]	; (8007514 <MX_TIM3_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800749e:	432a      	orrs	r2, r5
 80074a0:	631a      	str	r2, [r3, #48]	; 0x30
 80074a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 80074a4:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80074a6:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80074a8:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 80074aa:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80074ac:	930a      	str	r3, [sp, #40]	; 0x28
 80074ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80074b0:	f7f9 fb4e 	bl	8000b50 <HAL_GPIO_Init>
}
 80074b4:	e737      	b.n	8007326 <MX_TIM3_Init+0xe6>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80074b6:	4b14      	ldr	r3, [pc, #80]	; (8007508 <MX_TIM3_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80074b8:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM61_Pin;
 80074ba:	f44f 7680 	mov.w	r6, #256	; 0x100
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 80074be:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80074c0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 80074c2:	a90e      	add	r1, sp, #56	; 0x38
 80074c4:	4813      	ldr	r0, [pc, #76]	; (8007514 <MX_TIM3_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80074c6:	432a      	orrs	r2, r5
 80074c8:	631a      	str	r2, [r3, #48]	; 0x30
 80074ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM61_Pin;
 80074cc:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80074ce:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80074d0:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 80074d2:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80074d4:	9308      	str	r3, [sp, #32]
 80074d6:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 80074d8:	f7f9 fb3a 	bl	8000b50 <HAL_GPIO_Init>
 80074dc:	e723      	b.n	8007326 <MX_TIM3_Init+0xe6>
 80074de:	bf00      	nop
 80074e0:	40000400 	.word	0x40000400
 80074e4:	2000103c 	.word	0x2000103c
 80074e8:	40010000 	.word	0x40010000
 80074ec:	40000800 	.word	0x40000800
 80074f0:	40000c00 	.word	0x40000c00
 80074f4:	40010400 	.word	0x40010400
 80074f8:	40014000 	.word	0x40014000
 80074fc:	40014400 	.word	0x40014400
 8007500:	40014800 	.word	0x40014800
 8007504:	40001800 	.word	0x40001800
 8007508:	40023800 	.word	0x40023800
 800750c:	40020000 	.word	0x40020000
 8007510:	40021000 	.word	0x40021000
 8007514:	40020400 	.word	0x40020400
 8007518:	40020c00 	.word	0x40020c00
 800751c:	40020800 	.word	0x40020800
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007520:	4b09      	ldr	r3, [pc, #36]	; (8007548 <MX_TIM3_Init+0x308>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007522:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM62_Pin;
 8007524:	f44f 7600 	mov.w	r6, #512	; 0x200
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 8007528:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800752a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 800752c:	a90e      	add	r1, sp, #56	; 0x38
 800752e:	4807      	ldr	r0, [pc, #28]	; (800754c <MX_TIM3_Init+0x30c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007530:	432a      	orrs	r2, r5
 8007532:	631a      	str	r2, [r3, #48]	; 0x30
 8007534:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM62_Pin;
 8007536:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007538:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800753a:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 800753c:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800753e:	9309      	str	r3, [sp, #36]	; 0x24
 8007540:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8007542:	f7f9 fb05 	bl	8000b50 <HAL_GPIO_Init>
 8007546:	e6ee      	b.n	8007326 <MX_TIM3_Init+0xe6>
 8007548:	40023800 	.word	0x40023800
 800754c:	40020400 	.word	0x40020400

08007550 <MX_TIM4_Init>:
{
 8007550:	b570      	push	{r4, r5, r6, lr}
  htim4.Instance = TIM4;
 8007552:	48a7      	ldr	r0, [pc, #668]	; (80077f0 <MX_TIM4_Init+0x2a0>)
  htim4.Init.Prescaler = 56;
 8007554:	2138      	movs	r1, #56	; 0x38
  htim4.Instance = TIM4;
 8007556:	4ca7      	ldr	r4, [pc, #668]	; (80077f4 <MX_TIM4_Init+0x2a4>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007558:	2300      	movs	r3, #0
{
 800755a:	b09a      	sub	sp, #104	; 0x68
  htim4.Init.Period = 127;
 800755c:	227f      	movs	r2, #127	; 0x7f
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800755e:	6123      	str	r3, [r4, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007560:	930b      	str	r3, [sp, #44]	; 0x2c
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007562:	9313      	str	r3, [sp, #76]	; 0x4c
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8007564:	61a3      	str	r3, [r4, #24]
  htim4.Init.Prescaler = 56;
 8007566:	e9c4 0100 	strd	r0, r1, [r4]
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
 800756a:	4620      	mov	r0, r4
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 800756c:	e9c4 3202 	strd	r3, r2, [r4, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007570:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007574:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
 8007578:	e9cd 3316 	strd	r3, r3, [sp, #88]	; 0x58
 800757c:	e9cd 3318 	strd	r3, r3, [sp, #96]	; 0x60
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
 8007580:	f7fb fa64 	bl	8002a4c <HAL_TIM_PWM_Init>
 8007584:	2800      	cmp	r0, #0
 8007586:	d150      	bne.n	800762a <MX_TIM4_Init+0xda>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8007588:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 800758a:	a90b      	add	r1, sp, #44	; 0x2c
 800758c:	4899      	ldr	r0, [pc, #612]	; (80077f4 <MX_TIM4_Init+0x2a4>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800758e:	930b      	str	r3, [sp, #44]	; 0x2c
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8007590:	930d      	str	r3, [sp, #52]	; 0x34
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 8007592:	f7fb fd99 	bl	80030c8 <HAL_TIMEx_MasterConfigSynchronization>
 8007596:	2800      	cmp	r0, #0
 8007598:	d144      	bne.n	8007624 <MX_TIM4_Init+0xd4>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800759a:	2060      	movs	r0, #96	; 0x60
  sConfigOC.Pulse = 0;
 800759c:	2300      	movs	r3, #0
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 800759e:	2208      	movs	r2, #8
 80075a0:	a913      	add	r1, sp, #76	; 0x4c
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80075a2:	9013      	str	r0, [sp, #76]	; 0x4c
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 80075a4:	4893      	ldr	r0, [pc, #588]	; (80077f4 <MX_TIM4_Init+0x2a4>)
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80075a6:	9317      	str	r3, [sp, #92]	; 0x5c
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80075a8:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 80075ac:	f7fb fb3e 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80075b0:	2800      	cmp	r0, #0
 80075b2:	d134      	bne.n	800761e <MX_TIM4_Init+0xce>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 80075b4:	a913      	add	r1, sp, #76	; 0x4c
 80075b6:	220c      	movs	r2, #12
 80075b8:	488e      	ldr	r0, [pc, #568]	; (80077f4 <MX_TIM4_Init+0x2a4>)
 80075ba:	f7fb fb37 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80075be:	b108      	cbz	r0, 80075c4 <MX_TIM4_Init+0x74>
    Error_Handler();
 80075c0:	f7ff fabe 	bl	8006b40 <Error_Handler>
  if(timHandle->Instance==TIM1)
 80075c4:	6823      	ldr	r3, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80075c6:	2400      	movs	r4, #0
  if(timHandle->Instance==TIM1)
 80075c8:	4a8b      	ldr	r2, [pc, #556]	; (80077f8 <MX_TIM4_Init+0x2a8>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80075ca:	9412      	str	r4, [sp, #72]	; 0x48
  if(timHandle->Instance==TIM1)
 80075cc:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80075ce:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
 80075d2:	e9cd 4410 	strd	r4, r4, [sp, #64]	; 0x40
  if(timHandle->Instance==TIM1)
 80075d6:	d03f      	beq.n	8007658 <MX_TIM4_Init+0x108>
  else if(timHandle->Instance==TIM2)
 80075d8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80075dc:	d053      	beq.n	8007686 <MX_TIM4_Init+0x136>
  else if(timHandle->Instance==TIM3)
 80075de:	4a87      	ldr	r2, [pc, #540]	; (80077fc <MX_TIM4_Init+0x2ac>)
 80075e0:	4293      	cmp	r3, r2
 80075e2:	d075      	beq.n	80076d0 <MX_TIM4_Init+0x180>
  else if(timHandle->Instance==TIM4)
 80075e4:	4a82      	ldr	r2, [pc, #520]	; (80077f0 <MX_TIM4_Init+0x2a0>)
 80075e6:	4293      	cmp	r3, r2
 80075e8:	f000 8085 	beq.w	80076f6 <MX_TIM4_Init+0x1a6>
  else if(timHandle->Instance==TIM5)
 80075ec:	4a84      	ldr	r2, [pc, #528]	; (8007800 <MX_TIM4_Init+0x2b0>)
 80075ee:	4293      	cmp	r3, r2
 80075f0:	d01e      	beq.n	8007630 <MX_TIM4_Init+0xe0>
  else if(timHandle->Instance==TIM8)
 80075f2:	4a84      	ldr	r2, [pc, #528]	; (8007804 <MX_TIM4_Init+0x2b4>)
 80075f4:	4293      	cmp	r3, r2
 80075f6:	f000 8093 	beq.w	8007720 <MX_TIM4_Init+0x1d0>
  else if(timHandle->Instance==TIM9)
 80075fa:	4a83      	ldr	r2, [pc, #524]	; (8007808 <MX_TIM4_Init+0x2b8>)
 80075fc:	4293      	cmp	r3, r2
 80075fe:	f000 80a5 	beq.w	800774c <MX_TIM4_Init+0x1fc>
  else if(timHandle->Instance==TIM10)
 8007602:	4a82      	ldr	r2, [pc, #520]	; (800780c <MX_TIM4_Init+0x2bc>)
 8007604:	4293      	cmp	r3, r2
 8007606:	f000 80ca 	beq.w	800779e <MX_TIM4_Init+0x24e>
  else if(timHandle->Instance==TIM11)
 800760a:	4a81      	ldr	r2, [pc, #516]	; (8007810 <MX_TIM4_Init+0x2c0>)
 800760c:	4293      	cmp	r3, r2
 800760e:	f000 80da 	beq.w	80077c6 <MX_TIM4_Init+0x276>
  else if(timHandle->Instance==TIM12)
 8007612:	4a80      	ldr	r2, [pc, #512]	; (8007814 <MX_TIM4_Init+0x2c4>)
 8007614:	4293      	cmp	r3, r2
 8007616:	f000 80ae 	beq.w	8007776 <MX_TIM4_Init+0x226>
}
 800761a:	b01a      	add	sp, #104	; 0x68
 800761c:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 800761e:	f7ff fa8f 	bl	8006b40 <Error_Handler>
 8007622:	e7c7      	b.n	80075b4 <MX_TIM4_Init+0x64>
    Error_Handler();
 8007624:	f7ff fa8c 	bl	8006b40 <Error_Handler>
 8007628:	e7b7      	b.n	800759a <MX_TIM4_Init+0x4a>
    Error_Handler();
 800762a:	f7ff fa89 	bl	8006b40 <Error_Handler>
 800762e:	e7ab      	b.n	8007588 <MX_TIM4_Init+0x38>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007630:	4b79      	ldr	r3, [pc, #484]	; (8007818 <MX_TIM4_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007632:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8007634:	250f      	movs	r5, #15
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007636:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007638:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800763a:	4878      	ldr	r0, [pc, #480]	; (800781c <MX_TIM4_Init+0x2cc>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800763c:	f042 0201 	orr.w	r2, r2, #1
 8007640:	631a      	str	r2, [r3, #48]	; 0x30
 8007642:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8007644:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007646:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800764a:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 800764c:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800764e:	9305      	str	r3, [sp, #20]
 8007650:	9b05      	ldr	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007652:	f7f9 fa7d 	bl	8000b50 <HAL_GPIO_Init>
 8007656:	e7e0      	b.n	800761a <MX_TIM4_Init+0xca>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007658:	4b6f      	ldr	r3, [pc, #444]	; (8007818 <MX_TIM4_Init+0x2c8>)
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 800765a:	f44f 46d4 	mov.w	r6, #27136	; 0x6a00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800765e:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007660:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007662:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8007664:	2401      	movs	r4, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007666:	486e      	ldr	r0, [pc, #440]	; (8007820 <MX_TIM4_Init+0x2d0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007668:	f042 0210 	orr.w	r2, r2, #16
 800766c:	631a      	str	r2, [r3, #48]	; 0x30
 800766e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8007670:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007672:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007676:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8007678:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800767a:	9300      	str	r3, [sp, #0]
 800767c:	9b00      	ldr	r3, [sp, #0]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800767e:	f7f9 fa67 	bl	8000b50 <HAL_GPIO_Init>
}
 8007682:	b01a      	add	sp, #104	; 0x68
 8007684:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007686:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 800768a:	2601      	movs	r6, #1
    GPIO_InitStruct.Pin = PWM14_Pin;
 800768c:	2502      	movs	r5, #2
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 800768e:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007690:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8007692:	4862      	ldr	r0, [pc, #392]	; (800781c <MX_TIM4_Init+0x2cc>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007694:	4332      	orrs	r2, r6
 8007696:	631a      	str	r2, [r3, #48]	; 0x30
 8007698:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800769a:	4032      	ands	r2, r6
 800769c:	9201      	str	r2, [sp, #4]
 800769e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80076a0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80076a2:	432a      	orrs	r2, r5
 80076a4:	631a      	str	r2, [r3, #48]	; 0x30
 80076a6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM14_Pin;
 80076a8:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80076aa:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80076ac:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80076ae:	9612      	str	r6, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80076b0:	9302      	str	r3, [sp, #8]
 80076b2:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80076b4:	f7f9 fa4c 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = PWM58_Pin;
 80076b8:	2308      	movs	r3, #8
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 80076ba:	a90e      	add	r1, sp, #56	; 0x38
 80076bc:	4859      	ldr	r0, [pc, #356]	; (8007824 <MX_TIM4_Init+0x2d4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80076be:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80076c0:	9612      	str	r6, [sp, #72]	; 0x48
    GPIO_InitStruct.Pin = PWM58_Pin;
 80076c2:	930e      	str	r3, [sp, #56]	; 0x38
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80076c4:	e9cd 4410 	strd	r4, r4, [sp, #64]	; 0x40
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 80076c8:	f7f9 fa42 	bl	8000b50 <HAL_GPIO_Init>
}
 80076cc:	b01a      	add	sp, #104	; 0x68
 80076ce:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80076d0:	4b51      	ldr	r3, [pc, #324]	; (8007818 <MX_TIM4_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80076d2:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 80076d4:	2533      	movs	r5, #51	; 0x33
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80076d6:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80076d8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80076da:	4852      	ldr	r0, [pc, #328]	; (8007824 <MX_TIM4_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80076dc:	4322      	orrs	r2, r4
 80076de:	631a      	str	r2, [r3, #48]	; 0x30
 80076e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 80076e2:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80076e4:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80076e6:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 80076e8:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80076ea:	9303      	str	r3, [sp, #12]
 80076ec:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80076ee:	f7f9 fa2f 	bl	8000b50 <HAL_GPIO_Init>
}
 80076f2:	b01a      	add	sp, #104	; 0x68
 80076f4:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80076f6:	4b48      	ldr	r3, [pc, #288]	; (8007818 <MX_TIM4_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80076f8:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 80076fa:	f44f 4540 	mov.w	r5, #49152	; 0xc000
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80076fe:	a90e      	add	r1, sp, #56	; 0x38
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007700:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007702:	4849      	ldr	r0, [pc, #292]	; (8007828 <MX_TIM4_Init+0x2d8>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007704:	f042 0208 	orr.w	r2, r2, #8
 8007708:	631a      	str	r2, [r3, #48]	; 0x30
 800770a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 800770c:	950e      	str	r5, [sp, #56]	; 0x38
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800770e:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007712:	940f      	str	r4, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 8007714:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007716:	9304      	str	r3, [sp, #16]
 8007718:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800771a:	f7f9 fa19 	bl	8000b50 <HAL_GPIO_Init>
 800771e:	e77c      	b.n	800761a <MX_TIM4_Init+0xca>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007720:	4b3d      	ldr	r3, [pc, #244]	; (8007818 <MX_TIM4_Init+0x2c8>)
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8007722:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007726:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8007728:	2403      	movs	r4, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800772a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800772c:	a90e      	add	r1, sp, #56	; 0x38
 800772e:	483f      	ldr	r0, [pc, #252]	; (800782c <MX_TIM4_Init+0x2dc>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007730:	f042 0204 	orr.w	r2, r2, #4
 8007734:	631a      	str	r2, [r3, #48]	; 0x30
 8007736:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8007738:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800773a:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800773e:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8007740:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007742:	9306      	str	r3, [sp, #24]
 8007744:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007746:	f7f9 fa03 	bl	8000b50 <HAL_GPIO_Init>
 800774a:	e766      	b.n	800761a <MX_TIM4_Init+0xca>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800774c:	4b32      	ldr	r3, [pc, #200]	; (8007818 <MX_TIM4_Init+0x2c8>)
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 800774e:	2660      	movs	r6, #96	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007750:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8007752:	2403      	movs	r4, #3
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007754:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007756:	a90e      	add	r1, sp, #56	; 0x38
 8007758:	4831      	ldr	r0, [pc, #196]	; (8007820 <MX_TIM4_Init+0x2d0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800775a:	f042 0210 	orr.w	r2, r2, #16
 800775e:	631a      	str	r2, [r3, #48]	; 0x30
 8007760:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8007762:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007764:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007768:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 800776a:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800776c:	9307      	str	r3, [sp, #28]
 800776e:	9b07      	ldr	r3, [sp, #28]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007770:	f7f9 f9ee 	bl	8000b50 <HAL_GPIO_Init>
 8007774:	e751      	b.n	800761a <MX_TIM4_Init+0xca>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007776:	4b28      	ldr	r3, [pc, #160]	; (8007818 <MX_TIM4_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007778:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 800777a:	f44f 4640 	mov.w	r6, #49152	; 0xc000
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 800777e:	2409      	movs	r4, #9
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007780:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007782:	a90e      	add	r1, sp, #56	; 0x38
 8007784:	4827      	ldr	r0, [pc, #156]	; (8007824 <MX_TIM4_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007786:	432a      	orrs	r2, r5
 8007788:	631a      	str	r2, [r3, #48]	; 0x30
 800778a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 800778c:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800778e:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007790:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8007792:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007794:	930a      	str	r3, [sp, #40]	; 0x28
 8007796:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007798:	f7f9 f9da 	bl	8000b50 <HAL_GPIO_Init>
}
 800779c:	e73d      	b.n	800761a <MX_TIM4_Init+0xca>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800779e:	4b1e      	ldr	r3, [pc, #120]	; (8007818 <MX_TIM4_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80077a0:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM61_Pin;
 80077a2:	f44f 7680 	mov.w	r6, #256	; 0x100
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 80077a6:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80077a8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 80077aa:	a90e      	add	r1, sp, #56	; 0x38
 80077ac:	481d      	ldr	r0, [pc, #116]	; (8007824 <MX_TIM4_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80077ae:	432a      	orrs	r2, r5
 80077b0:	631a      	str	r2, [r3, #48]	; 0x30
 80077b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM61_Pin;
 80077b4:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80077b6:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80077b8:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 80077ba:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80077bc:	9308      	str	r3, [sp, #32]
 80077be:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 80077c0:	f7f9 f9c6 	bl	8000b50 <HAL_GPIO_Init>
 80077c4:	e729      	b.n	800761a <MX_TIM4_Init+0xca>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80077c6:	4b14      	ldr	r3, [pc, #80]	; (8007818 <MX_TIM4_Init+0x2c8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80077c8:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM62_Pin;
 80077ca:	f44f 7600 	mov.w	r6, #512	; 0x200
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 80077ce:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80077d0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 80077d2:	a90e      	add	r1, sp, #56	; 0x38
 80077d4:	4813      	ldr	r0, [pc, #76]	; (8007824 <MX_TIM4_Init+0x2d4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80077d6:	432a      	orrs	r2, r5
 80077d8:	631a      	str	r2, [r3, #48]	; 0x30
 80077da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM62_Pin;
 80077dc:	960e      	str	r6, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80077de:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80077e0:	950f      	str	r5, [sp, #60]	; 0x3c
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 80077e2:	9412      	str	r4, [sp, #72]	; 0x48
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80077e4:	9309      	str	r3, [sp, #36]	; 0x24
 80077e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 80077e8:	f7f9 f9b2 	bl	8000b50 <HAL_GPIO_Init>
 80077ec:	e715      	b.n	800761a <MX_TIM4_Init+0xca>
 80077ee:	bf00      	nop
 80077f0:	40000800 	.word	0x40000800
 80077f4:	20000f7c 	.word	0x20000f7c
 80077f8:	40010000 	.word	0x40010000
 80077fc:	40000400 	.word	0x40000400
 8007800:	40000c00 	.word	0x40000c00
 8007804:	40010400 	.word	0x40010400
 8007808:	40014000 	.word	0x40014000
 800780c:	40014400 	.word	0x40014400
 8007810:	40014800 	.word	0x40014800
 8007814:	40001800 	.word	0x40001800
 8007818:	40023800 	.word	0x40023800
 800781c:	40020000 	.word	0x40020000
 8007820:	40021000 	.word	0x40021000
 8007824:	40020400 	.word	0x40020400
 8007828:	40020c00 	.word	0x40020c00
 800782c:	40020800 	.word	0x40020800

08007830 <MX_TIM5_Init>:
{
 8007830:	b510      	push	{r4, lr}
  htim5.Instance = TIM5;
 8007832:	4a2a      	ldr	r2, [pc, #168]	; (80078dc <MX_TIM5_Init+0xac>)
  htim5.Init.Prescaler = 56;
 8007834:	2038      	movs	r0, #56	; 0x38
  htim5.Instance = TIM5;
 8007836:	4c2a      	ldr	r4, [pc, #168]	; (80078e0 <MX_TIM5_Init+0xb0>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007838:	2300      	movs	r3, #0
{
 800783a:	b08a      	sub	sp, #40	; 0x28
  htim5.Init.Period = 127;
 800783c:	217f      	movs	r1, #127	; 0x7f
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800783e:	6113      	str	r3, [r2, #16]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007840:	9300      	str	r3, [sp, #0]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007842:	9303      	str	r3, [sp, #12]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8007844:	6193      	str	r3, [r2, #24]
  htim5.Init.Prescaler = 56;
 8007846:	e9c2 4000 	strd	r4, r0, [r2]
  if (HAL_TIM_PWM_Init(&htim5) != HAL_OK)
 800784a:	4610      	mov	r0, r2
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 800784c:	e9c2 3102 	strd	r3, r1, [r2, #8]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007850:	e9cd 3301 	strd	r3, r3, [sp, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007854:	e9cd 3304 	strd	r3, r3, [sp, #16]
 8007858:	e9cd 3306 	strd	r3, r3, [sp, #24]
 800785c:	e9cd 3308 	strd	r3, r3, [sp, #32]
  if (HAL_TIM_PWM_Init(&htim5) != HAL_OK)
 8007860:	f7fb f8f4 	bl	8002a4c <HAL_TIM_PWM_Init>
 8007864:	2800      	cmp	r0, #0
 8007866:	d135      	bne.n	80078d4 <MX_TIM5_Init+0xa4>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8007868:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 800786a:	4669      	mov	r1, sp
 800786c:	481b      	ldr	r0, [pc, #108]	; (80078dc <MX_TIM5_Init+0xac>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800786e:	9300      	str	r3, [sp, #0]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8007870:	9302      	str	r3, [sp, #8]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8007872:	f7fb fc29 	bl	80030c8 <HAL_TIMEx_MasterConfigSynchronization>
 8007876:	bb50      	cbnz	r0, 80078ce <MX_TIM5_Init+0x9e>
  sConfigOC.Pulse = 0;
 8007878:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800787a:	2460      	movs	r4, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800787c:	a903      	add	r1, sp, #12
 800787e:	4817      	ldr	r0, [pc, #92]	; (80078dc <MX_TIM5_Init+0xac>)
 8007880:	461a      	mov	r2, r3
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8007882:	9307      	str	r3, [sp, #28]
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8007884:	9403      	str	r4, [sp, #12]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8007886:	e9cd 3304 	strd	r3, r3, [sp, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800788a:	f7fb f9cf 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 800788e:	b9d8      	cbnz	r0, 80078c8 <MX_TIM5_Init+0x98>
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8007890:	2204      	movs	r2, #4
 8007892:	a903      	add	r1, sp, #12
 8007894:	4811      	ldr	r0, [pc, #68]	; (80078dc <MX_TIM5_Init+0xac>)
 8007896:	f7fb f9c9 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 800789a:	b990      	cbnz	r0, 80078c2 <MX_TIM5_Init+0x92>
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 800789c:	2208      	movs	r2, #8
 800789e:	a903      	add	r1, sp, #12
 80078a0:	480e      	ldr	r0, [pc, #56]	; (80078dc <MX_TIM5_Init+0xac>)
 80078a2:	f7fb f9c3 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80078a6:	b948      	cbnz	r0, 80078bc <MX_TIM5_Init+0x8c>
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 80078a8:	a903      	add	r1, sp, #12
 80078aa:	220c      	movs	r2, #12
 80078ac:	480b      	ldr	r0, [pc, #44]	; (80078dc <MX_TIM5_Init+0xac>)
 80078ae:	f7fb f9bd 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80078b2:	b108      	cbz	r0, 80078b8 <MX_TIM5_Init+0x88>
    Error_Handler();
 80078b4:	f7ff f944 	bl	8006b40 <Error_Handler>
}
 80078b8:	b00a      	add	sp, #40	; 0x28
 80078ba:	bd10      	pop	{r4, pc}
    Error_Handler();
 80078bc:	f7ff f940 	bl	8006b40 <Error_Handler>
 80078c0:	e7f2      	b.n	80078a8 <MX_TIM5_Init+0x78>
    Error_Handler();
 80078c2:	f7ff f93d 	bl	8006b40 <Error_Handler>
 80078c6:	e7e9      	b.n	800789c <MX_TIM5_Init+0x6c>
    Error_Handler();
 80078c8:	f7ff f93a 	bl	8006b40 <Error_Handler>
 80078cc:	e7e0      	b.n	8007890 <MX_TIM5_Init+0x60>
    Error_Handler();
 80078ce:	f7ff f937 	bl	8006b40 <Error_Handler>
 80078d2:	e7d1      	b.n	8007878 <MX_TIM5_Init+0x48>
    Error_Handler();
 80078d4:	f7ff f934 	bl	8006b40 <Error_Handler>
 80078d8:	e7c6      	b.n	8007868 <MX_TIM5_Init+0x38>
 80078da:	bf00      	nop
 80078dc:	20000ffc 	.word	0x20000ffc
 80078e0:	40000c00 	.word	0x40000c00

080078e4 <MX_TIM6_Init>:
  htim6.Instance = TIM6;
 80078e4:	4a10      	ldr	r2, [pc, #64]	; (8007928 <MX_TIM6_Init+0x44>)
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80078e6:	2300      	movs	r3, #0
  htim6.Init.Period = 399;
 80078e8:	f240 118f 	movw	r1, #399	; 0x18f
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
 80078ec:	4610      	mov	r0, r2
{
 80078ee:	b510      	push	{r4, lr}
  htim6.Instance = TIM6;
 80078f0:	4c0e      	ldr	r4, [pc, #56]	; (800792c <MX_TIM6_Init+0x48>)
{
 80078f2:	b084      	sub	sp, #16
  htim6.Init.Period = 399;
 80078f4:	60d1      	str	r1, [r2, #12]
  htim6.Instance = TIM6;
 80078f6:	6014      	str	r4, [r2, #0]
  htim6.Init.Prescaler = 0;
 80078f8:	6053      	str	r3, [r2, #4]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80078fa:	9301      	str	r3, [sp, #4]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 80078fc:	6093      	str	r3, [r2, #8]
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80078fe:	6193      	str	r3, [r2, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007900:	e9cd 3302 	strd	r3, r3, [sp, #8]
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
 8007904:	f7fb f808 	bl	8002918 <HAL_TIM_Base_Init>
 8007908:	b958      	cbnz	r0, 8007922 <MX_TIM6_Init+0x3e>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800790a:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
 800790c:	a901      	add	r1, sp, #4
 800790e:	4806      	ldr	r0, [pc, #24]	; (8007928 <MX_TIM6_Init+0x44>)
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8007910:	9301      	str	r3, [sp, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8007912:	9303      	str	r3, [sp, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
 8007914:	f7fb fbd8 	bl	80030c8 <HAL_TIMEx_MasterConfigSynchronization>
 8007918:	b108      	cbz	r0, 800791e <MX_TIM6_Init+0x3a>
    Error_Handler();
 800791a:	f7ff f911 	bl	8006b40 <Error_Handler>
}
 800791e:	b004      	add	sp, #16
 8007920:	bd10      	pop	{r4, pc}
    Error_Handler();
 8007922:	f7ff f90d 	bl	8006b40 <Error_Handler>
 8007926:	e7f0      	b.n	800790a <MX_TIM6_Init+0x26>
 8007928:	200010fc 	.word	0x200010fc
 800792c:	40001000 	.word	0x40001000

08007930 <MX_TIM8_Init>:
{
 8007930:	b570      	push	{r4, r5, r6, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007932:	2400      	movs	r4, #0
{
 8007934:	b0a6      	sub	sp, #152	; 0x98
  htim8.Instance = TIM8;
 8007936:	4da8      	ldr	r5, [pc, #672]	; (8007bd8 <MX_TIM8_Init+0x2a8>)
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8007938:	222c      	movs	r2, #44	; 0x2c
 800793a:	4621      	mov	r1, r4
 800793c:	a81b      	add	r0, sp, #108	; 0x6c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800793e:	940c      	str	r4, [sp, #48]	; 0x30
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007940:	9414      	str	r4, [sp, #80]	; 0x50
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8007942:	e9cd 440d 	strd	r4, r4, [sp, #52]	; 0x34
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007946:	e9cd 4415 	strd	r4, r4, [sp, #84]	; 0x54
 800794a:	e9cd 4417 	strd	r4, r4, [sp, #92]	; 0x5c
 800794e:	e9cd 4419 	strd	r4, r4, [sp, #100]	; 0x64
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8007952:	f001 fb9f 	bl	8009094 <memset>
  htim8.Instance = TIM8;
 8007956:	49a1      	ldr	r1, [pc, #644]	; (8007bdc <MX_TIM8_Init+0x2ac>)
  htim8.Init.Prescaler = 112;
 8007958:	2270      	movs	r2, #112	; 0x70
  htim8.Init.Period = 127;
 800795a:	237f      	movs	r3, #127	; 0x7f
  if (HAL_TIM_PWM_Init(&htim8) != HAL_OK)
 800795c:	4628      	mov	r0, r5
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
 800795e:	60ac      	str	r4, [r5, #8]
  htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8007960:	612c      	str	r4, [r5, #16]
  htim8.Init.Period = 127;
 8007962:	60eb      	str	r3, [r5, #12]
  htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8007964:	e9c5 4405 	strd	r4, r4, [r5, #20]
  htim8.Init.Prescaler = 112;
 8007968:	e9c5 1200 	strd	r1, r2, [r5]
  if (HAL_TIM_PWM_Init(&htim8) != HAL_OK)
 800796c:	f7fb f86e 	bl	8002a4c <HAL_TIM_PWM_Init>
 8007970:	2800      	cmp	r0, #0
 8007972:	d177      	bne.n	8007a64 <MX_TIM8_Init+0x134>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8007974:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 8007976:	a90c      	add	r1, sp, #48	; 0x30
 8007978:	4897      	ldr	r0, [pc, #604]	; (8007bd8 <MX_TIM8_Init+0x2a8>)
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800797a:	930e      	str	r3, [sp, #56]	; 0x38
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 800797c:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 8007980:	f7fb fba2 	bl	80030c8 <HAL_TIMEx_MasterConfigSynchronization>
 8007984:	2800      	cmp	r0, #0
 8007986:	d16a      	bne.n	8007a5e <MX_TIM8_Init+0x12e>
  sConfigOC.Pulse = 0;
 8007988:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800798a:	2460      	movs	r4, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800798c:	a914      	add	r1, sp, #80	; 0x50
 800798e:	4892      	ldr	r0, [pc, #584]	; (8007bd8 <MX_TIM8_Init+0x2a8>)
 8007990:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
 8007992:	9315      	str	r3, [sp, #84]	; 0x54
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8007994:	931a      	str	r3, [sp, #104]	; 0x68
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8007996:	9414      	str	r4, [sp, #80]	; 0x50
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8007998:	e9cd 3316 	strd	r3, r3, [sp, #88]	; 0x58
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 800799c:	e9cd 3318 	strd	r3, r3, [sp, #96]	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80079a0:	f7fb f944 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80079a4:	2800      	cmp	r0, #0
 80079a6:	d157      	bne.n	8007a58 <MX_TIM8_Init+0x128>
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80079a8:	2204      	movs	r2, #4
 80079aa:	a914      	add	r1, sp, #80	; 0x50
 80079ac:	488a      	ldr	r0, [pc, #552]	; (8007bd8 <MX_TIM8_Init+0x2a8>)
 80079ae:	f7fb f93d 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80079b2:	2800      	cmp	r0, #0
 80079b4:	d14d      	bne.n	8007a52 <MX_TIM8_Init+0x122>
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 80079b6:	a914      	add	r1, sp, #80	; 0x50
 80079b8:	2208      	movs	r2, #8
 80079ba:	4887      	ldr	r0, [pc, #540]	; (8007bd8 <MX_TIM8_Init+0x2a8>)
 80079bc:	f7fb f936 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80079c0:	2800      	cmp	r0, #0
 80079c2:	d143      	bne.n	8007a4c <MX_TIM8_Init+0x11c>
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 80079c4:	2300      	movs	r3, #0
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 80079c6:	f44f 5400 	mov.w	r4, #8192	; 0x2000
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 80079ca:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim8, &sBreakDeadTimeConfig) != HAL_OK)
 80079ce:	a91b      	add	r1, sp, #108	; 0x6c
 80079d0:	4881      	ldr	r0, [pc, #516]	; (8007bd8 <MX_TIM8_Init+0x2a8>)
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 80079d2:	931f      	str	r3, [sp, #124]	; 0x7c
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 80079d4:	9420      	str	r4, [sp, #128]	; 0x80
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 80079d6:	9223      	str	r2, [sp, #140]	; 0x8c
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 80079d8:	e9cd 331b 	strd	r3, r3, [sp, #108]	; 0x6c
  sBreakDeadTimeConfig.DeadTime = 0;
 80079dc:	e9cd 331d 	strd	r3, r3, [sp, #116]	; 0x74
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
 80079e0:	e9cd 3321 	strd	r3, r3, [sp, #132]	; 0x84
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 80079e4:	e9cd 3324 	strd	r3, r3, [sp, #144]	; 0x90
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim8, &sBreakDeadTimeConfig) != HAL_OK)
 80079e8:	f7fb fb9e 	bl	8003128 <HAL_TIMEx_ConfigBreakDeadTime>
 80079ec:	b108      	cbz	r0, 80079f2 <MX_TIM8_Init+0xc2>
    Error_Handler();
 80079ee:	f7ff f8a7 	bl	8006b40 <Error_Handler>
  if(timHandle->Instance==TIM1)
 80079f2:	682b      	ldr	r3, [r5, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80079f4:	2400      	movs	r4, #0
  if(timHandle->Instance==TIM1)
 80079f6:	4a7a      	ldr	r2, [pc, #488]	; (8007be0 <MX_TIM8_Init+0x2b0>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80079f8:	9413      	str	r4, [sp, #76]	; 0x4c
  if(timHandle->Instance==TIM1)
 80079fa:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80079fc:	e9cd 440f 	strd	r4, r4, [sp, #60]	; 0x3c
 8007a00:	e9cd 4411 	strd	r4, r4, [sp, #68]	; 0x44
  if(timHandle->Instance==TIM1)
 8007a04:	d045      	beq.n	8007a92 <MX_TIM8_Init+0x162>
  else if(timHandle->Instance==TIM2)
 8007a06:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007a0a:	d059      	beq.n	8007ac0 <MX_TIM8_Init+0x190>
  else if(timHandle->Instance==TIM3)
 8007a0c:	4a75      	ldr	r2, [pc, #468]	; (8007be4 <MX_TIM8_Init+0x2b4>)
 8007a0e:	4293      	cmp	r3, r2
 8007a10:	d07b      	beq.n	8007b0a <MX_TIM8_Init+0x1da>
  else if(timHandle->Instance==TIM4)
 8007a12:	4a75      	ldr	r2, [pc, #468]	; (8007be8 <MX_TIM8_Init+0x2b8>)
 8007a14:	4293      	cmp	r3, r2
 8007a16:	f000 808b 	beq.w	8007b30 <MX_TIM8_Init+0x200>
  else if(timHandle->Instance==TIM5)
 8007a1a:	4a74      	ldr	r2, [pc, #464]	; (8007bec <MX_TIM8_Init+0x2bc>)
 8007a1c:	4293      	cmp	r3, r2
 8007a1e:	d024      	beq.n	8007a6a <MX_TIM8_Init+0x13a>
  else if(timHandle->Instance==TIM8)
 8007a20:	4a6e      	ldr	r2, [pc, #440]	; (8007bdc <MX_TIM8_Init+0x2ac>)
 8007a22:	4293      	cmp	r3, r2
 8007a24:	f000 8099 	beq.w	8007b5a <MX_TIM8_Init+0x22a>
  else if(timHandle->Instance==TIM9)
 8007a28:	4a71      	ldr	r2, [pc, #452]	; (8007bf0 <MX_TIM8_Init+0x2c0>)
 8007a2a:	4293      	cmp	r3, r2
 8007a2c:	f000 80ab 	beq.w	8007b86 <MX_TIM8_Init+0x256>
  else if(timHandle->Instance==TIM10)
 8007a30:	4a70      	ldr	r2, [pc, #448]	; (8007bf4 <MX_TIM8_Init+0x2c4>)
 8007a32:	4293      	cmp	r3, r2
 8007a34:	f000 80f0 	beq.w	8007c18 <MX_TIM8_Init+0x2e8>
  else if(timHandle->Instance==TIM11)
 8007a38:	4a6f      	ldr	r2, [pc, #444]	; (8007bf8 <MX_TIM8_Init+0x2c8>)
 8007a3a:	4293      	cmp	r3, r2
 8007a3c:	f000 8100 	beq.w	8007c40 <MX_TIM8_Init+0x310>
  else if(timHandle->Instance==TIM12)
 8007a40:	4a6e      	ldr	r2, [pc, #440]	; (8007bfc <MX_TIM8_Init+0x2cc>)
 8007a42:	4293      	cmp	r3, r2
 8007a44:	f000 80b4 	beq.w	8007bb0 <MX_TIM8_Init+0x280>
}
 8007a48:	b026      	add	sp, #152	; 0x98
 8007a4a:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 8007a4c:	f7ff f878 	bl	8006b40 <Error_Handler>
 8007a50:	e7b8      	b.n	80079c4 <MX_TIM8_Init+0x94>
    Error_Handler();
 8007a52:	f7ff f875 	bl	8006b40 <Error_Handler>
 8007a56:	e7ae      	b.n	80079b6 <MX_TIM8_Init+0x86>
    Error_Handler();
 8007a58:	f7ff f872 	bl	8006b40 <Error_Handler>
 8007a5c:	e7a4      	b.n	80079a8 <MX_TIM8_Init+0x78>
    Error_Handler();
 8007a5e:	f7ff f86f 	bl	8006b40 <Error_Handler>
 8007a62:	e791      	b.n	8007988 <MX_TIM8_Init+0x58>
    Error_Handler();
 8007a64:	f7ff f86c 	bl	8006b40 <Error_Handler>
 8007a68:	e784      	b.n	8007974 <MX_TIM8_Init+0x44>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007a6a:	4b65      	ldr	r3, [pc, #404]	; (8007c00 <MX_TIM8_Init+0x2d0>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007a6c:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8007a6e:	250f      	movs	r5, #15
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007a70:	a90f      	add	r1, sp, #60	; 0x3c
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007a72:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007a74:	4863      	ldr	r0, [pc, #396]	; (8007c04 <MX_TIM8_Init+0x2d4>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007a76:	f042 0201 	orr.w	r2, r2, #1
 8007a7a:	631a      	str	r2, [r3, #48]	; 0x30
 8007a7c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8007a7e:	950f      	str	r5, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007a80:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007a84:	9410      	str	r4, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 8007a86:	9413      	str	r4, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007a88:	9306      	str	r3, [sp, #24]
 8007a8a:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007a8c:	f7f9 f860 	bl	8000b50 <HAL_GPIO_Init>
 8007a90:	e7da      	b.n	8007a48 <MX_TIM8_Init+0x118>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007a92:	4b5b      	ldr	r3, [pc, #364]	; (8007c00 <MX_TIM8_Init+0x2d0>)
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8007a94:	f44f 46d4 	mov.w	r6, #27136	; 0x6a00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007a98:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007a9a:	a90f      	add	r1, sp, #60	; 0x3c
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007a9c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8007a9e:	2401      	movs	r4, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007aa0:	4859      	ldr	r0, [pc, #356]	; (8007c08 <MX_TIM8_Init+0x2d8>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007aa2:	f042 0210 	orr.w	r2, r2, #16
 8007aa6:	631a      	str	r2, [r3, #48]	; 0x30
 8007aa8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8007aaa:	960f      	str	r6, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007aac:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007ab0:	9510      	str	r5, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8007ab2:	9413      	str	r4, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007ab4:	9301      	str	r3, [sp, #4]
 8007ab6:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007ab8:	f7f9 f84a 	bl	8000b50 <HAL_GPIO_Init>
}
 8007abc:	b026      	add	sp, #152	; 0x98
 8007abe:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007ac0:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8007ac4:	2601      	movs	r6, #1
    GPIO_InitStruct.Pin = PWM14_Pin;
 8007ac6:	2502      	movs	r5, #2
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8007ac8:	a90f      	add	r1, sp, #60	; 0x3c
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007aca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8007acc:	484d      	ldr	r0, [pc, #308]	; (8007c04 <MX_TIM8_Init+0x2d4>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007ace:	4332      	orrs	r2, r6
 8007ad0:	631a      	str	r2, [r3, #48]	; 0x30
 8007ad2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8007ad4:	4032      	ands	r2, r6
 8007ad6:	9202      	str	r2, [sp, #8]
 8007ad8:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007ada:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8007adc:	432a      	orrs	r2, r5
 8007ade:	631a      	str	r2, [r3, #48]	; 0x30
 8007ae0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM14_Pin;
 8007ae2:	950f      	str	r5, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007ae4:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007ae6:	9510      	str	r5, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8007ae8:	9613      	str	r6, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007aea:	9303      	str	r3, [sp, #12]
 8007aec:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8007aee:	f7f9 f82f 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = PWM58_Pin;
 8007af2:	2308      	movs	r3, #8
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8007af4:	a90f      	add	r1, sp, #60	; 0x3c
 8007af6:	4845      	ldr	r0, [pc, #276]	; (8007c0c <MX_TIM8_Init+0x2dc>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007af8:	9510      	str	r5, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8007afa:	9613      	str	r6, [sp, #76]	; 0x4c
    GPIO_InitStruct.Pin = PWM58_Pin;
 8007afc:	930f      	str	r3, [sp, #60]	; 0x3c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8007afe:	e9cd 4411 	strd	r4, r4, [sp, #68]	; 0x44
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8007b02:	f7f9 f825 	bl	8000b50 <HAL_GPIO_Init>
}
 8007b06:	b026      	add	sp, #152	; 0x98
 8007b08:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007b0a:	4b3d      	ldr	r3, [pc, #244]	; (8007c00 <MX_TIM8_Init+0x2d0>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007b0c:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 8007b0e:	2533      	movs	r5, #51	; 0x33
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007b10:	a90f      	add	r1, sp, #60	; 0x3c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007b12:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007b14:	483d      	ldr	r0, [pc, #244]	; (8007c0c <MX_TIM8_Init+0x2dc>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007b16:	4322      	orrs	r2, r4
 8007b18:	631a      	str	r2, [r3, #48]	; 0x30
 8007b1a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 8007b1c:	950f      	str	r5, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007b1e:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007b20:	9410      	str	r4, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8007b22:	9413      	str	r4, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007b24:	9304      	str	r3, [sp, #16]
 8007b26:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007b28:	f7f9 f812 	bl	8000b50 <HAL_GPIO_Init>
}
 8007b2c:	b026      	add	sp, #152	; 0x98
 8007b2e:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007b30:	4b33      	ldr	r3, [pc, #204]	; (8007c00 <MX_TIM8_Init+0x2d0>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007b32:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8007b34:	f44f 4540 	mov.w	r5, #49152	; 0xc000
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007b38:	a90f      	add	r1, sp, #60	; 0x3c
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007b3a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007b3c:	4834      	ldr	r0, [pc, #208]	; (8007c10 <MX_TIM8_Init+0x2e0>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007b3e:	f042 0208 	orr.w	r2, r2, #8
 8007b42:	631a      	str	r2, [r3, #48]	; 0x30
 8007b44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8007b46:	950f      	str	r5, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007b48:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007b4c:	9410      	str	r4, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 8007b4e:	9413      	str	r4, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007b50:	9305      	str	r3, [sp, #20]
 8007b52:	9b05      	ldr	r3, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007b54:	f7f8 fffc 	bl	8000b50 <HAL_GPIO_Init>
 8007b58:	e776      	b.n	8007a48 <MX_TIM8_Init+0x118>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007b5a:	4b29      	ldr	r3, [pc, #164]	; (8007c00 <MX_TIM8_Init+0x2d0>)
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8007b5c:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007b60:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8007b62:	2403      	movs	r4, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007b64:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007b66:	a90f      	add	r1, sp, #60	; 0x3c
 8007b68:	482a      	ldr	r0, [pc, #168]	; (8007c14 <MX_TIM8_Init+0x2e4>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007b6a:	f042 0204 	orr.w	r2, r2, #4
 8007b6e:	631a      	str	r2, [r3, #48]	; 0x30
 8007b70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8007b72:	960f      	str	r6, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007b74:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007b78:	9510      	str	r5, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8007b7a:	9413      	str	r4, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007b7c:	9307      	str	r3, [sp, #28]
 8007b7e:	9b07      	ldr	r3, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007b80:	f7f8 ffe6 	bl	8000b50 <HAL_GPIO_Init>
 8007b84:	e760      	b.n	8007a48 <MX_TIM8_Init+0x118>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007b86:	4b1e      	ldr	r3, [pc, #120]	; (8007c00 <MX_TIM8_Init+0x2d0>)
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8007b88:	2660      	movs	r6, #96	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007b8a:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8007b8c:	2403      	movs	r4, #3
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007b8e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007b90:	a90f      	add	r1, sp, #60	; 0x3c
 8007b92:	481d      	ldr	r0, [pc, #116]	; (8007c08 <MX_TIM8_Init+0x2d8>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007b94:	f042 0210 	orr.w	r2, r2, #16
 8007b98:	631a      	str	r2, [r3, #48]	; 0x30
 8007b9a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8007b9c:	960f      	str	r6, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007b9e:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007ba2:	9510      	str	r5, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8007ba4:	9413      	str	r4, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007ba6:	9308      	str	r3, [sp, #32]
 8007ba8:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007baa:	f7f8 ffd1 	bl	8000b50 <HAL_GPIO_Init>
 8007bae:	e74b      	b.n	8007a48 <MX_TIM8_Init+0x118>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007bb0:	4b13      	ldr	r3, [pc, #76]	; (8007c00 <MX_TIM8_Init+0x2d0>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007bb2:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 8007bb4:	f44f 4640 	mov.w	r6, #49152	; 0xc000
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8007bb8:	2409      	movs	r4, #9
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007bba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007bbc:	a90f      	add	r1, sp, #60	; 0x3c
 8007bbe:	4813      	ldr	r0, [pc, #76]	; (8007c0c <MX_TIM8_Init+0x2dc>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007bc0:	432a      	orrs	r2, r5
 8007bc2:	631a      	str	r2, [r3, #48]	; 0x30
 8007bc4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 8007bc6:	960f      	str	r6, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007bc8:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007bca:	9510      	str	r5, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8007bcc:	9413      	str	r4, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007bce:	930b      	str	r3, [sp, #44]	; 0x2c
 8007bd0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007bd2:	f7f8 ffbd 	bl	8000b50 <HAL_GPIO_Init>
}
 8007bd6:	e737      	b.n	8007a48 <MX_TIM8_Init+0x118>
 8007bd8:	20000f3c 	.word	0x20000f3c
 8007bdc:	40010400 	.word	0x40010400
 8007be0:	40010000 	.word	0x40010000
 8007be4:	40000400 	.word	0x40000400
 8007be8:	40000800 	.word	0x40000800
 8007bec:	40000c00 	.word	0x40000c00
 8007bf0:	40014000 	.word	0x40014000
 8007bf4:	40014400 	.word	0x40014400
 8007bf8:	40014800 	.word	0x40014800
 8007bfc:	40001800 	.word	0x40001800
 8007c00:	40023800 	.word	0x40023800
 8007c04:	40020000 	.word	0x40020000
 8007c08:	40021000 	.word	0x40021000
 8007c0c:	40020400 	.word	0x40020400
 8007c10:	40020c00 	.word	0x40020c00
 8007c14:	40020800 	.word	0x40020800
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c18:	4b13      	ldr	r3, [pc, #76]	; (8007c68 <MX_TIM8_Init+0x338>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007c1a:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM61_Pin;
 8007c1c:	f44f 7680 	mov.w	r6, #256	; 0x100
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8007c20:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c22:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 8007c24:	a90f      	add	r1, sp, #60	; 0x3c
 8007c26:	4811      	ldr	r0, [pc, #68]	; (8007c6c <MX_TIM8_Init+0x33c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c28:	432a      	orrs	r2, r5
 8007c2a:	631a      	str	r2, [r3, #48]	; 0x30
 8007c2c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM61_Pin;
 8007c2e:	960f      	str	r6, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c30:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007c32:	9510      	str	r5, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8007c34:	9413      	str	r4, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c36:	9309      	str	r3, [sp, #36]	; 0x24
 8007c38:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 8007c3a:	f7f8 ff89 	bl	8000b50 <HAL_GPIO_Init>
 8007c3e:	e703      	b.n	8007a48 <MX_TIM8_Init+0x118>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c40:	4b09      	ldr	r3, [pc, #36]	; (8007c68 <MX_TIM8_Init+0x338>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007c42:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM62_Pin;
 8007c44:	f44f 7600 	mov.w	r6, #512	; 0x200
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 8007c48:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c4a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8007c4c:	a90f      	add	r1, sp, #60	; 0x3c
 8007c4e:	4807      	ldr	r0, [pc, #28]	; (8007c6c <MX_TIM8_Init+0x33c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c50:	432a      	orrs	r2, r5
 8007c52:	631a      	str	r2, [r3, #48]	; 0x30
 8007c54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM62_Pin;
 8007c56:	960f      	str	r6, [sp, #60]	; 0x3c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c58:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007c5a:	9510      	str	r5, [sp, #64]	; 0x40
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 8007c5c:	9413      	str	r4, [sp, #76]	; 0x4c
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007c5e:	930a      	str	r3, [sp, #40]	; 0x28
 8007c60:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8007c62:	f7f8 ff75 	bl	8000b50 <HAL_GPIO_Init>
 8007c66:	e6ef      	b.n	8007a48 <MX_TIM8_Init+0x118>
 8007c68:	40023800 	.word	0x40023800
 8007c6c:	40020400 	.word	0x40020400

08007c70 <MX_TIM9_Init>:
{
 8007c70:	b570      	push	{r4, r5, r6, lr}
  htim9.Instance = TIM9;
 8007c72:	489f      	ldr	r0, [pc, #636]	; (8007ef0 <MX_TIM9_Init+0x280>)
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007c74:	2300      	movs	r3, #0
  htim9.Instance = TIM9;
 8007c76:	4c9f      	ldr	r4, [pc, #636]	; (8007ef4 <MX_TIM9_Init+0x284>)
{
 8007c78:	b098      	sub	sp, #96	; 0x60
  htim9.Init.Prescaler = 112;
 8007c7a:	2170      	movs	r1, #112	; 0x70
  htim9.Init.Period = 127;
 8007c7c:	227f      	movs	r2, #127	; 0x7f
  htim9.Instance = TIM9;
 8007c7e:	6020      	str	r0, [r4, #0]
  if (HAL_TIM_PWM_Init(&htim9) != HAL_OK)
 8007c80:	4620      	mov	r0, r4
  htim9.Init.Prescaler = 112;
 8007c82:	6061      	str	r1, [r4, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007c84:	9311      	str	r3, [sp, #68]	; 0x44
  htim9.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8007c86:	6123      	str	r3, [r4, #16]
  htim9.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8007c88:	61a3      	str	r3, [r4, #24]
  htim9.Init.CounterMode = TIM_COUNTERMODE_UP;
 8007c8a:	e9c4 3202 	strd	r3, r2, [r4, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007c8e:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
 8007c92:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
 8007c96:	e9cd 3316 	strd	r3, r3, [sp, #88]	; 0x58
  if (HAL_TIM_PWM_Init(&htim9) != HAL_OK)
 8007c9a:	f7fa fed7 	bl	8002a4c <HAL_TIM_PWM_Init>
 8007c9e:	2800      	cmp	r0, #0
 8007ca0:	d144      	bne.n	8007d2c <MX_TIM9_Init+0xbc>
  sConfigOC.Pulse = 0;
 8007ca2:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8007ca4:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8007ca6:	a911      	add	r1, sp, #68	; 0x44
 8007ca8:	4892      	ldr	r0, [pc, #584]	; (8007ef4 <MX_TIM9_Init+0x284>)
 8007caa:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
 8007cac:	9312      	str	r3, [sp, #72]	; 0x48
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8007cae:	9313      	str	r3, [sp, #76]	; 0x4c
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8007cb0:	9315      	str	r3, [sp, #84]	; 0x54
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8007cb2:	9511      	str	r5, [sp, #68]	; 0x44
  if (HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8007cb4:	f7fa ffba 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 8007cb8:	2800      	cmp	r0, #0
 8007cba:	d134      	bne.n	8007d26 <MX_TIM9_Init+0xb6>
  if (HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8007cbc:	a911      	add	r1, sp, #68	; 0x44
 8007cbe:	2204      	movs	r2, #4
 8007cc0:	488c      	ldr	r0, [pc, #560]	; (8007ef4 <MX_TIM9_Init+0x284>)
 8007cc2:	f7fa ffb3 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 8007cc6:	b108      	cbz	r0, 8007ccc <MX_TIM9_Init+0x5c>
    Error_Handler();
 8007cc8:	f7fe ff3a 	bl	8006b40 <Error_Handler>
  if(timHandle->Instance==TIM1)
 8007ccc:	6823      	ldr	r3, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007cce:	2400      	movs	r4, #0
  if(timHandle->Instance==TIM1)
 8007cd0:	4a89      	ldr	r2, [pc, #548]	; (8007ef8 <MX_TIM9_Init+0x288>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007cd2:	9410      	str	r4, [sp, #64]	; 0x40
  if(timHandle->Instance==TIM1)
 8007cd4:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007cd6:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
 8007cda:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
  if(timHandle->Instance==TIM1)
 8007cde:	d03c      	beq.n	8007d5a <MX_TIM9_Init+0xea>
  else if(timHandle->Instance==TIM2)
 8007ce0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007ce4:	d050      	beq.n	8007d88 <MX_TIM9_Init+0x118>
  else if(timHandle->Instance==TIM3)
 8007ce6:	4a85      	ldr	r2, [pc, #532]	; (8007efc <MX_TIM9_Init+0x28c>)
 8007ce8:	4293      	cmp	r3, r2
 8007cea:	d072      	beq.n	8007dd2 <MX_TIM9_Init+0x162>
  else if(timHandle->Instance==TIM4)
 8007cec:	4a84      	ldr	r2, [pc, #528]	; (8007f00 <MX_TIM9_Init+0x290>)
 8007cee:	4293      	cmp	r3, r2
 8007cf0:	f000 8082 	beq.w	8007df8 <MX_TIM9_Init+0x188>
  else if(timHandle->Instance==TIM5)
 8007cf4:	4a83      	ldr	r2, [pc, #524]	; (8007f04 <MX_TIM9_Init+0x294>)
 8007cf6:	4293      	cmp	r3, r2
 8007cf8:	d01b      	beq.n	8007d32 <MX_TIM9_Init+0xc2>
  else if(timHandle->Instance==TIM8)
 8007cfa:	4a83      	ldr	r2, [pc, #524]	; (8007f08 <MX_TIM9_Init+0x298>)
 8007cfc:	4293      	cmp	r3, r2
 8007cfe:	f000 8090 	beq.w	8007e22 <MX_TIM9_Init+0x1b2>
  else if(timHandle->Instance==TIM9)
 8007d02:	4a7b      	ldr	r2, [pc, #492]	; (8007ef0 <MX_TIM9_Init+0x280>)
 8007d04:	4293      	cmp	r3, r2
 8007d06:	f000 80a2 	beq.w	8007e4e <MX_TIM9_Init+0x1de>
  else if(timHandle->Instance==TIM10)
 8007d0a:	4a80      	ldr	r2, [pc, #512]	; (8007f0c <MX_TIM9_Init+0x29c>)
 8007d0c:	4293      	cmp	r3, r2
 8007d0e:	f000 80c7 	beq.w	8007ea0 <MX_TIM9_Init+0x230>
  else if(timHandle->Instance==TIM11)
 8007d12:	4a7f      	ldr	r2, [pc, #508]	; (8007f10 <MX_TIM9_Init+0x2a0>)
 8007d14:	4293      	cmp	r3, r2
 8007d16:	f000 80d7 	beq.w	8007ec8 <MX_TIM9_Init+0x258>
  else if(timHandle->Instance==TIM12)
 8007d1a:	4a7e      	ldr	r2, [pc, #504]	; (8007f14 <MX_TIM9_Init+0x2a4>)
 8007d1c:	4293      	cmp	r3, r2
 8007d1e:	f000 80ab 	beq.w	8007e78 <MX_TIM9_Init+0x208>
}
 8007d22:	b018      	add	sp, #96	; 0x60
 8007d24:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 8007d26:	f7fe ff0b 	bl	8006b40 <Error_Handler>
 8007d2a:	e7c7      	b.n	8007cbc <MX_TIM9_Init+0x4c>
    Error_Handler();
 8007d2c:	f7fe ff08 	bl	8006b40 <Error_Handler>
 8007d30:	e7b7      	b.n	8007ca2 <MX_TIM9_Init+0x32>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007d32:	4b79      	ldr	r3, [pc, #484]	; (8007f18 <MX_TIM9_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007d34:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8007d36:	250f      	movs	r5, #15
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007d38:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007d3a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007d3c:	4877      	ldr	r0, [pc, #476]	; (8007f1c <MX_TIM9_Init+0x2ac>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007d3e:	f042 0201 	orr.w	r2, r2, #1
 8007d42:	631a      	str	r2, [r3, #48]	; 0x30
 8007d44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8007d46:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007d48:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007d4c:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 8007d4e:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007d50:	9306      	str	r3, [sp, #24]
 8007d52:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007d54:	f7f8 fefc 	bl	8000b50 <HAL_GPIO_Init>
 8007d58:	e7e3      	b.n	8007d22 <MX_TIM9_Init+0xb2>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007d5a:	4b6f      	ldr	r3, [pc, #444]	; (8007f18 <MX_TIM9_Init+0x2a8>)
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8007d5c:	f44f 46d4 	mov.w	r6, #27136	; 0x6a00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007d60:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007d62:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007d64:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8007d66:	2401      	movs	r4, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007d68:	486d      	ldr	r0, [pc, #436]	; (8007f20 <MX_TIM9_Init+0x2b0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007d6a:	f042 0210 	orr.w	r2, r2, #16
 8007d6e:	631a      	str	r2, [r3, #48]	; 0x30
 8007d70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8007d72:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007d74:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007d78:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8007d7a:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007d7c:	9301      	str	r3, [sp, #4]
 8007d7e:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007d80:	f7f8 fee6 	bl	8000b50 <HAL_GPIO_Init>
}
 8007d84:	b018      	add	sp, #96	; 0x60
 8007d86:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007d88:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8007d8c:	2601      	movs	r6, #1
    GPIO_InitStruct.Pin = PWM14_Pin;
 8007d8e:	2502      	movs	r5, #2
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8007d90:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007d92:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8007d94:	4861      	ldr	r0, [pc, #388]	; (8007f1c <MX_TIM9_Init+0x2ac>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007d96:	4332      	orrs	r2, r6
 8007d98:	631a      	str	r2, [r3, #48]	; 0x30
 8007d9a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8007d9c:	4032      	ands	r2, r6
 8007d9e:	9202      	str	r2, [sp, #8]
 8007da0:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007da2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8007da4:	432a      	orrs	r2, r5
 8007da6:	631a      	str	r2, [r3, #48]	; 0x30
 8007da8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM14_Pin;
 8007daa:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007dac:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007dae:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8007db0:	9610      	str	r6, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007db2:	9303      	str	r3, [sp, #12]
 8007db4:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8007db6:	f7f8 fecb 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = PWM58_Pin;
 8007dba:	2308      	movs	r3, #8
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8007dbc:	a90c      	add	r1, sp, #48	; 0x30
 8007dbe:	4859      	ldr	r0, [pc, #356]	; (8007f24 <MX_TIM9_Init+0x2b4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007dc0:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8007dc2:	9610      	str	r6, [sp, #64]	; 0x40
    GPIO_InitStruct.Pin = PWM58_Pin;
 8007dc4:	930c      	str	r3, [sp, #48]	; 0x30
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8007dc6:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8007dca:	f7f8 fec1 	bl	8000b50 <HAL_GPIO_Init>
}
 8007dce:	b018      	add	sp, #96	; 0x60
 8007dd0:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007dd2:	4b51      	ldr	r3, [pc, #324]	; (8007f18 <MX_TIM9_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007dd4:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 8007dd6:	2533      	movs	r5, #51	; 0x33
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007dd8:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007dda:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007ddc:	4851      	ldr	r0, [pc, #324]	; (8007f24 <MX_TIM9_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007dde:	4322      	orrs	r2, r4
 8007de0:	631a      	str	r2, [r3, #48]	; 0x30
 8007de2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 8007de4:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007de6:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007de8:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8007dea:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007dec:	9304      	str	r3, [sp, #16]
 8007dee:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007df0:	f7f8 feae 	bl	8000b50 <HAL_GPIO_Init>
}
 8007df4:	b018      	add	sp, #96	; 0x60
 8007df6:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007df8:	4b47      	ldr	r3, [pc, #284]	; (8007f18 <MX_TIM9_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007dfa:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8007dfc:	f44f 4540 	mov.w	r5, #49152	; 0xc000
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007e00:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007e02:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007e04:	4848      	ldr	r0, [pc, #288]	; (8007f28 <MX_TIM9_Init+0x2b8>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007e06:	f042 0208 	orr.w	r2, r2, #8
 8007e0a:	631a      	str	r2, [r3, #48]	; 0x30
 8007e0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8007e0e:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007e10:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007e14:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 8007e16:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8007e18:	9305      	str	r3, [sp, #20]
 8007e1a:	9b05      	ldr	r3, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007e1c:	f7f8 fe98 	bl	8000b50 <HAL_GPIO_Init>
 8007e20:	e77f      	b.n	8007d22 <MX_TIM9_Init+0xb2>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007e22:	4b3d      	ldr	r3, [pc, #244]	; (8007f18 <MX_TIM9_Init+0x2a8>)
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8007e24:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007e28:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8007e2a:	2403      	movs	r4, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007e2c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007e2e:	a90c      	add	r1, sp, #48	; 0x30
 8007e30:	483e      	ldr	r0, [pc, #248]	; (8007f2c <MX_TIM9_Init+0x2bc>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007e32:	f042 0204 	orr.w	r2, r2, #4
 8007e36:	631a      	str	r2, [r3, #48]	; 0x30
 8007e38:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8007e3a:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007e3c:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007e40:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8007e42:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8007e44:	9307      	str	r3, [sp, #28]
 8007e46:	9b07      	ldr	r3, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007e48:	f7f8 fe82 	bl	8000b50 <HAL_GPIO_Init>
 8007e4c:	e769      	b.n	8007d22 <MX_TIM9_Init+0xb2>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007e4e:	4b32      	ldr	r3, [pc, #200]	; (8007f18 <MX_TIM9_Init+0x2a8>)
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8007e50:	2660      	movs	r6, #96	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007e52:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8007e54:	2403      	movs	r4, #3
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007e56:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007e58:	a90c      	add	r1, sp, #48	; 0x30
 8007e5a:	4831      	ldr	r0, [pc, #196]	; (8007f20 <MX_TIM9_Init+0x2b0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007e5c:	f042 0210 	orr.w	r2, r2, #16
 8007e60:	631a      	str	r2, [r3, #48]	; 0x30
 8007e62:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8007e64:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007e66:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007e6a:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8007e6c:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8007e6e:	9308      	str	r3, [sp, #32]
 8007e70:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8007e72:	f7f8 fe6d 	bl	8000b50 <HAL_GPIO_Init>
 8007e76:	e754      	b.n	8007d22 <MX_TIM9_Init+0xb2>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007e78:	4b27      	ldr	r3, [pc, #156]	; (8007f18 <MX_TIM9_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007e7a:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 8007e7c:	f44f 4640 	mov.w	r6, #49152	; 0xc000
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8007e80:	2409      	movs	r4, #9
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007e82:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007e84:	a90c      	add	r1, sp, #48	; 0x30
 8007e86:	4827      	ldr	r0, [pc, #156]	; (8007f24 <MX_TIM9_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007e88:	432a      	orrs	r2, r5
 8007e8a:	631a      	str	r2, [r3, #48]	; 0x30
 8007e8c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 8007e8e:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007e90:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007e92:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8007e94:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007e96:	930b      	str	r3, [sp, #44]	; 0x2c
 8007e98:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8007e9a:	f7f8 fe59 	bl	8000b50 <HAL_GPIO_Init>
}
 8007e9e:	e740      	b.n	8007d22 <MX_TIM9_Init+0xb2>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007ea0:	4b1d      	ldr	r3, [pc, #116]	; (8007f18 <MX_TIM9_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007ea2:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM61_Pin;
 8007ea4:	f44f 7680 	mov.w	r6, #256	; 0x100
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8007ea8:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007eaa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 8007eac:	a90c      	add	r1, sp, #48	; 0x30
 8007eae:	481d      	ldr	r0, [pc, #116]	; (8007f24 <MX_TIM9_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007eb0:	432a      	orrs	r2, r5
 8007eb2:	631a      	str	r2, [r3, #48]	; 0x30
 8007eb4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM61_Pin;
 8007eb6:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007eb8:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007eba:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8007ebc:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007ebe:	9309      	str	r3, [sp, #36]	; 0x24
 8007ec0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 8007ec2:	f7f8 fe45 	bl	8000b50 <HAL_GPIO_Init>
 8007ec6:	e72c      	b.n	8007d22 <MX_TIM9_Init+0xb2>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007ec8:	4b13      	ldr	r3, [pc, #76]	; (8007f18 <MX_TIM9_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007eca:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM62_Pin;
 8007ecc:	f44f 7600 	mov.w	r6, #512	; 0x200
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 8007ed0:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007ed2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8007ed4:	a90c      	add	r1, sp, #48	; 0x30
 8007ed6:	4813      	ldr	r0, [pc, #76]	; (8007f24 <MX_TIM9_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007ed8:	432a      	orrs	r2, r5
 8007eda:	631a      	str	r2, [r3, #48]	; 0x30
 8007edc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM62_Pin;
 8007ede:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007ee0:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007ee2:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 8007ee4:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007ee6:	930a      	str	r3, [sp, #40]	; 0x28
 8007ee8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8007eea:	f7f8 fe31 	bl	8000b50 <HAL_GPIO_Init>
 8007eee:	e718      	b.n	8007d22 <MX_TIM9_Init+0xb2>
 8007ef0:	40014000 	.word	0x40014000
 8007ef4:	2000117c 	.word	0x2000117c
 8007ef8:	40010000 	.word	0x40010000
 8007efc:	40000400 	.word	0x40000400
 8007f00:	40000800 	.word	0x40000800
 8007f04:	40000c00 	.word	0x40000c00
 8007f08:	40010400 	.word	0x40010400
 8007f0c:	40014400 	.word	0x40014400
 8007f10:	40014800 	.word	0x40014800
 8007f14:	40001800 	.word	0x40001800
 8007f18:	40023800 	.word	0x40023800
 8007f1c:	40020000 	.word	0x40020000
 8007f20:	40021000 	.word	0x40021000
 8007f24:	40020400 	.word	0x40020400
 8007f28:	40020c00 	.word	0x40020c00
 8007f2c:	40020800 	.word	0x40020800

08007f30 <MX_TIM10_Init>:
{
 8007f30:	b570      	push	{r4, r5, r6, lr}
  htim10.Instance = TIM10;
 8007f32:	489e      	ldr	r0, [pc, #632]	; (80081ac <MX_TIM10_Init+0x27c>)
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007f34:	2300      	movs	r3, #0
  htim10.Instance = TIM10;
 8007f36:	4c9e      	ldr	r4, [pc, #632]	; (80081b0 <MX_TIM10_Init+0x280>)
{
 8007f38:	b098      	sub	sp, #96	; 0x60
  htim10.Init.Prescaler = 112;
 8007f3a:	2170      	movs	r1, #112	; 0x70
  htim10.Init.Period = 127;
 8007f3c:	227f      	movs	r2, #127	; 0x7f
  htim10.Instance = TIM10;
 8007f3e:	6020      	str	r0, [r4, #0]
  if (HAL_TIM_Base_Init(&htim10) != HAL_OK)
 8007f40:	4620      	mov	r0, r4
  htim10.Init.Prescaler = 112;
 8007f42:	6061      	str	r1, [r4, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007f44:	9311      	str	r3, [sp, #68]	; 0x44
  htim10.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8007f46:	6123      	str	r3, [r4, #16]
  htim10.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8007f48:	61a3      	str	r3, [r4, #24]
  htim10.Init.CounterMode = TIM_COUNTERMODE_UP;
 8007f4a:	e9c4 3202 	strd	r3, r2, [r4, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8007f4e:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
 8007f52:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
 8007f56:	e9cd 3316 	strd	r3, r3, [sp, #88]	; 0x58
  if (HAL_TIM_Base_Init(&htim10) != HAL_OK)
 8007f5a:	f7fa fcdd 	bl	8002918 <HAL_TIM_Base_Init>
 8007f5e:	2800      	cmp	r0, #0
 8007f60:	d142      	bne.n	8007fe8 <MX_TIM10_Init+0xb8>
  if (HAL_TIM_PWM_Init(&htim10) != HAL_OK)
 8007f62:	4893      	ldr	r0, [pc, #588]	; (80081b0 <MX_TIM10_Init+0x280>)
 8007f64:	f7fa fd72 	bl	8002a4c <HAL_TIM_PWM_Init>
 8007f68:	2800      	cmp	r0, #0
 8007f6a:	d13a      	bne.n	8007fe2 <MX_TIM10_Init+0xb2>
  sConfigOC.Pulse = 0;
 8007f6c:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8007f6e:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim10, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8007f70:	a911      	add	r1, sp, #68	; 0x44
 8007f72:	488f      	ldr	r0, [pc, #572]	; (80081b0 <MX_TIM10_Init+0x280>)
 8007f74:	461a      	mov	r2, r3
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8007f76:	9315      	str	r3, [sp, #84]	; 0x54
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8007f78:	9511      	str	r5, [sp, #68]	; 0x44
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8007f7a:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
  if (HAL_TIM_PWM_ConfigChannel(&htim10, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8007f7e:	f7fa fe55 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 8007f82:	b108      	cbz	r0, 8007f88 <MX_TIM10_Init+0x58>
    Error_Handler();
 8007f84:	f7fe fddc 	bl	8006b40 <Error_Handler>
  if(timHandle->Instance==TIM1)
 8007f88:	6823      	ldr	r3, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007f8a:	2400      	movs	r4, #0
  if(timHandle->Instance==TIM1)
 8007f8c:	4a89      	ldr	r2, [pc, #548]	; (80081b4 <MX_TIM10_Init+0x284>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007f8e:	9410      	str	r4, [sp, #64]	; 0x40
  if(timHandle->Instance==TIM1)
 8007f90:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007f92:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
 8007f96:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
  if(timHandle->Instance==TIM1)
 8007f9a:	d03c      	beq.n	8008016 <MX_TIM10_Init+0xe6>
  else if(timHandle->Instance==TIM2)
 8007f9c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007fa0:	d050      	beq.n	8008044 <MX_TIM10_Init+0x114>
  else if(timHandle->Instance==TIM3)
 8007fa2:	4a85      	ldr	r2, [pc, #532]	; (80081b8 <MX_TIM10_Init+0x288>)
 8007fa4:	4293      	cmp	r3, r2
 8007fa6:	d072      	beq.n	800808e <MX_TIM10_Init+0x15e>
  else if(timHandle->Instance==TIM4)
 8007fa8:	4a84      	ldr	r2, [pc, #528]	; (80081bc <MX_TIM10_Init+0x28c>)
 8007faa:	4293      	cmp	r3, r2
 8007fac:	f000 8082 	beq.w	80080b4 <MX_TIM10_Init+0x184>
  else if(timHandle->Instance==TIM5)
 8007fb0:	4a83      	ldr	r2, [pc, #524]	; (80081c0 <MX_TIM10_Init+0x290>)
 8007fb2:	4293      	cmp	r3, r2
 8007fb4:	d01b      	beq.n	8007fee <MX_TIM10_Init+0xbe>
  else if(timHandle->Instance==TIM8)
 8007fb6:	4a83      	ldr	r2, [pc, #524]	; (80081c4 <MX_TIM10_Init+0x294>)
 8007fb8:	4293      	cmp	r3, r2
 8007fba:	f000 8090 	beq.w	80080de <MX_TIM10_Init+0x1ae>
  else if(timHandle->Instance==TIM9)
 8007fbe:	4a82      	ldr	r2, [pc, #520]	; (80081c8 <MX_TIM10_Init+0x298>)
 8007fc0:	4293      	cmp	r3, r2
 8007fc2:	f000 80a2 	beq.w	800810a <MX_TIM10_Init+0x1da>
  else if(timHandle->Instance==TIM10)
 8007fc6:	4a79      	ldr	r2, [pc, #484]	; (80081ac <MX_TIM10_Init+0x27c>)
 8007fc8:	4293      	cmp	r3, r2
 8007fca:	f000 80c7 	beq.w	800815c <MX_TIM10_Init+0x22c>
  else if(timHandle->Instance==TIM11)
 8007fce:	4a7f      	ldr	r2, [pc, #508]	; (80081cc <MX_TIM10_Init+0x29c>)
 8007fd0:	4293      	cmp	r3, r2
 8007fd2:	f000 80d7 	beq.w	8008184 <MX_TIM10_Init+0x254>
  else if(timHandle->Instance==TIM12)
 8007fd6:	4a7e      	ldr	r2, [pc, #504]	; (80081d0 <MX_TIM10_Init+0x2a0>)
 8007fd8:	4293      	cmp	r3, r2
 8007fda:	f000 80ab 	beq.w	8008134 <MX_TIM10_Init+0x204>
}
 8007fde:	b018      	add	sp, #96	; 0x60
 8007fe0:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 8007fe2:	f7fe fdad 	bl	8006b40 <Error_Handler>
 8007fe6:	e7c1      	b.n	8007f6c <MX_TIM10_Init+0x3c>
    Error_Handler();
 8007fe8:	f7fe fdaa 	bl	8006b40 <Error_Handler>
 8007fec:	e7b9      	b.n	8007f62 <MX_TIM10_Init+0x32>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007fee:	4b79      	ldr	r3, [pc, #484]	; (80081d4 <MX_TIM10_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007ff0:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8007ff2:	250f      	movs	r5, #15
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007ff4:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007ff6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8007ff8:	4877      	ldr	r0, [pc, #476]	; (80081d8 <MX_TIM10_Init+0x2a8>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007ffa:	f042 0201 	orr.w	r2, r2, #1
 8007ffe:	631a      	str	r2, [r3, #48]	; 0x30
 8008000:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 8008002:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008004:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008008:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 800800a:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800800c:	9306      	str	r3, [sp, #24]
 800800e:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008010:	f7f8 fd9e 	bl	8000b50 <HAL_GPIO_Init>
 8008014:	e7e3      	b.n	8007fde <MX_TIM10_Init+0xae>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008016:	4b6f      	ldr	r3, [pc, #444]	; (80081d4 <MX_TIM10_Init+0x2a4>)
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8008018:	f44f 46d4 	mov.w	r6, #27136	; 0x6a00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800801c:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800801e:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008020:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8008022:	2401      	movs	r4, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8008024:	486d      	ldr	r0, [pc, #436]	; (80081dc <MX_TIM10_Init+0x2ac>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008026:	f042 0210 	orr.w	r2, r2, #16
 800802a:	631a      	str	r2, [r3, #48]	; 0x30
 800802c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 800802e:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008030:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008034:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8008036:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008038:	9301      	str	r3, [sp, #4]
 800803a:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800803c:	f7f8 fd88 	bl	8000b50 <HAL_GPIO_Init>
}
 8008040:	b018      	add	sp, #96	; 0x60
 8008042:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008044:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8008048:	2601      	movs	r6, #1
    GPIO_InitStruct.Pin = PWM14_Pin;
 800804a:	2502      	movs	r5, #2
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 800804c:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800804e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8008050:	4861      	ldr	r0, [pc, #388]	; (80081d8 <MX_TIM10_Init+0x2a8>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008052:	4332      	orrs	r2, r6
 8008054:	631a      	str	r2, [r3, #48]	; 0x30
 8008056:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8008058:	4032      	ands	r2, r6
 800805a:	9202      	str	r2, [sp, #8]
 800805c:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800805e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8008060:	432a      	orrs	r2, r5
 8008062:	631a      	str	r2, [r3, #48]	; 0x30
 8008064:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM14_Pin;
 8008066:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008068:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800806a:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 800806c:	9610      	str	r6, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800806e:	9303      	str	r3, [sp, #12]
 8008070:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8008072:	f7f8 fd6d 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = PWM58_Pin;
 8008076:	2308      	movs	r3, #8
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8008078:	a90c      	add	r1, sp, #48	; 0x30
 800807a:	4859      	ldr	r0, [pc, #356]	; (80081e0 <MX_TIM10_Init+0x2b0>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800807c:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 800807e:	9610      	str	r6, [sp, #64]	; 0x40
    GPIO_InitStruct.Pin = PWM58_Pin;
 8008080:	930c      	str	r3, [sp, #48]	; 0x30
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8008082:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8008086:	f7f8 fd63 	bl	8000b50 <HAL_GPIO_Init>
}
 800808a:	b018      	add	sp, #96	; 0x60
 800808c:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800808e:	4b51      	ldr	r3, [pc, #324]	; (80081d4 <MX_TIM10_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008090:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 8008092:	2533      	movs	r5, #51	; 0x33
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008094:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008096:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008098:	4851      	ldr	r0, [pc, #324]	; (80081e0 <MX_TIM10_Init+0x2b0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800809a:	4322      	orrs	r2, r4
 800809c:	631a      	str	r2, [r3, #48]	; 0x30
 800809e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 80080a0:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80080a2:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80080a4:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 80080a6:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80080a8:	9304      	str	r3, [sp, #16]
 80080aa:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80080ac:	f7f8 fd50 	bl	8000b50 <HAL_GPIO_Init>
}
 80080b0:	b018      	add	sp, #96	; 0x60
 80080b2:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80080b4:	4b47      	ldr	r3, [pc, #284]	; (80081d4 <MX_TIM10_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80080b6:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 80080b8:	f44f 4540 	mov.w	r5, #49152	; 0xc000
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80080bc:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80080be:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80080c0:	4848      	ldr	r0, [pc, #288]	; (80081e4 <MX_TIM10_Init+0x2b4>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80080c2:	f042 0208 	orr.w	r2, r2, #8
 80080c6:	631a      	str	r2, [r3, #48]	; 0x30
 80080c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 80080ca:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80080cc:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80080d0:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 80080d2:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80080d4:	9305      	str	r3, [sp, #20]
 80080d6:	9b05      	ldr	r3, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80080d8:	f7f8 fd3a 	bl	8000b50 <HAL_GPIO_Init>
 80080dc:	e77f      	b.n	8007fde <MX_TIM10_Init+0xae>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80080de:	4b3d      	ldr	r3, [pc, #244]	; (80081d4 <MX_TIM10_Init+0x2a4>)
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 80080e0:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80080e4:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 80080e6:	2403      	movs	r4, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80080e8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80080ea:	a90c      	add	r1, sp, #48	; 0x30
 80080ec:	483e      	ldr	r0, [pc, #248]	; (80081e8 <MX_TIM10_Init+0x2b8>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80080ee:	f042 0204 	orr.w	r2, r2, #4
 80080f2:	631a      	str	r2, [r3, #48]	; 0x30
 80080f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 80080f6:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80080f8:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80080fc:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 80080fe:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8008100:	9307      	str	r3, [sp, #28]
 8008102:	9b07      	ldr	r3, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8008104:	f7f8 fd24 	bl	8000b50 <HAL_GPIO_Init>
 8008108:	e769      	b.n	8007fde <MX_TIM10_Init+0xae>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800810a:	4b32      	ldr	r3, [pc, #200]	; (80081d4 <MX_TIM10_Init+0x2a4>)
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 800810c:	2660      	movs	r6, #96	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800810e:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8008110:	2403      	movs	r4, #3
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008112:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8008114:	a90c      	add	r1, sp, #48	; 0x30
 8008116:	4831      	ldr	r0, [pc, #196]	; (80081dc <MX_TIM10_Init+0x2ac>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008118:	f042 0210 	orr.w	r2, r2, #16
 800811c:	631a      	str	r2, [r3, #48]	; 0x30
 800811e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8008120:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008122:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008126:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 8008128:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800812a:	9308      	str	r3, [sp, #32]
 800812c:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800812e:	f7f8 fd0f 	bl	8000b50 <HAL_GPIO_Init>
 8008132:	e754      	b.n	8007fde <MX_TIM10_Init+0xae>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008134:	4b27      	ldr	r3, [pc, #156]	; (80081d4 <MX_TIM10_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008136:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 8008138:	f44f 4640 	mov.w	r6, #49152	; 0xc000
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 800813c:	2409      	movs	r4, #9
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800813e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008140:	a90c      	add	r1, sp, #48	; 0x30
 8008142:	4827      	ldr	r0, [pc, #156]	; (80081e0 <MX_TIM10_Init+0x2b0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008144:	432a      	orrs	r2, r5
 8008146:	631a      	str	r2, [r3, #48]	; 0x30
 8008148:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 800814a:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800814c:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800814e:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8008150:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008152:	930b      	str	r3, [sp, #44]	; 0x2c
 8008154:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008156:	f7f8 fcfb 	bl	8000b50 <HAL_GPIO_Init>
}
 800815a:	e740      	b.n	8007fde <MX_TIM10_Init+0xae>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800815c:	4b1d      	ldr	r3, [pc, #116]	; (80081d4 <MX_TIM10_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800815e:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM61_Pin;
 8008160:	f44f 7680 	mov.w	r6, #256	; 0x100
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8008164:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008166:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 8008168:	a90c      	add	r1, sp, #48	; 0x30
 800816a:	481d      	ldr	r0, [pc, #116]	; (80081e0 <MX_TIM10_Init+0x2b0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800816c:	432a      	orrs	r2, r5
 800816e:	631a      	str	r2, [r3, #48]	; 0x30
 8008170:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM61_Pin;
 8008172:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008174:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008176:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8008178:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800817a:	9309      	str	r3, [sp, #36]	; 0x24
 800817c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 800817e:	f7f8 fce7 	bl	8000b50 <HAL_GPIO_Init>
 8008182:	e72c      	b.n	8007fde <MX_TIM10_Init+0xae>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008184:	4b13      	ldr	r3, [pc, #76]	; (80081d4 <MX_TIM10_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008186:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM62_Pin;
 8008188:	f44f 7600 	mov.w	r6, #512	; 0x200
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 800818c:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800818e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8008190:	a90c      	add	r1, sp, #48	; 0x30
 8008192:	4813      	ldr	r0, [pc, #76]	; (80081e0 <MX_TIM10_Init+0x2b0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008194:	432a      	orrs	r2, r5
 8008196:	631a      	str	r2, [r3, #48]	; 0x30
 8008198:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM62_Pin;
 800819a:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800819c:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800819e:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 80081a0:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80081a2:	930a      	str	r3, [sp, #40]	; 0x28
 80081a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 80081a6:	f7f8 fcd3 	bl	8000b50 <HAL_GPIO_Init>
 80081aa:	e718      	b.n	8007fde <MX_TIM10_Init+0xae>
 80081ac:	40014400 	.word	0x40014400
 80081b0:	20000fbc 	.word	0x20000fbc
 80081b4:	40010000 	.word	0x40010000
 80081b8:	40000400 	.word	0x40000400
 80081bc:	40000800 	.word	0x40000800
 80081c0:	40000c00 	.word	0x40000c00
 80081c4:	40010400 	.word	0x40010400
 80081c8:	40014000 	.word	0x40014000
 80081cc:	40014800 	.word	0x40014800
 80081d0:	40001800 	.word	0x40001800
 80081d4:	40023800 	.word	0x40023800
 80081d8:	40020000 	.word	0x40020000
 80081dc:	40021000 	.word	0x40021000
 80081e0:	40020400 	.word	0x40020400
 80081e4:	40020c00 	.word	0x40020c00
 80081e8:	40020800 	.word	0x40020800

080081ec <MX_TIM11_Init>:
{
 80081ec:	b570      	push	{r4, r5, r6, lr}
  htim11.Instance = TIM11;
 80081ee:	489e      	ldr	r0, [pc, #632]	; (8008468 <MX_TIM11_Init+0x27c>)
  TIM_OC_InitTypeDef sConfigOC = {0};
 80081f0:	2300      	movs	r3, #0
  htim11.Instance = TIM11;
 80081f2:	4c9e      	ldr	r4, [pc, #632]	; (800846c <MX_TIM11_Init+0x280>)
{
 80081f4:	b098      	sub	sp, #96	; 0x60
  htim11.Init.Prescaler = 112;
 80081f6:	2170      	movs	r1, #112	; 0x70
  htim11.Init.Period = 127;
 80081f8:	227f      	movs	r2, #127	; 0x7f
  htim11.Instance = TIM11;
 80081fa:	6020      	str	r0, [r4, #0]
  if (HAL_TIM_Base_Init(&htim11) != HAL_OK)
 80081fc:	4620      	mov	r0, r4
  htim11.Init.Prescaler = 112;
 80081fe:	6061      	str	r1, [r4, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8008200:	9311      	str	r3, [sp, #68]	; 0x44
  htim11.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8008202:	6123      	str	r3, [r4, #16]
  htim11.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8008204:	61a3      	str	r3, [r4, #24]
  htim11.Init.CounterMode = TIM_COUNTERMODE_UP;
 8008206:	e9c4 3202 	strd	r3, r2, [r4, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 800820a:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
 800820e:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
 8008212:	e9cd 3316 	strd	r3, r3, [sp, #88]	; 0x58
  if (HAL_TIM_Base_Init(&htim11) != HAL_OK)
 8008216:	f7fa fb7f 	bl	8002918 <HAL_TIM_Base_Init>
 800821a:	2800      	cmp	r0, #0
 800821c:	d142      	bne.n	80082a4 <MX_TIM11_Init+0xb8>
  if (HAL_TIM_PWM_Init(&htim11) != HAL_OK)
 800821e:	4893      	ldr	r0, [pc, #588]	; (800846c <MX_TIM11_Init+0x280>)
 8008220:	f7fa fc14 	bl	8002a4c <HAL_TIM_PWM_Init>
 8008224:	2800      	cmp	r0, #0
 8008226:	d13a      	bne.n	800829e <MX_TIM11_Init+0xb2>
  sConfigOC.Pulse = 0;
 8008228:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800822a:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim11, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800822c:	a911      	add	r1, sp, #68	; 0x44
 800822e:	488f      	ldr	r0, [pc, #572]	; (800846c <MX_TIM11_Init+0x280>)
 8008230:	461a      	mov	r2, r3
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8008232:	9315      	str	r3, [sp, #84]	; 0x54
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8008234:	9511      	str	r5, [sp, #68]	; 0x44
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8008236:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
  if (HAL_TIM_PWM_ConfigChannel(&htim11, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800823a:	f7fa fcf7 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 800823e:	b108      	cbz	r0, 8008244 <MX_TIM11_Init+0x58>
    Error_Handler();
 8008240:	f7fe fc7e 	bl	8006b40 <Error_Handler>
  if(timHandle->Instance==TIM1)
 8008244:	6823      	ldr	r3, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8008246:	2400      	movs	r4, #0
  if(timHandle->Instance==TIM1)
 8008248:	4a89      	ldr	r2, [pc, #548]	; (8008470 <MX_TIM11_Init+0x284>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800824a:	9410      	str	r4, [sp, #64]	; 0x40
  if(timHandle->Instance==TIM1)
 800824c:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800824e:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
 8008252:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
  if(timHandle->Instance==TIM1)
 8008256:	d03c      	beq.n	80082d2 <MX_TIM11_Init+0xe6>
  else if(timHandle->Instance==TIM2)
 8008258:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800825c:	d050      	beq.n	8008300 <MX_TIM11_Init+0x114>
  else if(timHandle->Instance==TIM3)
 800825e:	4a85      	ldr	r2, [pc, #532]	; (8008474 <MX_TIM11_Init+0x288>)
 8008260:	4293      	cmp	r3, r2
 8008262:	d072      	beq.n	800834a <MX_TIM11_Init+0x15e>
  else if(timHandle->Instance==TIM4)
 8008264:	4a84      	ldr	r2, [pc, #528]	; (8008478 <MX_TIM11_Init+0x28c>)
 8008266:	4293      	cmp	r3, r2
 8008268:	f000 8082 	beq.w	8008370 <MX_TIM11_Init+0x184>
  else if(timHandle->Instance==TIM5)
 800826c:	4a83      	ldr	r2, [pc, #524]	; (800847c <MX_TIM11_Init+0x290>)
 800826e:	4293      	cmp	r3, r2
 8008270:	d01b      	beq.n	80082aa <MX_TIM11_Init+0xbe>
  else if(timHandle->Instance==TIM8)
 8008272:	4a83      	ldr	r2, [pc, #524]	; (8008480 <MX_TIM11_Init+0x294>)
 8008274:	4293      	cmp	r3, r2
 8008276:	f000 8090 	beq.w	800839a <MX_TIM11_Init+0x1ae>
  else if(timHandle->Instance==TIM9)
 800827a:	4a82      	ldr	r2, [pc, #520]	; (8008484 <MX_TIM11_Init+0x298>)
 800827c:	4293      	cmp	r3, r2
 800827e:	f000 80a2 	beq.w	80083c6 <MX_TIM11_Init+0x1da>
  else if(timHandle->Instance==TIM10)
 8008282:	4a81      	ldr	r2, [pc, #516]	; (8008488 <MX_TIM11_Init+0x29c>)
 8008284:	4293      	cmp	r3, r2
 8008286:	f000 80c7 	beq.w	8008418 <MX_TIM11_Init+0x22c>
  else if(timHandle->Instance==TIM11)
 800828a:	4a77      	ldr	r2, [pc, #476]	; (8008468 <MX_TIM11_Init+0x27c>)
 800828c:	4293      	cmp	r3, r2
 800828e:	f000 80d7 	beq.w	8008440 <MX_TIM11_Init+0x254>
  else if(timHandle->Instance==TIM12)
 8008292:	4a7e      	ldr	r2, [pc, #504]	; (800848c <MX_TIM11_Init+0x2a0>)
 8008294:	4293      	cmp	r3, r2
 8008296:	f000 80ab 	beq.w	80083f0 <MX_TIM11_Init+0x204>
}
 800829a:	b018      	add	sp, #96	; 0x60
 800829c:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 800829e:	f7fe fc4f 	bl	8006b40 <Error_Handler>
 80082a2:	e7c1      	b.n	8008228 <MX_TIM11_Init+0x3c>
    Error_Handler();
 80082a4:	f7fe fc4c 	bl	8006b40 <Error_Handler>
 80082a8:	e7b9      	b.n	800821e <MX_TIM11_Init+0x32>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80082aa:	4b79      	ldr	r3, [pc, #484]	; (8008490 <MX_TIM11_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80082ac:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 80082ae:	250f      	movs	r5, #15
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80082b0:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80082b2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80082b4:	4877      	ldr	r0, [pc, #476]	; (8008494 <MX_TIM11_Init+0x2a8>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80082b6:	f042 0201 	orr.w	r2, r2, #1
 80082ba:	631a      	str	r2, [r3, #48]	; 0x30
 80082bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 80082be:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80082c0:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80082c4:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 80082c6:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80082c8:	9306      	str	r3, [sp, #24]
 80082ca:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80082cc:	f7f8 fc40 	bl	8000b50 <HAL_GPIO_Init>
 80082d0:	e7e3      	b.n	800829a <MX_TIM11_Init+0xae>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80082d2:	4b6f      	ldr	r3, [pc, #444]	; (8008490 <MX_TIM11_Init+0x2a4>)
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 80082d4:	f44f 46d4 	mov.w	r6, #27136	; 0x6a00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80082d8:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80082da:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80082dc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 80082de:	2401      	movs	r4, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80082e0:	486d      	ldr	r0, [pc, #436]	; (8008498 <MX_TIM11_Init+0x2ac>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80082e2:	f042 0210 	orr.w	r2, r2, #16
 80082e6:	631a      	str	r2, [r3, #48]	; 0x30
 80082e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 80082ea:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80082ec:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80082f0:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 80082f2:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80082f4:	9301      	str	r3, [sp, #4]
 80082f6:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80082f8:	f7f8 fc2a 	bl	8000b50 <HAL_GPIO_Init>
}
 80082fc:	b018      	add	sp, #96	; 0x60
 80082fe:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008300:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8008304:	2601      	movs	r6, #1
    GPIO_InitStruct.Pin = PWM14_Pin;
 8008306:	2502      	movs	r5, #2
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 8008308:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800830a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 800830c:	4861      	ldr	r0, [pc, #388]	; (8008494 <MX_TIM11_Init+0x2a8>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800830e:	4332      	orrs	r2, r6
 8008310:	631a      	str	r2, [r3, #48]	; 0x30
 8008312:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8008314:	4032      	ands	r2, r6
 8008316:	9202      	str	r2, [sp, #8]
 8008318:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800831a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800831c:	432a      	orrs	r2, r5
 800831e:	631a      	str	r2, [r3, #48]	; 0x30
 8008320:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM14_Pin;
 8008322:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008324:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008326:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8008328:	9610      	str	r6, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800832a:	9303      	str	r3, [sp, #12]
 800832c:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 800832e:	f7f8 fc0f 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = PWM58_Pin;
 8008332:	2308      	movs	r3, #8
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8008334:	a90c      	add	r1, sp, #48	; 0x30
 8008336:	4859      	ldr	r0, [pc, #356]	; (800849c <MX_TIM11_Init+0x2b0>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008338:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 800833a:	9610      	str	r6, [sp, #64]	; 0x40
    GPIO_InitStruct.Pin = PWM58_Pin;
 800833c:	930c      	str	r3, [sp, #48]	; 0x30
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800833e:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8008342:	f7f8 fc05 	bl	8000b50 <HAL_GPIO_Init>
}
 8008346:	b018      	add	sp, #96	; 0x60
 8008348:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800834a:	4b51      	ldr	r3, [pc, #324]	; (8008490 <MX_TIM11_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800834c:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 800834e:	2533      	movs	r5, #51	; 0x33
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008350:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008352:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008354:	4851      	ldr	r0, [pc, #324]	; (800849c <MX_TIM11_Init+0x2b0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008356:	4322      	orrs	r2, r4
 8008358:	631a      	str	r2, [r3, #48]	; 0x30
 800835a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 800835c:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800835e:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008360:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8008362:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008364:	9304      	str	r3, [sp, #16]
 8008366:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008368:	f7f8 fbf2 	bl	8000b50 <HAL_GPIO_Init>
}
 800836c:	b018      	add	sp, #96	; 0x60
 800836e:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8008370:	4b47      	ldr	r3, [pc, #284]	; (8008490 <MX_TIM11_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008372:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8008374:	f44f 4540 	mov.w	r5, #49152	; 0xc000
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8008378:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800837a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800837c:	4848      	ldr	r0, [pc, #288]	; (80084a0 <MX_TIM11_Init+0x2b4>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800837e:	f042 0208 	orr.w	r2, r2, #8
 8008382:	631a      	str	r2, [r3, #48]	; 0x30
 8008384:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8008386:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8008388:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800838c:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 800838e:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8008390:	9305      	str	r3, [sp, #20]
 8008392:	9b05      	ldr	r3, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8008394:	f7f8 fbdc 	bl	8000b50 <HAL_GPIO_Init>
 8008398:	e77f      	b.n	800829a <MX_TIM11_Init+0xae>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800839a:	4b3d      	ldr	r3, [pc, #244]	; (8008490 <MX_TIM11_Init+0x2a4>)
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 800839c:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80083a0:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 80083a2:	2403      	movs	r4, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80083a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80083a6:	a90c      	add	r1, sp, #48	; 0x30
 80083a8:	483e      	ldr	r0, [pc, #248]	; (80084a4 <MX_TIM11_Init+0x2b8>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80083aa:	f042 0204 	orr.w	r2, r2, #4
 80083ae:	631a      	str	r2, [r3, #48]	; 0x30
 80083b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 80083b2:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80083b4:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80083b8:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 80083ba:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80083bc:	9307      	str	r3, [sp, #28]
 80083be:	9b07      	ldr	r3, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80083c0:	f7f8 fbc6 	bl	8000b50 <HAL_GPIO_Init>
 80083c4:	e769      	b.n	800829a <MX_TIM11_Init+0xae>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80083c6:	4b32      	ldr	r3, [pc, #200]	; (8008490 <MX_TIM11_Init+0x2a4>)
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 80083c8:	2660      	movs	r6, #96	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80083ca:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 80083cc:	2403      	movs	r4, #3
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80083ce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80083d0:	a90c      	add	r1, sp, #48	; 0x30
 80083d2:	4831      	ldr	r0, [pc, #196]	; (8008498 <MX_TIM11_Init+0x2ac>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80083d4:	f042 0210 	orr.w	r2, r2, #16
 80083d8:	631a      	str	r2, [r3, #48]	; 0x30
 80083da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 80083dc:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80083de:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80083e2:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 80083e4:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80083e6:	9308      	str	r3, [sp, #32]
 80083e8:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80083ea:	f7f8 fbb1 	bl	8000b50 <HAL_GPIO_Init>
 80083ee:	e754      	b.n	800829a <MX_TIM11_Init+0xae>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80083f0:	4b27      	ldr	r3, [pc, #156]	; (8008490 <MX_TIM11_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80083f2:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 80083f4:	f44f 4640 	mov.w	r6, #49152	; 0xc000
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 80083f8:	2409      	movs	r4, #9
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80083fa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80083fc:	a90c      	add	r1, sp, #48	; 0x30
 80083fe:	4827      	ldr	r0, [pc, #156]	; (800849c <MX_TIM11_Init+0x2b0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008400:	432a      	orrs	r2, r5
 8008402:	631a      	str	r2, [r3, #48]	; 0x30
 8008404:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 8008406:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008408:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800840a:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 800840c:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800840e:	930b      	str	r3, [sp, #44]	; 0x2c
 8008410:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008412:	f7f8 fb9d 	bl	8000b50 <HAL_GPIO_Init>
}
 8008416:	e740      	b.n	800829a <MX_TIM11_Init+0xae>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008418:	4b1d      	ldr	r3, [pc, #116]	; (8008490 <MX_TIM11_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800841a:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM61_Pin;
 800841c:	f44f 7680 	mov.w	r6, #256	; 0x100
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8008420:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008422:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 8008424:	a90c      	add	r1, sp, #48	; 0x30
 8008426:	481d      	ldr	r0, [pc, #116]	; (800849c <MX_TIM11_Init+0x2b0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008428:	432a      	orrs	r2, r5
 800842a:	631a      	str	r2, [r3, #48]	; 0x30
 800842c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM61_Pin;
 800842e:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008430:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008432:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 8008434:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008436:	9309      	str	r3, [sp, #36]	; 0x24
 8008438:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 800843a:	f7f8 fb89 	bl	8000b50 <HAL_GPIO_Init>
 800843e:	e72c      	b.n	800829a <MX_TIM11_Init+0xae>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008440:	4b13      	ldr	r3, [pc, #76]	; (8008490 <MX_TIM11_Init+0x2a4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008442:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM62_Pin;
 8008444:	f44f 7600 	mov.w	r6, #512	; 0x200
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 8008448:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800844a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 800844c:	a90c      	add	r1, sp, #48	; 0x30
 800844e:	4813      	ldr	r0, [pc, #76]	; (800849c <MX_TIM11_Init+0x2b0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008450:	432a      	orrs	r2, r5
 8008452:	631a      	str	r2, [r3, #48]	; 0x30
 8008454:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM62_Pin;
 8008456:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008458:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800845a:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 800845c:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800845e:	930a      	str	r3, [sp, #40]	; 0x28
 8008460:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8008462:	f7f8 fb75 	bl	8000b50 <HAL_GPIO_Init>
 8008466:	e718      	b.n	800829a <MX_TIM11_Init+0xae>
 8008468:	40014800 	.word	0x40014800
 800846c:	200010bc 	.word	0x200010bc
 8008470:	40010000 	.word	0x40010000
 8008474:	40000400 	.word	0x40000400
 8008478:	40000800 	.word	0x40000800
 800847c:	40000c00 	.word	0x40000c00
 8008480:	40010400 	.word	0x40010400
 8008484:	40014000 	.word	0x40014000
 8008488:	40014400 	.word	0x40014400
 800848c:	40001800 	.word	0x40001800
 8008490:	40023800 	.word	0x40023800
 8008494:	40020000 	.word	0x40020000
 8008498:	40021000 	.word	0x40021000
 800849c:	40020400 	.word	0x40020400
 80084a0:	40020c00 	.word	0x40020c00
 80084a4:	40020800 	.word	0x40020800

080084a8 <MX_TIM12_Init>:
{
 80084a8:	b570      	push	{r4, r5, r6, lr}
  htim12.Instance = TIM12;
 80084aa:	489f      	ldr	r0, [pc, #636]	; (8008728 <MX_TIM12_Init+0x280>)
  TIM_OC_InitTypeDef sConfigOC = {0};
 80084ac:	2300      	movs	r3, #0
  htim12.Instance = TIM12;
 80084ae:	4c9f      	ldr	r4, [pc, #636]	; (800872c <MX_TIM12_Init+0x284>)
{
 80084b0:	b098      	sub	sp, #96	; 0x60
  htim12.Init.Prescaler = 56;
 80084b2:	2138      	movs	r1, #56	; 0x38
  htim12.Init.Period = 127;
 80084b4:	227f      	movs	r2, #127	; 0x7f
  htim12.Instance = TIM12;
 80084b6:	6020      	str	r0, [r4, #0]
  if (HAL_TIM_PWM_Init(&htim12) != HAL_OK)
 80084b8:	4620      	mov	r0, r4
  htim12.Init.Prescaler = 56;
 80084ba:	6061      	str	r1, [r4, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 80084bc:	9311      	str	r3, [sp, #68]	; 0x44
  htim12.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80084be:	6123      	str	r3, [r4, #16]
  htim12.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80084c0:	61a3      	str	r3, [r4, #24]
  htim12.Init.CounterMode = TIM_COUNTERMODE_UP;
 80084c2:	e9c4 3202 	strd	r3, r2, [r4, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 80084c6:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
 80084ca:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
 80084ce:	e9cd 3316 	strd	r3, r3, [sp, #88]	; 0x58
  if (HAL_TIM_PWM_Init(&htim12) != HAL_OK)
 80084d2:	f7fa fabb 	bl	8002a4c <HAL_TIM_PWM_Init>
 80084d6:	2800      	cmp	r0, #0
 80084d8:	d144      	bne.n	8008564 <MX_TIM12_Init+0xbc>
  sConfigOC.Pulse = 0;
 80084da:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80084dc:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80084de:	a911      	add	r1, sp, #68	; 0x44
 80084e0:	4892      	ldr	r0, [pc, #584]	; (800872c <MX_TIM12_Init+0x284>)
 80084e2:	461a      	mov	r2, r3
  sConfigOC.Pulse = 0;
 80084e4:	9312      	str	r3, [sp, #72]	; 0x48
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80084e6:	9313      	str	r3, [sp, #76]	; 0x4c
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80084e8:	9315      	str	r3, [sp, #84]	; 0x54
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80084ea:	9511      	str	r5, [sp, #68]	; 0x44
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 80084ec:	f7fa fb9e 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80084f0:	2800      	cmp	r0, #0
 80084f2:	d134      	bne.n	800855e <MX_TIM12_Init+0xb6>
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 80084f4:	a911      	add	r1, sp, #68	; 0x44
 80084f6:	2204      	movs	r2, #4
 80084f8:	488c      	ldr	r0, [pc, #560]	; (800872c <MX_TIM12_Init+0x284>)
 80084fa:	f7fa fb97 	bl	8002c2c <HAL_TIM_PWM_ConfigChannel>
 80084fe:	b108      	cbz	r0, 8008504 <MX_TIM12_Init+0x5c>
    Error_Handler();
 8008500:	f7fe fb1e 	bl	8006b40 <Error_Handler>
  if(timHandle->Instance==TIM1)
 8008504:	6823      	ldr	r3, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8008506:	2400      	movs	r4, #0
  if(timHandle->Instance==TIM1)
 8008508:	4a89      	ldr	r2, [pc, #548]	; (8008730 <MX_TIM12_Init+0x288>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800850a:	9410      	str	r4, [sp, #64]	; 0x40
  if(timHandle->Instance==TIM1)
 800850c:	4293      	cmp	r3, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800850e:	e9cd 440c 	strd	r4, r4, [sp, #48]	; 0x30
 8008512:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
  if(timHandle->Instance==TIM1)
 8008516:	d03c      	beq.n	8008592 <MX_TIM12_Init+0xea>
  else if(timHandle->Instance==TIM2)
 8008518:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800851c:	d050      	beq.n	80085c0 <MX_TIM12_Init+0x118>
  else if(timHandle->Instance==TIM3)
 800851e:	4a85      	ldr	r2, [pc, #532]	; (8008734 <MX_TIM12_Init+0x28c>)
 8008520:	4293      	cmp	r3, r2
 8008522:	d072      	beq.n	800860a <MX_TIM12_Init+0x162>
  else if(timHandle->Instance==TIM4)
 8008524:	4a84      	ldr	r2, [pc, #528]	; (8008738 <MX_TIM12_Init+0x290>)
 8008526:	4293      	cmp	r3, r2
 8008528:	f000 8082 	beq.w	8008630 <MX_TIM12_Init+0x188>
  else if(timHandle->Instance==TIM5)
 800852c:	4a83      	ldr	r2, [pc, #524]	; (800873c <MX_TIM12_Init+0x294>)
 800852e:	4293      	cmp	r3, r2
 8008530:	d01b      	beq.n	800856a <MX_TIM12_Init+0xc2>
  else if(timHandle->Instance==TIM8)
 8008532:	4a83      	ldr	r2, [pc, #524]	; (8008740 <MX_TIM12_Init+0x298>)
 8008534:	4293      	cmp	r3, r2
 8008536:	f000 8090 	beq.w	800865a <MX_TIM12_Init+0x1b2>
  else if(timHandle->Instance==TIM9)
 800853a:	4a82      	ldr	r2, [pc, #520]	; (8008744 <MX_TIM12_Init+0x29c>)
 800853c:	4293      	cmp	r3, r2
 800853e:	f000 80a2 	beq.w	8008686 <MX_TIM12_Init+0x1de>
  else if(timHandle->Instance==TIM10)
 8008542:	4a81      	ldr	r2, [pc, #516]	; (8008748 <MX_TIM12_Init+0x2a0>)
 8008544:	4293      	cmp	r3, r2
 8008546:	f000 80c7 	beq.w	80086d8 <MX_TIM12_Init+0x230>
  else if(timHandle->Instance==TIM11)
 800854a:	4a80      	ldr	r2, [pc, #512]	; (800874c <MX_TIM12_Init+0x2a4>)
 800854c:	4293      	cmp	r3, r2
 800854e:	f000 80d7 	beq.w	8008700 <MX_TIM12_Init+0x258>
  else if(timHandle->Instance==TIM12)
 8008552:	4a75      	ldr	r2, [pc, #468]	; (8008728 <MX_TIM12_Init+0x280>)
 8008554:	4293      	cmp	r3, r2
 8008556:	f000 80ab 	beq.w	80086b0 <MX_TIM12_Init+0x208>
}
 800855a:	b018      	add	sp, #96	; 0x60
 800855c:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 800855e:	f7fe faef 	bl	8006b40 <Error_Handler>
 8008562:	e7c7      	b.n	80084f4 <MX_TIM12_Init+0x4c>
    Error_Handler();
 8008564:	f7fe faec 	bl	8006b40 <Error_Handler>
 8008568:	e7b7      	b.n	80084da <MX_TIM12_Init+0x32>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800856a:	4b79      	ldr	r3, [pc, #484]	; (8008750 <MX_TIM12_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800856c:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 800856e:	250f      	movs	r5, #15
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008570:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008572:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008574:	4877      	ldr	r0, [pc, #476]	; (8008754 <MX_TIM12_Init+0x2ac>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008576:	f042 0201 	orr.w	r2, r2, #1
 800857a:	631a      	str	r2, [r3, #48]	; 0x30
 800857c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM13_Pin|PWM14_Pin|PWM15_Pin|PWM16_Pin;
 800857e:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008580:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008584:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 8008586:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008588:	9306      	str	r3, [sp, #24]
 800858a:	9b06      	ldr	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800858c:	f7f8 fae0 	bl	8000b50 <HAL_GPIO_Init>
 8008590:	e7e3      	b.n	800855a <MX_TIM12_Init+0xb2>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008592:	4b6f      	ldr	r3, [pc, #444]	; (8008750 <MX_TIM12_Init+0x2a8>)
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 8008594:	f44f 46d4 	mov.w	r6, #27136	; 0x6a00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008598:	2502      	movs	r5, #2
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800859a:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800859c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 800859e:	2401      	movs	r4, #1
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80085a0:	486d      	ldr	r0, [pc, #436]	; (8008758 <MX_TIM12_Init+0x2b0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80085a2:	f042 0210 	orr.w	r2, r2, #16
 80085a6:	631a      	str	r2, [r3, #48]	; 0x30
 80085a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM24_Pin|PWM26_Pin|PWM28_Pin|PWM29_Pin;
 80085aa:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80085ac:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80085b0:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 80085b2:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80085b4:	9301      	str	r3, [sp, #4]
 80085b6:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80085b8:	f7f8 faca 	bl	8000b50 <HAL_GPIO_Init>
}
 80085bc:	b018      	add	sp, #96	; 0x60
 80085be:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80085c0:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80085c4:	2601      	movs	r6, #1
    GPIO_InitStruct.Pin = PWM14_Pin;
 80085c6:	2502      	movs	r5, #2
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80085c8:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80085ca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80085cc:	4861      	ldr	r0, [pc, #388]	; (8008754 <MX_TIM12_Init+0x2ac>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80085ce:	4332      	orrs	r2, r6
 80085d0:	631a      	str	r2, [r3, #48]	; 0x30
 80085d2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80085d4:	4032      	ands	r2, r6
 80085d6:	9202      	str	r2, [sp, #8]
 80085d8:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80085da:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80085dc:	432a      	orrs	r2, r5
 80085de:	631a      	str	r2, [r3, #48]	; 0x30
 80085e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM14_Pin;
 80085e2:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80085e4:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80085e6:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80085e8:	9610      	str	r6, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80085ea:	9303      	str	r3, [sp, #12]
 80085ec:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(PWM14_GPIO_Port, &GPIO_InitStruct);
 80085ee:	f7f8 faaf 	bl	8000b50 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = PWM58_Pin;
 80085f2:	2308      	movs	r3, #8
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 80085f4:	a90c      	add	r1, sp, #48	; 0x30
 80085f6:	4859      	ldr	r0, [pc, #356]	; (800875c <MX_TIM12_Init+0x2b4>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80085f8:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80085fa:	9610      	str	r6, [sp, #64]	; 0x40
    GPIO_InitStruct.Pin = PWM58_Pin;
 80085fc:	930c      	str	r3, [sp, #48]	; 0x30
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80085fe:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
    HAL_GPIO_Init(PWM58_GPIO_Port, &GPIO_InitStruct);
 8008602:	f7f8 faa5 	bl	8000b50 <HAL_GPIO_Init>
}
 8008606:	b018      	add	sp, #96	; 0x60
 8008608:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800860a:	4b51      	ldr	r3, [pc, #324]	; (8008750 <MX_TIM12_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800860c:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 800860e:	2533      	movs	r5, #51	; 0x33
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008610:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008612:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008614:	4851      	ldr	r0, [pc, #324]	; (800875c <MX_TIM12_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008616:	4322      	orrs	r2, r4
 8008618:	631a      	str	r2, [r3, #48]	; 0x30
 800861a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM19_Pin|PWM20_Pin|PWM59_Pin|PWM60_Pin;
 800861c:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800861e:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008620:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8008622:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008624:	9304      	str	r3, [sp, #16]
 8008626:	9b04      	ldr	r3, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008628:	f7f8 fa92 	bl	8000b50 <HAL_GPIO_Init>
}
 800862c:	b018      	add	sp, #96	; 0x60
 800862e:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8008630:	4b47      	ldr	r3, [pc, #284]	; (8008750 <MX_TIM12_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008632:	2402      	movs	r4, #2
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8008634:	f44f 4540 	mov.w	r5, #49152	; 0xc000
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8008638:	a90c      	add	r1, sp, #48	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800863a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800863c:	4848      	ldr	r0, [pc, #288]	; (8008760 <MX_TIM12_Init+0x2b8>)
    __HAL_RCC_GPIOD_CLK_ENABLE();
 800863e:	f042 0208 	orr.w	r2, r2, #8
 8008642:	631a      	str	r2, [r3, #48]	; 0x30
 8008644:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM39_Pin|PWM40_Pin;
 8008646:	950c      	str	r5, [sp, #48]	; 0x30
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8008648:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800864c:	940d      	str	r4, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 800864e:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8008650:	9305      	str	r3, [sp, #20]
 8008652:	9b05      	ldr	r3, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8008654:	f7f8 fa7c 	bl	8000b50 <HAL_GPIO_Init>
 8008658:	e77f      	b.n	800855a <MX_TIM12_Init+0xb2>
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800865a:	4b3d      	ldr	r3, [pc, #244]	; (8008750 <MX_TIM12_Init+0x2a8>)
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 800865c:	f44f 76e0 	mov.w	r6, #448	; 0x1c0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008660:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 8008662:	2403      	movs	r4, #3
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8008664:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8008666:	a90c      	add	r1, sp, #48	; 0x30
 8008668:	483e      	ldr	r0, [pc, #248]	; (8008764 <MX_TIM12_Init+0x2bc>)
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800866a:	f042 0204 	orr.w	r2, r2, #4
 800866e:	631a      	str	r2, [r3, #48]	; 0x30
 8008670:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM41_Pin|PWM42_Pin|PWM43_Pin;
 8008672:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8008674:	f003 0304 	and.w	r3, r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008678:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM8;
 800867a:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOC_CLK_ENABLE();
 800867c:	9307      	str	r3, [sp, #28]
 800867e:	9b07      	ldr	r3, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8008680:	f7f8 fa66 	bl	8000b50 <HAL_GPIO_Init>
 8008684:	e769      	b.n	800855a <MX_TIM12_Init+0xb2>
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008686:	4b32      	ldr	r3, [pc, #200]	; (8008750 <MX_TIM12_Init+0x2a8>)
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 8008688:	2660      	movs	r6, #96	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800868a:	2502      	movs	r5, #2
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 800868c:	2403      	movs	r4, #3
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800868e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8008690:	a90c      	add	r1, sp, #48	; 0x30
 8008692:	4831      	ldr	r0, [pc, #196]	; (8008758 <MX_TIM12_Init+0x2b0>)
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008694:	f042 0210 	orr.w	r2, r2, #16
 8008698:	631a      	str	r2, [r3, #48]	; 0x30
 800869a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM4_Pin|PWM5_Pin;
 800869c:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800869e:	f003 0310 	and.w	r3, r3, #16
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80086a2:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM9;
 80086a4:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80086a6:	9308      	str	r3, [sp, #32]
 80086a8:	9b08      	ldr	r3, [sp, #32]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80086aa:	f7f8 fa51 	bl	8000b50 <HAL_GPIO_Init>
 80086ae:	e754      	b.n	800855a <MX_TIM12_Init+0xb2>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086b0:	4b27      	ldr	r3, [pc, #156]	; (8008750 <MX_TIM12_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80086b2:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 80086b4:	f44f 4640 	mov.w	r6, #49152	; 0xc000
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 80086b8:	2409      	movs	r4, #9
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086ba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80086bc:	a90c      	add	r1, sp, #48	; 0x30
 80086be:	4827      	ldr	r0, [pc, #156]	; (800875c <MX_TIM12_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086c0:	432a      	orrs	r2, r5
 80086c2:	631a      	str	r2, [r3, #48]	; 0x30
 80086c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM33_Pin|PWM34_Pin;
 80086c6:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086c8:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80086ca:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 80086cc:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086ce:	930b      	str	r3, [sp, #44]	; 0x2c
 80086d0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80086d2:	f7f8 fa3d 	bl	8000b50 <HAL_GPIO_Init>
}
 80086d6:	e740      	b.n	800855a <MX_TIM12_Init+0xb2>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086d8:	4b1d      	ldr	r3, [pc, #116]	; (8008750 <MX_TIM12_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80086da:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM61_Pin;
 80086dc:	f44f 7680 	mov.w	r6, #256	; 0x100
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 80086e0:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086e2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 80086e4:	a90c      	add	r1, sp, #48	; 0x30
 80086e6:	481d      	ldr	r0, [pc, #116]	; (800875c <MX_TIM12_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086e8:	432a      	orrs	r2, r5
 80086ea:	631a      	str	r2, [r3, #48]	; 0x30
 80086ec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM61_Pin;
 80086ee:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086f0:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80086f2:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 80086f4:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80086f6:	9309      	str	r3, [sp, #36]	; 0x24
 80086f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    HAL_GPIO_Init(PWM61_GPIO_Port, &GPIO_InitStruct);
 80086fa:	f7f8 fa29 	bl	8000b50 <HAL_GPIO_Init>
 80086fe:	e72c      	b.n	800855a <MX_TIM12_Init+0xb2>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008700:	4b13      	ldr	r3, [pc, #76]	; (8008750 <MX_TIM12_Init+0x2a8>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008702:	2502      	movs	r5, #2
    GPIO_InitStruct.Pin = PWM62_Pin;
 8008704:	f44f 7600 	mov.w	r6, #512	; 0x200
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 8008708:	2403      	movs	r4, #3
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800870a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 800870c:	a90c      	add	r1, sp, #48	; 0x30
 800870e:	4813      	ldr	r0, [pc, #76]	; (800875c <MX_TIM12_Init+0x2b4>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008710:	432a      	orrs	r2, r5
 8008712:	631a      	str	r2, [r3, #48]	; 0x30
 8008714:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Pin = PWM62_Pin;
 8008716:	960c      	str	r6, [sp, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008718:	402b      	ands	r3, r5
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800871a:	950d      	str	r5, [sp, #52]	; 0x34
    GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 800871c:	9410      	str	r4, [sp, #64]	; 0x40
    __HAL_RCC_GPIOB_CLK_ENABLE();
 800871e:	930a      	str	r3, [sp, #40]	; 0x28
 8008720:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    HAL_GPIO_Init(PWM62_GPIO_Port, &GPIO_InitStruct);
 8008722:	f7f8 fa15 	bl	8000b50 <HAL_GPIO_Init>
 8008726:	e718      	b.n	800855a <MX_TIM12_Init+0xb2>
 8008728:	40001800 	.word	0x40001800
 800872c:	2000123c 	.word	0x2000123c
 8008730:	40010000 	.word	0x40010000
 8008734:	40000400 	.word	0x40000400
 8008738:	40000800 	.word	0x40000800
 800873c:	40000c00 	.word	0x40000c00
 8008740:	40010400 	.word	0x40010400
 8008744:	40014000 	.word	0x40014000
 8008748:	40014400 	.word	0x40014400
 800874c:	40014800 	.word	0x40014800
 8008750:	40023800 	.word	0x40023800
 8008754:	40020000 	.word	0x40020000
 8008758:	40021000 	.word	0x40021000
 800875c:	40020400 	.word	0x40020400
 8008760:	40020c00 	.word	0x40020c00
 8008764:	40020800 	.word	0x40020800

08008768 <HAL_TIM_PWM_MspInit>:
  if(tim_pwmHandle->Instance==TIM1)
 8008768:	6803      	ldr	r3, [r0, #0]
{
 800876a:	b088      	sub	sp, #32
  if(tim_pwmHandle->Instance==TIM1)
 800876c:	4a3b      	ldr	r2, [pc, #236]	; (800885c <HAL_TIM_PWM_MspInit+0xf4>)
 800876e:	4293      	cmp	r3, r2
 8008770:	d01e      	beq.n	80087b0 <HAL_TIM_PWM_MspInit+0x48>
  if(tim_pwmHandle->Instance==TIM2)
 8008772:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8008776:	d00e      	beq.n	8008796 <HAL_TIM_PWM_MspInit+0x2e>
  else if(tim_pwmHandle->Instance==TIM3)
 8008778:	4a39      	ldr	r2, [pc, #228]	; (8008860 <HAL_TIM_PWM_MspInit+0xf8>)
 800877a:	4293      	cmp	r3, r2
 800877c:	d132      	bne.n	80087e4 <HAL_TIM_PWM_MspInit+0x7c>
    __HAL_RCC_TIM3_CLK_ENABLE();
 800877e:	4b39      	ldr	r3, [pc, #228]	; (8008864 <HAL_TIM_PWM_MspInit+0xfc>)
 8008780:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8008782:	f042 0202 	orr.w	r2, r2, #2
 8008786:	641a      	str	r2, [r3, #64]	; 0x40
 8008788:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800878a:	f003 0302 	and.w	r3, r3, #2
 800878e:	9302      	str	r3, [sp, #8]
 8008790:	9b02      	ldr	r3, [sp, #8]
}
 8008792:	b008      	add	sp, #32
 8008794:	4770      	bx	lr
    __HAL_RCC_TIM2_CLK_ENABLE();
 8008796:	f503 330e 	add.w	r3, r3, #145408	; 0x23800
 800879a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800879c:	f042 0201 	orr.w	r2, r2, #1
 80087a0:	641a      	str	r2, [r3, #64]	; 0x40
 80087a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80087a4:	f003 0301 	and.w	r3, r3, #1
 80087a8:	9301      	str	r3, [sp, #4]
 80087aa:	9b01      	ldr	r3, [sp, #4]
}
 80087ac:	b008      	add	sp, #32
 80087ae:	4770      	bx	lr
    __HAL_RCC_TIM1_CLK_ENABLE();
 80087b0:	f502 329c 	add.w	r2, r2, #79872	; 0x13800
 80087b4:	6c51      	ldr	r1, [r2, #68]	; 0x44
 80087b6:	f041 0101 	orr.w	r1, r1, #1
 80087ba:	6451      	str	r1, [r2, #68]	; 0x44
 80087bc:	6c52      	ldr	r2, [r2, #68]	; 0x44
 80087be:	f002 0201 	and.w	r2, r2, #1
 80087c2:	9200      	str	r2, [sp, #0]
 80087c4:	9a00      	ldr	r2, [sp, #0]
  else if(tim_pwmHandle->Instance==TIM9)
 80087c6:	4a28      	ldr	r2, [pc, #160]	; (8008868 <HAL_TIM_PWM_MspInit+0x100>)
 80087c8:	4293      	cmp	r3, r2
 80087ca:	d129      	bne.n	8008820 <HAL_TIM_PWM_MspInit+0xb8>
    __HAL_RCC_TIM9_CLK_ENABLE();
 80087cc:	4b25      	ldr	r3, [pc, #148]	; (8008864 <HAL_TIM_PWM_MspInit+0xfc>)
 80087ce:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80087d0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80087d4:	645a      	str	r2, [r3, #68]	; 0x44
 80087d6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80087d8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80087dc:	9306      	str	r3, [sp, #24]
 80087de:	9b06      	ldr	r3, [sp, #24]
}
 80087e0:	b008      	add	sp, #32
 80087e2:	4770      	bx	lr
  else if(tim_pwmHandle->Instance==TIM4)
 80087e4:	4a21      	ldr	r2, [pc, #132]	; (800886c <HAL_TIM_PWM_MspInit+0x104>)
 80087e6:	4293      	cmp	r3, r2
 80087e8:	d10b      	bne.n	8008802 <HAL_TIM_PWM_MspInit+0x9a>
    __HAL_RCC_TIM4_CLK_ENABLE();
 80087ea:	4b1e      	ldr	r3, [pc, #120]	; (8008864 <HAL_TIM_PWM_MspInit+0xfc>)
 80087ec:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80087ee:	f042 0204 	orr.w	r2, r2, #4
 80087f2:	641a      	str	r2, [r3, #64]	; 0x40
 80087f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80087f6:	f003 0304 	and.w	r3, r3, #4
 80087fa:	9303      	str	r3, [sp, #12]
 80087fc:	9b03      	ldr	r3, [sp, #12]
}
 80087fe:	b008      	add	sp, #32
 8008800:	4770      	bx	lr
  if(tim_pwmHandle->Instance==TIM5)
 8008802:	4a1b      	ldr	r2, [pc, #108]	; (8008870 <HAL_TIM_PWM_MspInit+0x108>)
 8008804:	4293      	cmp	r3, r2
 8008806:	d11a      	bne.n	800883e <HAL_TIM_PWM_MspInit+0xd6>
     __HAL_RCC_TIM5_CLK_ENABLE();
 8008808:	4b16      	ldr	r3, [pc, #88]	; (8008864 <HAL_TIM_PWM_MspInit+0xfc>)
 800880a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800880c:	f042 0208 	orr.w	r2, r2, #8
 8008810:	641a      	str	r2, [r3, #64]	; 0x40
 8008812:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008814:	f003 0308 	and.w	r3, r3, #8
 8008818:	9304      	str	r3, [sp, #16]
 800881a:	9b04      	ldr	r3, [sp, #16]
}
 800881c:	b008      	add	sp, #32
 800881e:	4770      	bx	lr
  else if(tim_pwmHandle->Instance==TIM12)
 8008820:	4a14      	ldr	r2, [pc, #80]	; (8008874 <HAL_TIM_PWM_MspInit+0x10c>)
 8008822:	4293      	cmp	r3, r2
 8008824:	d1b5      	bne.n	8008792 <HAL_TIM_PWM_MspInit+0x2a>
    __HAL_RCC_TIM12_CLK_ENABLE();
 8008826:	4b0f      	ldr	r3, [pc, #60]	; (8008864 <HAL_TIM_PWM_MspInit+0xfc>)
 8008828:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800882a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800882e:	641a      	str	r2, [r3, #64]	; 0x40
 8008830:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008832:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008836:	9307      	str	r3, [sp, #28]
 8008838:	9b07      	ldr	r3, [sp, #28]
}
 800883a:	b008      	add	sp, #32
 800883c:	4770      	bx	lr
  else if(tim_pwmHandle->Instance==TIM8)
 800883e:	4a0e      	ldr	r2, [pc, #56]	; (8008878 <HAL_TIM_PWM_MspInit+0x110>)
 8008840:	4293      	cmp	r3, r2
 8008842:	d1c0      	bne.n	80087c6 <HAL_TIM_PWM_MspInit+0x5e>
    __HAL_RCC_TIM8_CLK_ENABLE();
 8008844:	4b07      	ldr	r3, [pc, #28]	; (8008864 <HAL_TIM_PWM_MspInit+0xfc>)
 8008846:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008848:	f042 0202 	orr.w	r2, r2, #2
 800884c:	645a      	str	r2, [r3, #68]	; 0x44
 800884e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008850:	f003 0302 	and.w	r3, r3, #2
 8008854:	9305      	str	r3, [sp, #20]
 8008856:	9b05      	ldr	r3, [sp, #20]
}
 8008858:	b008      	add	sp, #32
 800885a:	4770      	bx	lr
 800885c:	40010000 	.word	0x40010000
 8008860:	40000400 	.word	0x40000400
 8008864:	40023800 	.word	0x40023800
 8008868:	40014000 	.word	0x40014000
 800886c:	40000800 	.word	0x40000800
 8008870:	40000c00 	.word	0x40000c00
 8008874:	40001800 	.word	0x40001800
 8008878:	40010400 	.word	0x40010400

0800887c <HAL_TIM_Base_MspInit>:
  if(tim_baseHandle->Instance==TIM6)
 800887c:	6803      	ldr	r3, [r0, #0]
 800887e:	4a1d      	ldr	r2, [pc, #116]	; (80088f4 <HAL_TIM_Base_MspInit+0x78>)
 8008880:	4293      	cmp	r3, r2
{
 8008882:	b510      	push	{r4, lr}
 8008884:	b084      	sub	sp, #16
  if(tim_baseHandle->Instance==TIM6)
 8008886:	d01f      	beq.n	80088c8 <HAL_TIM_Base_MspInit+0x4c>
  else if(tim_baseHandle->Instance==TIM10)
 8008888:	4a1b      	ldr	r2, [pc, #108]	; (80088f8 <HAL_TIM_Base_MspInit+0x7c>)
 800888a:	4293      	cmp	r3, r2
 800888c:	d010      	beq.n	80088b0 <HAL_TIM_Base_MspInit+0x34>
  else if(tim_baseHandle->Instance==TIM11)
 800888e:	4a1b      	ldr	r2, [pc, #108]	; (80088fc <HAL_TIM_Base_MspInit+0x80>)
 8008890:	4293      	cmp	r3, r2
 8008892:	d001      	beq.n	8008898 <HAL_TIM_Base_MspInit+0x1c>
}
 8008894:	b004      	add	sp, #16
 8008896:	bd10      	pop	{r4, pc}
    __HAL_RCC_TIM11_CLK_ENABLE();
 8008898:	4b19      	ldr	r3, [pc, #100]	; (8008900 <HAL_TIM_Base_MspInit+0x84>)
 800889a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800889c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80088a0:	645a      	str	r2, [r3, #68]	; 0x44
 80088a2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80088a4:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80088a8:	9303      	str	r3, [sp, #12]
 80088aa:	9b03      	ldr	r3, [sp, #12]
}
 80088ac:	b004      	add	sp, #16
 80088ae:	bd10      	pop	{r4, pc}
    __HAL_RCC_TIM10_CLK_ENABLE();
 80088b0:	4b13      	ldr	r3, [pc, #76]	; (8008900 <HAL_TIM_Base_MspInit+0x84>)
 80088b2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80088b4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 80088b8:	645a      	str	r2, [r3, #68]	; 0x44
 80088ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80088bc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80088c0:	9302      	str	r3, [sp, #8]
 80088c2:	9b02      	ldr	r3, [sp, #8]
}
 80088c4:	b004      	add	sp, #16
 80088c6:	bd10      	pop	{r4, pc}
    __HAL_RCC_TIM6_CLK_ENABLE();
 80088c8:	4b0d      	ldr	r3, [pc, #52]	; (8008900 <HAL_TIM_Base_MspInit+0x84>)
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 1, 0);
 80088ca:	2200      	movs	r2, #0
 80088cc:	2101      	movs	r1, #1
 80088ce:	2036      	movs	r0, #54	; 0x36
    __HAL_RCC_TIM6_CLK_ENABLE();
 80088d0:	6c1c      	ldr	r4, [r3, #64]	; 0x40
 80088d2:	f044 0410 	orr.w	r4, r4, #16
 80088d6:	641c      	str	r4, [r3, #64]	; 0x40
 80088d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80088da:	f003 0310 	and.w	r3, r3, #16
 80088de:	9301      	str	r3, [sp, #4]
 80088e0:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM6_DAC_IRQn, 1, 0);
 80088e2:	f7f8 f8c5 	bl	8000a70 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 80088e6:	2036      	movs	r0, #54	; 0x36
}
 80088e8:	b004      	add	sp, #16
 80088ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 80088ee:	f7f8 b8f5 	b.w	8000adc <HAL_NVIC_EnableIRQ>
 80088f2:	bf00      	nop
 80088f4:	40001000 	.word	0x40001000
 80088f8:	40014400 	.word	0x40014400
 80088fc:	40014800 	.word	0x40014800
 8008900:	40023800 	.word	0x40023800

08008904 <MX_UART8_Init>:

UART_HandleTypeDef huart8;

/* UART4 init function */
void MX_UART8_Init(void)
{
 8008904:	b538      	push	{r3, r4, r5, lr}

  huart8.Instance = UART8;
 8008906:	4b0c      	ldr	r3, [pc, #48]	; (8008938 <MX_UART8_Init+0x34>)
  huart8.Init.BaudRate = 31250;
  huart8.Init.WordLength = UART_WORDLENGTH_8B;
 8008908:	2200      	movs	r2, #0
  huart8.Init.BaudRate = 31250;
 800890a:	f647 2412 	movw	r4, #31250	; 0x7a12
  huart8.Instance = UART8;
 800890e:	4d0b      	ldr	r5, [pc, #44]	; (800893c <MX_UART8_Init+0x38>)
  huart8.Init.StopBits = UART_STOPBITS_1;
  huart8.Init.Parity = UART_PARITY_NONE;
  huart8.Init.Mode = UART_MODE_RX;
 8008910:	2104      	movs	r1, #4
  huart8.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart8.Init.OverSampling = UART_OVERSAMPLING_16;
  huart8.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart8.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart8) != HAL_OK)
 8008912:	4618      	mov	r0, r3
  huart8.Init.Parity = UART_PARITY_NONE;
 8008914:	611a      	str	r2, [r3, #16]
  huart8.Init.Mode = UART_MODE_RX;
 8008916:	6159      	str	r1, [r3, #20]
  huart8.Init.BaudRate = 31250;
 8008918:	e9c3 5400 	strd	r5, r4, [r3]
  huart8.Init.StopBits = UART_STOPBITS_1;
 800891c:	e9c3 2202 	strd	r2, r2, [r3, #8]
  huart8.Init.OverSampling = UART_OVERSAMPLING_16;
 8008920:	e9c3 2206 	strd	r2, r2, [r3, #24]
  huart8.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8008924:	e9c3 2208 	strd	r2, r2, [r3, #32]
  if (HAL_UART_Init(&huart8) != HAL_OK)
 8008928:	f7fa fe1e 	bl	8003568 <HAL_UART_Init>
 800892c:	b900      	cbnz	r0, 8008930 <MX_UART8_Init+0x2c>
  {
    Error_Handler();
  }

}
 800892e:	bd38      	pop	{r3, r4, r5, pc}
 8008930:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 8008934:	f7fe b904 	b.w	8006b40 <Error_Handler>
 8008938:	2000127c 	.word	0x2000127c
 800893c:	40007c00 	.word	0x40007c00

08008940 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(uartHandle->Instance==UART8)
 8008940:	6802      	ldr	r2, [r0, #0]
 8008942:	4b1c      	ldr	r3, [pc, #112]	; (80089b4 <HAL_UART_MspInit+0x74>)
{
 8008944:	b570      	push	{r4, r5, r6, lr}
  if(uartHandle->Instance==UART8)
 8008946:	429a      	cmp	r2, r3
{
 8008948:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800894a:	f04f 0400 	mov.w	r4, #0
 800894e:	e9cd 4403 	strd	r4, r4, [sp, #12]
 8008952:	e9cd 4405 	strd	r4, r4, [sp, #20]
 8008956:	9407      	str	r4, [sp, #28]
  if(uartHandle->Instance==UART8)
 8008958:	d001      	beq.n	800895e <HAL_UART_MspInit+0x1e>
    HAL_NVIC_EnableIRQ(UART8_IRQn);
  /* USER CODE BEGIN UART4_MspInit 1 */

  /* USER CODE END UART4_MspInit 1 */
  }
}
 800895a:	b008      	add	sp, #32
 800895c:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_UART8_CLK_ENABLE();
 800895e:	f503 33de 	add.w	r3, r3, #113664	; 0x1bc00
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008962:	2002      	movs	r0, #2
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 8008964:	2601      	movs	r6, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8008966:	2503      	movs	r5, #3
    __HAL_RCC_UART8_CLK_ENABLE();
 8008968:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800896a:	a903      	add	r1, sp, #12
    __HAL_RCC_UART8_CLK_ENABLE();
 800896c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8008970:	641a      	str	r2, [r3, #64]	; 0x40
 8008972:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8008974:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 8008978:	9201      	str	r2, [sp, #4]
 800897a:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800897c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800897e:	f042 0210 	orr.w	r2, r2, #16
 8008982:	631a      	str	r2, [r3, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF8_UART8;
 8008984:	2208      	movs	r2, #8
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008986:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008988:	9004      	str	r0, [sp, #16]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800898a:	f003 0310 	and.w	r3, r3, #16
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800898e:	480a      	ldr	r0, [pc, #40]	; (80089b8 <HAL_UART_MspInit+0x78>)
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 8008990:	9603      	str	r6, [sp, #12]
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8008992:	9302      	str	r3, [sp, #8]
 8008994:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF8_UART8;
 8008996:	e9cd 5206 	strd	r5, r2, [sp, #24]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800899a:	f7f8 f8d9 	bl	8000b50 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(UART8_IRQn, 0, 0);
 800899e:	4622      	mov	r2, r4
 80089a0:	4621      	mov	r1, r4
 80089a2:	2053      	movs	r0, #83	; 0x53
 80089a4:	f7f8 f864 	bl	8000a70 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(UART8_IRQn);
 80089a8:	2053      	movs	r0, #83	; 0x53
 80089aa:	f7f8 f897 	bl	8000adc <HAL_NVIC_EnableIRQ>
}
 80089ae:	b008      	add	sp, #32
 80089b0:	bd70      	pop	{r4, r5, r6, pc}
 80089b2:	bf00      	nop
 80089b4:	40007c00 	.word	0x40007c00
 80089b8:	40021000 	.word	0x40021000

080089bc <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 80089bc:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PreTreatment */
  
  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 80089be:	2200      	movs	r2, #0
 80089c0:	4910      	ldr	r1, [pc, #64]	; (8008a04 <MX_USB_DEVICE_Init+0x48>)
 80089c2:	4811      	ldr	r0, [pc, #68]	; (8008a08 <MX_USB_DEVICE_Init+0x4c>)
 80089c4:	f7fb fe36 	bl	8004634 <USBD_Init>
 80089c8:	b9c0      	cbnz	r0, 80089fc <MX_USB_DEVICE_Init+0x40>
  {
    Error_Handler();
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_MIDI) != USBD_OK)
 80089ca:	4910      	ldr	r1, [pc, #64]	; (8008a0c <MX_USB_DEVICE_Init+0x50>)
 80089cc:	480e      	ldr	r0, [pc, #56]	; (8008a08 <MX_USB_DEVICE_Init+0x4c>)
 80089ce:	f7fb fe47 	bl	8004660 <USBD_RegisterClass>
 80089d2:	b980      	cbnz	r0, 80089f6 <MX_USB_DEVICE_Init+0x3a>
  {
    Error_Handler();
  }
  if (USBD_MIDI_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 80089d4:	490e      	ldr	r1, [pc, #56]	; (8008a10 <MX_USB_DEVICE_Init+0x54>)
 80089d6:	480c      	ldr	r0, [pc, #48]	; (8008a08 <MX_USB_DEVICE_Init+0x4c>)
 80089d8:	f7fb fde6 	bl	80045a8 <USBD_MIDI_RegisterInterface>
 80089dc:	b940      	cbnz	r0, 80089f0 <MX_USB_DEVICE_Init+0x34>
  {
    Error_Handler();
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 80089de:	480a      	ldr	r0, [pc, #40]	; (8008a08 <MX_USB_DEVICE_Init+0x4c>)
 80089e0:	f7fb fe46 	bl	8004670 <USBD_Start>
 80089e4:	b900      	cbnz	r0, 80089e8 <MX_USB_DEVICE_Init+0x2c>
    Error_Handler();
  }
  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 80089e6:	bd08      	pop	{r3, pc}
 80089e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 80089ec:	f7fe b8a8 	b.w	8006b40 <Error_Handler>
    Error_Handler();
 80089f0:	f7fe f8a6 	bl	8006b40 <Error_Handler>
 80089f4:	e7f3      	b.n	80089de <MX_USB_DEVICE_Init+0x22>
    Error_Handler();
 80089f6:	f7fe f8a3 	bl	8006b40 <Error_Handler>
 80089fa:	e7eb      	b.n	80089d4 <MX_USB_DEVICE_Init+0x18>
    Error_Handler();
 80089fc:	f7fe f8a0 	bl	8006b40 <Error_Handler>
 8008a00:	e7e3      	b.n	80089ca <MX_USB_DEVICE_Init+0xe>
 8008a02:	bf00      	nop
 8008a04:	200001c8 	.word	0x200001c8
 8008a08:	200012fc 	.word	0x200012fc
 8008a0c:	2000014c 	.word	0x2000014c
 8008a10:	200001e8 	.word	0x200001e8

08008a14 <HAL_PCD_MspInit>:
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 8008a14:	6803      	ldr	r3, [r0, #0]
 8008a16:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8008a1a:	d000      	beq.n	8008a1e <HAL_PCD_MspInit+0xa>
 8008a1c:	4770      	bx	lr
{
 8008a1e:	b570      	push	{r4, r5, r6, lr}
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008a20:	4c1a      	ldr	r4, [pc, #104]	; (8008a8c <HAL_PCD_MspInit+0x78>)
{
 8008a22:	b088      	sub	sp, #32
    /**USB_OTG_FS GPIO Configuration    
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8008a24:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008a28:	2102      	movs	r1, #2
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008a2a:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008a2c:	2500      	movs	r5, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8008a2e:	220a      	movs	r2, #10
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8008a30:	2603      	movs	r6, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008a32:	f043 0301 	orr.w	r3, r3, #1
 8008a36:	6323      	str	r3, [r4, #48]	; 0x30
 8008a38:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8008a3a:	9003      	str	r0, [sp, #12]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008a3c:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008a40:	9104      	str	r1, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008a42:	4813      	ldr	r0, [pc, #76]	; (8008a90 <HAL_PCD_MspInit+0x7c>)
 8008a44:	a903      	add	r1, sp, #12
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008a46:	9300      	str	r3, [sp, #0]
 8008a48:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008a4a:	9505      	str	r5, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8008a4c:	e9cd 6206 	strd	r6, r2, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008a50:	f7f8 f87e 	bl	8000b50 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8008a54:	6b63      	ldr	r3, [r4, #52]	; 0x34

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8008a56:	462a      	mov	r2, r5
 8008a58:	4629      	mov	r1, r5
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8008a5a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8008a5e:	2043      	movs	r0, #67	; 0x43
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8008a60:	6363      	str	r3, [r4, #52]	; 0x34
 8008a62:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8008a64:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008a68:	9301      	str	r3, [sp, #4]
 8008a6a:	9b01      	ldr	r3, [sp, #4]
 8008a6c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008a6e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8008a72:	6463      	str	r3, [r4, #68]	; 0x44
 8008a74:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008a76:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8008a7a:	9302      	str	r3, [sp, #8]
 8008a7c:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 8008a7e:	f7f7 fff7 	bl	8000a70 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8008a82:	2043      	movs	r0, #67	; 0x43
 8008a84:	f7f8 f82a 	bl	8000adc <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 8008a88:	b008      	add	sp, #32
 8008a8a:	bd70      	pop	{r4, r5, r6, pc}
 8008a8c:	40023800 	.word	0x40023800
 8008a90:	40020000 	.word	0x40020000

08008a94 <HAL_PCD_SetupStageCallback>:
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8008a94:	f500 7171 	add.w	r1, r0, #964	; 0x3c4
 8008a98:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008a9c:	f7fb be00 	b.w	80046a0 <USBD_LL_SetupStage>

08008aa0 <HAL_PCD_DataOutStageCallback>:
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 8008aa0:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8008aa4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8008aa8:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008aac:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
 8008ab0:	f7fb be26 	b.w	8004700 <USBD_LL_DataOutStage>

08008ab4 <HAL_PCD_DataInStageCallback>:
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 8008ab4:	ebc1 03c1 	rsb	r3, r1, r1, lsl #3
 8008ab8:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8008abc:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008ac0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8008ac2:	f7fb be5d 	b.w	8004780 <USBD_LL_DataInStage>
 8008ac6:	bf00      	nop

08008ac8 <HAL_PCD_SOFCallback>:
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 8008ac8:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008acc:	f7fb bef0 	b.w	80048b0 <USBD_LL_SOF>

08008ad0 <HAL_PCD_ResetCallback>:
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{ 
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8008ad0:	68c1      	ldr	r1, [r0, #12]
{ 
 8008ad2:	b510      	push	{r4, lr}
 8008ad4:	4604      	mov	r4, r0
  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8008ad6:	b121      	cbz	r1, 8008ae2 <HAL_PCD_ResetCallback+0x12>
  {
    speed = USBD_SPEED_HIGH;
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 8008ad8:	2902      	cmp	r1, #2
 8008ada:	d00c      	beq.n	8008af6 <HAL_PCD_ResetCallback+0x26>
  {
    speed = USBD_SPEED_FULL;
  }
  else
  {
    Error_Handler();
 8008adc:	f7fe f830 	bl	8006b40 <Error_Handler>
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 8008ae0:	2101      	movs	r1, #1
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8008ae2:	f8d4 0400 	ldr.w	r0, [r4, #1024]	; 0x400
 8008ae6:	f7fb fecd 	bl	8004884 <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8008aea:	f8d4 0400 	ldr.w	r0, [r4, #1024]	; 0x400
}
 8008aee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8008af2:	f7fb be9f 	b.w	8004834 <USBD_LL_Reset>
    speed = USBD_SPEED_FULL;
 8008af6:	2101      	movs	r1, #1
 8008af8:	e7f3      	b.n	8008ae2 <HAL_PCD_ResetCallback+0x12>
 8008afa:	bf00      	nop

08008afc <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8008afc:	b510      	push	{r4, lr}
 8008afe:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8008b00:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008b04:	f7fb fec2 	bl	800488c <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8008b08:	6822      	ldr	r2, [r4, #0]
 8008b0a:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 8008b0e:	f043 0301 	orr.w	r3, r3, #1
 8008b12:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8008b16:	6a23      	ldr	r3, [r4, #32]
 8008b18:	b123      	cbz	r3, 8008b24 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8008b1a:	4a03      	ldr	r2, [pc, #12]	; (8008b28 <HAL_PCD_SuspendCallback+0x2c>)
 8008b1c:	6913      	ldr	r3, [r2, #16]
 8008b1e:	f043 0306 	orr.w	r3, r3, #6
 8008b22:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8008b24:	bd10      	pop	{r4, pc}
 8008b26:	bf00      	nop
 8008b28:	e000ed00 	.word	0xe000ed00

08008b2c <HAL_PCD_ResumeCallback>:
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8008b2c:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008b30:	f7fb beb6 	b.w	80048a0 <USBD_LL_Resume>

08008b34 <HAL_PCD_ISOOUTIncompleteCallback>:
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8008b34:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008b38:	f7fb beca 	b.w	80048d0 <USBD_LL_IsoOUTIncomplete>

08008b3c <HAL_PCD_ISOINIncompleteCallback>:
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8008b3c:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008b40:	f7fb bec4 	b.w	80048cc <USBD_LL_IsoINIncomplete>

08008b44 <HAL_PCD_ConnectCallback>:
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8008b44:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008b48:	f7fb bec4 	b.w	80048d4 <USBD_LL_DevConnected>

08008b4c <HAL_PCD_DisconnectCallback>:
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8008b4c:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
 8008b50:	f7fb bec2 	b.w	80048d8 <USBD_LL_DevDisconnected>

08008b54 <USBD_LL_Init>:
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 8008b54:	7802      	ldrb	r2, [r0, #0]
 8008b56:	b10a      	cbz	r2, 8008b5c <USBD_LL_Init+0x8>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
  }
  return USBD_OK;
}
 8008b58:	2000      	movs	r0, #0
 8008b5a:	4770      	bx	lr
{
 8008b5c:	b538      	push	{r3, r4, r5, lr}
  hpcd_USB_OTG_FS.pData = pdev;
 8008b5e:	4b15      	ldr	r3, [pc, #84]	; (8008bb4 <USBD_LL_Init+0x60>)
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8008b60:	2102      	movs	r1, #2
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8008b62:	f04f 45a0 	mov.w	r5, #1342177280	; 0x50000000
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 8008b66:	2406      	movs	r4, #6
  hpcd_USB_OTG_FS.pData = pdev;
 8008b68:	f8c3 0400 	str.w	r0, [r3, #1024]	; 0x400
  pdev->pData = &hpcd_USB_OTG_FS;
 8008b6c:	f8c0 3298 	str.w	r3, [r0, #664]	; 0x298
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8008b70:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8008b72:	611a      	str	r2, [r3, #16]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8008b74:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8008b76:	60d9      	str	r1, [r3, #12]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8008b78:	6199      	str	r1, [r3, #24]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8008b7a:	e9c3 2207 	strd	r2, r2, [r3, #28]
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8008b7e:	e9c3 220b 	strd	r2, r2, [r3, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.dev_endpoints = 6;
 8008b82:	e9c3 5400 	strd	r5, r4, [r3]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8008b86:	f7f8 fb35 	bl	80011f4 <HAL_PCD_Init>
 8008b8a:	b978      	cbnz	r0, 8008bac <USBD_LL_Init+0x58>
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8008b8c:	2180      	movs	r1, #128	; 0x80
 8008b8e:	4809      	ldr	r0, [pc, #36]	; (8008bb4 <USBD_LL_Init+0x60>)
 8008b90:	f7f9 f8dc 	bl	8001d4c <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8008b94:	2240      	movs	r2, #64	; 0x40
 8008b96:	2100      	movs	r1, #0
 8008b98:	4806      	ldr	r0, [pc, #24]	; (8008bb4 <USBD_LL_Init+0x60>)
 8008b9a:	f7f9 f8b3 	bl	8001d04 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8008b9e:	2280      	movs	r2, #128	; 0x80
 8008ba0:	2101      	movs	r1, #1
 8008ba2:	4804      	ldr	r0, [pc, #16]	; (8008bb4 <USBD_LL_Init+0x60>)
 8008ba4:	f7f9 f8ae 	bl	8001d04 <HAL_PCDEx_SetTxFiFo>
}
 8008ba8:	2000      	movs	r0, #0
 8008baa:	bd38      	pop	{r3, r4, r5, pc}
    Error_Handler( );
 8008bac:	f7fd ffc8 	bl	8006b40 <Error_Handler>
 8008bb0:	e7ec      	b.n	8008b8c <USBD_LL_Init+0x38>
 8008bb2:	bf00      	nop
 8008bb4:	20001598 	.word	0x20001598

08008bb8 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8008bb8:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
 
  hal_status = HAL_PCD_Start(pdev->pData);
 8008bba:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8008bbe:	f7f8 fbab 	bl	8001318 <HAL_PCD_Start>
 8008bc2:	2803      	cmp	r0, #3
 8008bc4:	d802      	bhi.n	8008bcc <USBD_LL_Start+0x14>
 8008bc6:	4b02      	ldr	r3, [pc, #8]	; (8008bd0 <USBD_LL_Start+0x18>)
 8008bc8:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status =  USBD_Get_USB_Status(hal_status);     
  
  return usb_status;
}
 8008bca:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_Start(pdev->pData);
 8008bcc:	2002      	movs	r0, #2
}
 8008bce:	bd08      	pop	{r3, pc}
 8008bd0:	0800926c 	.word	0x0800926c

08008bd4 <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8008bd4:	b510      	push	{r4, lr}
 8008bd6:	461c      	mov	r4, r3
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8008bd8:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8008bdc:	4613      	mov	r3, r2
 8008bde:	4622      	mov	r2, r4
 8008be0:	f7f8 ff4c 	bl	8001a7c <HAL_PCD_EP_Open>
 8008be4:	2803      	cmp	r0, #3
 8008be6:	d802      	bhi.n	8008bee <USBD_LL_OpenEP+0x1a>
 8008be8:	4b02      	ldr	r3, [pc, #8]	; (8008bf4 <USBD_LL_OpenEP+0x20>)
 8008bea:	5c18      	ldrb	r0, [r3, r0]

  usb_status =  USBD_Get_USB_Status(hal_status);
  
  return usb_status;
}
 8008bec:	bd10      	pop	{r4, pc}
  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8008bee:	2002      	movs	r0, #2
}
 8008bf0:	bd10      	pop	{r4, pc}
 8008bf2:	bf00      	nop
 8008bf4:	0800926c 	.word	0x0800926c

08008bf8 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8008bf8:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8008bfa:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8008bfe:	f7f8 ff77 	bl	8001af0 <HAL_PCD_EP_Close>
 8008c02:	2803      	cmp	r0, #3
 8008c04:	d802      	bhi.n	8008c0c <USBD_LL_CloseEP+0x14>
 8008c06:	4b02      	ldr	r3, [pc, #8]	; (8008c10 <USBD_LL_CloseEP+0x18>)
 8008c08:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status =  USBD_Get_USB_Status(hal_status);    
 
  return usb_status;  
}
 8008c0a:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8008c0c:	2002      	movs	r0, #2
}
 8008c0e:	bd08      	pop	{r3, pc}
 8008c10:	0800926c 	.word	0x0800926c

08008c14 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8008c14:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8008c16:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8008c1a:	f7f8 fff3 	bl	8001c04 <HAL_PCD_EP_SetStall>
 8008c1e:	2803      	cmp	r0, #3
 8008c20:	d802      	bhi.n	8008c28 <USBD_LL_StallEP+0x14>
 8008c22:	4b02      	ldr	r3, [pc, #8]	; (8008c2c <USBD_LL_StallEP+0x18>)
 8008c24:	5c18      	ldrb	r0, [r3, r0]

  usb_status =  USBD_Get_USB_Status(hal_status);
  
  return usb_status;  
}
 8008c26:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8008c28:	2002      	movs	r0, #2
}
 8008c2a:	bd08      	pop	{r3, pc}
 8008c2c:	0800926c 	.word	0x0800926c

08008c30 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8008c30:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8008c32:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8008c36:	f7f9 f829 	bl	8001c8c <HAL_PCD_EP_ClrStall>
 8008c3a:	2803      	cmp	r0, #3
 8008c3c:	d802      	bhi.n	8008c44 <USBD_LL_ClearStallEP+0x14>
 8008c3e:	4b02      	ldr	r3, [pc, #8]	; (8008c48 <USBD_LL_ClearStallEP+0x18>)
 8008c40:	5c18      	ldrb	r0, [r3, r0]
    
  usb_status =  USBD_Get_USB_Status(hal_status);  
  
  return usb_status; 
}
 8008c42:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8008c44:	2002      	movs	r0, #2
}
 8008c46:	bd08      	pop	{r3, pc}
 8008c48:	0800926c 	.word	0x0800926c

08008c4c <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
  
  if((ep_addr & 0x80) == 0x80)
 8008c4c:	060a      	lsls	r2, r1, #24
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8008c4e:	f8d0 3298 	ldr.w	r3, [r0, #664]	; 0x298
  if((ep_addr & 0x80) == 0x80)
 8008c52:	d406      	bmi.n	8008c62 <USBD_LL_IsStallEP+0x16>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8008c54:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8008c58:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8008c5c:	f891 01fe 	ldrb.w	r0, [r1, #510]	; 0x1fe
  }
}
 8008c60:	4770      	bx	lr
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 8008c62:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8008c66:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8008c6a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8008c6e:	f891 003e 	ldrb.w	r0, [r1, #62]	; 0x3e
 8008c72:	4770      	bx	lr

08008c74 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8008c74:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8008c76:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8008c7a:	f7f8 feeb 	bl	8001a54 <HAL_PCD_SetAddress>
 8008c7e:	2803      	cmp	r0, #3
 8008c80:	d802      	bhi.n	8008c88 <USBD_LL_SetUSBAddress+0x14>
 8008c82:	4b02      	ldr	r3, [pc, #8]	; (8008c8c <USBD_LL_SetUSBAddress+0x18>)
 8008c84:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status =  USBD_Get_USB_Status(hal_status);
  
  return usb_status;  
}
 8008c86:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8008c88:	2002      	movs	r0, #2
}
 8008c8a:	bd08      	pop	{r3, pc}
 8008c8c:	0800926c 	.word	0x0800926c

08008c90 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size    
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8008c90:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8008c92:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8008c96:	f7f8 ff91 	bl	8001bbc <HAL_PCD_EP_Transmit>
 8008c9a:	2803      	cmp	r0, #3
 8008c9c:	d802      	bhi.n	8008ca4 <USBD_LL_Transmit+0x14>
 8008c9e:	4b02      	ldr	r3, [pc, #8]	; (8008ca8 <USBD_LL_Transmit+0x18>)
 8008ca0:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status =  USBD_Get_USB_Status(hal_status); 
  
  return usb_status;    
}
 8008ca2:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8008ca4:	2002      	movs	r0, #2
}
 8008ca6:	bd08      	pop	{r3, pc}
 8008ca8:	0800926c 	.word	0x0800926c

08008cac <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8008cac:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8008cae:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8008cb2:	f7f8 ff51 	bl	8001b58 <HAL_PCD_EP_Receive>
 8008cb6:	2803      	cmp	r0, #3
 8008cb8:	d802      	bhi.n	8008cc0 <USBD_LL_PrepareReceive+0x14>
 8008cba:	4b02      	ldr	r3, [pc, #8]	; (8008cc4 <USBD_LL_PrepareReceive+0x18>)
 8008cbc:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status =  USBD_Get_USB_Status(hal_status);   
  
  return usb_status; 
}
 8008cbe:	bd08      	pop	{r3, pc}
  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8008cc0:	2002      	movs	r0, #2
}
 8008cc2:	bd08      	pop	{r3, pc}
 8008cc4:	0800926c 	.word	0x0800926c

08008cc8 <USBD_LL_GetRxDataSize>:
  * @param  ep_addr: Endpoint number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8008cc8:	f8d0 0298 	ldr.w	r0, [r0, #664]	; 0x298
 8008ccc:	f7f8 bf6c 	b.w	8001ba8 <HAL_PCD_EP_GetRxCount>

08008cd0 <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd: PCD handle
  * @param  msg: LPM message
  * @retval None
  */
void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 8008cd0:	b510      	push	{r4, lr}
 8008cd2:	4604      	mov	r4, r0
  switch (msg)
 8008cd4:	b1a1      	cbz	r1, 8008d00 <HAL_PCDEx_LPM_Callback+0x30>
 8008cd6:	2901      	cmp	r1, #1
 8008cd8:	d111      	bne.n	8008cfe <HAL_PCDEx_LPM_Callback+0x2e>
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
    USBD_LL_Resume(hpcd->pData);
    break;
    
  case PCD_LPM_L1_ACTIVE:
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8008cda:	6802      	ldr	r2, [r0, #0]
    USBD_LL_Suspend(hpcd->pData);
 8008cdc:	f8d0 0400 	ldr.w	r0, [r0, #1024]	; 0x400
    __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8008ce0:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 8008ce4:	f043 0301 	orr.w	r3, r3, #1
 8008ce8:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
    USBD_LL_Suspend(hpcd->pData);
 8008cec:	f7fb fdce 	bl	800488c <USBD_LL_Suspend>
    
    /* Enter in STOP mode. */
    if (hpcd->Init.low_power_enable)
 8008cf0:	6a23      	ldr	r3, [r4, #32]
 8008cf2:	b123      	cbz	r3, 8008cfe <HAL_PCDEx_LPM_Callback+0x2e>
    {   
      /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
      SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8008cf4:	4a0d      	ldr	r2, [pc, #52]	; (8008d2c <HAL_PCDEx_LPM_Callback+0x5c>)
 8008cf6:	6913      	ldr	r3, [r2, #16]
 8008cf8:	f043 0306 	orr.w	r3, r3, #6
 8008cfc:	6113      	str	r3, [r2, #16]
    }
    break;   
  }
}
 8008cfe:	bd10      	pop	{r4, pc}
    if (hpcd->Init.low_power_enable)
 8008d00:	6a03      	ldr	r3, [r0, #32]
 8008d02:	b133      	cbz	r3, 8008d12 <HAL_PCDEx_LPM_Callback+0x42>
  *         enable HSI, PLL and select PLL as system clock source.
  * @retval None
  */
static void SystemClockConfig_Resume(void)
{
  SystemClock_Config();
 8008d04:	f7fd fa14 	bl	8006130 <SystemClock_Config>
      SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8008d08:	4a08      	ldr	r2, [pc, #32]	; (8008d2c <HAL_PCDEx_LPM_Callback+0x5c>)
 8008d0a:	6913      	ldr	r3, [r2, #16]
 8008d0c:	f023 0306 	bic.w	r3, r3, #6
 8008d10:	6113      	str	r3, [r2, #16]
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8008d12:	6822      	ldr	r2, [r4, #0]
    USBD_LL_Resume(hpcd->pData);
 8008d14:	f8d4 0400 	ldr.w	r0, [r4, #1024]	; 0x400
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8008d18:	f8d2 3e00 	ldr.w	r3, [r2, #3584]	; 0xe00
 8008d1c:	f023 0301 	bic.w	r3, r3, #1
}
 8008d20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    __HAL_PCD_UNGATE_PHYCLOCK(hpcd);
 8008d24:	f8c2 3e00 	str.w	r3, [r2, #3584]	; 0xe00
    USBD_LL_Resume(hpcd->pData);
 8008d28:	f7fb bdba 	b.w	80048a0 <USBD_LL_Resume>
 8008d2c:	e000ed00 	.word	0xe000ed00

08008d30 <USBD_FS_DeviceDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 8008d30:	2312      	movs	r3, #18
  return USBD_FS_DeviceDesc;
}
 8008d32:	4801      	ldr	r0, [pc, #4]	; (8008d38 <USBD_FS_DeviceDescriptor+0x8>)
  *length = sizeof(USBD_FS_DeviceDesc);
 8008d34:	800b      	strh	r3, [r1, #0]
}
 8008d36:	4770      	bx	lr
 8008d38:	20000188 	.word	0x20000188

08008d3c <USBD_FS_LangIDStrDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_LangIDDesc);
 8008d3c:	2304      	movs	r3, #4
  return USBD_LangIDDesc;
}
 8008d3e:	4801      	ldr	r0, [pc, #4]	; (8008d44 <USBD_FS_LangIDStrDescriptor+0x8>)
  *length = sizeof(USBD_LangIDDesc);
 8008d40:	800b      	strh	r3, [r1, #0]
}
 8008d42:	4770      	bx	lr
 8008d44:	2000019c 	.word	0x2000019c

08008d48 <USBD_FS_USR_BOSDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_USR_BOSDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_FS_BOSDesc);
 8008d48:	230c      	movs	r3, #12
  return (uint8_t*)USBD_FS_BOSDesc;
}
 8008d4a:	4801      	ldr	r0, [pc, #4]	; (8008d50 <USBD_FS_USR_BOSDescriptor+0x8>)
  *length = sizeof(USBD_FS_BOSDesc);
 8008d4c:	800b      	strh	r3, [r1, #0]
}
 8008d4e:	4770      	bx	lr
 8008d50:	200001a0 	.word	0x200001a0

08008d54 <USBD_FS_ManufacturerStrDescriptor>:
{
 8008d54:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8008d56:	4c04      	ldr	r4, [pc, #16]	; (8008d68 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 8008d58:	460a      	mov	r2, r1
 8008d5a:	4804      	ldr	r0, [pc, #16]	; (8008d6c <USBD_FS_ManufacturerStrDescriptor+0x18>)
 8008d5c:	4621      	mov	r1, r4
 8008d5e:	f7fc f839 	bl	8004dd4 <USBD_GetString>
}
 8008d62:	4620      	mov	r0, r4
 8008d64:	bd10      	pop	{r4, pc}
 8008d66:	bf00      	nop
 8008d68:	2000199c 	.word	0x2000199c
 8008d6c:	08009270 	.word	0x08009270

08008d70 <USBD_FS_ProductStrDescriptor>:
{
 8008d70:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8008d72:	4c04      	ldr	r4, [pc, #16]	; (8008d84 <USBD_FS_ProductStrDescriptor+0x14>)
 8008d74:	460a      	mov	r2, r1
 8008d76:	4804      	ldr	r0, [pc, #16]	; (8008d88 <USBD_FS_ProductStrDescriptor+0x18>)
 8008d78:	4621      	mov	r1, r4
 8008d7a:	f7fc f82b 	bl	8004dd4 <USBD_GetString>
}
 8008d7e:	4620      	mov	r0, r4
 8008d80:	bd10      	pop	{r4, pc}
 8008d82:	bf00      	nop
 8008d84:	2000199c 	.word	0x2000199c
 8008d88:	08009278 	.word	0x08009278

08008d8c <USBD_FS_ConfigStrDescriptor>:
{
 8008d8c:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8008d8e:	4c04      	ldr	r4, [pc, #16]	; (8008da0 <USBD_FS_ConfigStrDescriptor+0x14>)
 8008d90:	460a      	mov	r2, r1
 8008d92:	4804      	ldr	r0, [pc, #16]	; (8008da4 <USBD_FS_ConfigStrDescriptor+0x18>)
 8008d94:	4621      	mov	r1, r4
 8008d96:	f7fc f81d 	bl	8004dd4 <USBD_GetString>
}
 8008d9a:	4620      	mov	r0, r4
 8008d9c:	bd10      	pop	{r4, pc}
 8008d9e:	bf00      	nop
 8008da0:	2000199c 	.word	0x2000199c
 8008da4:	0800928c 	.word	0x0800928c

08008da8 <USBD_FS_InterfaceStrDescriptor>:
{
 8008da8:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8008daa:	4c04      	ldr	r4, [pc, #16]	; (8008dbc <USBD_FS_InterfaceStrDescriptor+0x14>)
 8008dac:	460a      	mov	r2, r1
 8008dae:	4804      	ldr	r0, [pc, #16]	; (8008dc0 <USBD_FS_InterfaceStrDescriptor+0x18>)
 8008db0:	4621      	mov	r1, r4
 8008db2:	f7fc f80f 	bl	8004dd4 <USBD_GetString>
}
 8008db6:	4620      	mov	r0, r4
 8008db8:	bd10      	pop	{r4, pc}
 8008dba:	bf00      	nop
 8008dbc:	2000199c 	.word	0x2000199c
 8008dc0:	08009298 	.word	0x08009298

08008dc4 <USBD_FS_SerialStrDescriptor>:
  */
static void Get_SerialNum(void)
{
  uint32_t deviceserial0, deviceserial1, deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8008dc4:	4a55      	ldr	r2, [pc, #340]	; (8008f1c <USBD_FS_SerialStrDescriptor+0x158>)
  *length = USB_SIZ_STRING_SERIAL;
 8008dc6:	201a      	movs	r0, #26
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 8008dc8:	4b55      	ldr	r3, [pc, #340]	; (8008f20 <USBD_FS_SerialStrDescriptor+0x15c>)
  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 8008dca:	6812      	ldr	r2, [r2, #0]

  deviceserial0 += deviceserial2;
 8008dcc:	681b      	ldr	r3, [r3, #0]
  *length = USB_SIZ_STRING_SERIAL;
 8008dce:	8008      	strh	r0, [r1, #0]

  if (deviceserial0 != 0)
 8008dd0:	18d2      	adds	r2, r2, r3
 8008dd2:	d101      	bne.n	8008dd8 <USBD_FS_SerialStrDescriptor+0x14>
}
 8008dd4:	4853      	ldr	r0, [pc, #332]	; (8008f24 <USBD_FS_SerialStrDescriptor+0x160>)
 8008dd6:	4770      	bx	lr
{
  uint8_t idx = 0;

  for (idx = 0; idx < len; idx++)
  {
    if (((value >> 28)) < 0xA)
 8008dd8:	0f13      	lsrs	r3, r2, #28
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8008dda:	4953      	ldr	r1, [pc, #332]	; (8008f28 <USBD_FS_SerialStrDescriptor+0x164>)
 8008ddc:	b2d8      	uxtb	r0, r3
    if (((value >> 28)) < 0xA)
 8008dde:	2b09      	cmp	r3, #9
    {
      pbuf[2 * idx] = (value >> 28) + '0';
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008de0:	4b52      	ldr	r3, [pc, #328]	; (8008f2c <USBD_FS_SerialStrDescriptor+0x168>)
      pbuf[2 * idx] = (value >> 28) + '0';
 8008de2:	bf94      	ite	ls
 8008de4:	3030      	addls	r0, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008de6:	3037      	addhi	r0, #55	; 0x37
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 8008de8:	6809      	ldr	r1, [r1, #0]
{
 8008dea:	b410      	push	{r4}
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008dec:	f883 0026 	strb.w	r0, [r3, #38]	; 0x26
    }

    value = value << 4;

    pbuf[2 * idx + 1] = 0;
 8008df0:	2400      	movs	r4, #0
    if (((value >> 28)) < 0xA)
 8008df2:	f3c2 6003 	ubfx	r0, r2, #24, #4
    pbuf[2 * idx + 1] = 0;
 8008df6:	f883 4027 	strb.w	r4, [r3, #39]	; 0x27
    if (((value >> 28)) < 0xA)
 8008dfa:	2809      	cmp	r0, #9
 8008dfc:	b2c4      	uxtb	r4, r0
 8008dfe:	f3c2 5003 	ubfx	r0, r2, #20, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 8008e02:	bf94      	ite	ls
 8008e04:	3430      	addls	r4, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e06:	3437      	addhi	r4, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008e08:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e0a:	f883 4028 	strb.w	r4, [r3, #40]	; 0x28
    pbuf[2 * idx + 1] = 0;
 8008e0e:	f04f 0400 	mov.w	r4, #0
 8008e12:	f883 4029 	strb.w	r4, [r3, #41]	; 0x29
 8008e16:	b2c4      	uxtb	r4, r0
    if (((value >> 28)) < 0xA)
 8008e18:	f3c2 4003 	ubfx	r0, r2, #16, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 8008e1c:	bf94      	ite	ls
 8008e1e:	3430      	addls	r4, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e20:	3437      	addhi	r4, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008e22:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e24:	f883 402a 	strb.w	r4, [r3, #42]	; 0x2a
    pbuf[2 * idx + 1] = 0;
 8008e28:	f04f 0400 	mov.w	r4, #0
 8008e2c:	f883 402b 	strb.w	r4, [r3, #43]	; 0x2b
 8008e30:	b2c4      	uxtb	r4, r0
    if (((value >> 28)) < 0xA)
 8008e32:	f3c2 3003 	ubfx	r0, r2, #12, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 8008e36:	bf94      	ite	ls
 8008e38:	3430      	addls	r4, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e3a:	3437      	addhi	r4, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008e3c:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e3e:	f883 402c 	strb.w	r4, [r3, #44]	; 0x2c
    pbuf[2 * idx + 1] = 0;
 8008e42:	f04f 0400 	mov.w	r4, #0
 8008e46:	f883 402d 	strb.w	r4, [r3, #45]	; 0x2d
 8008e4a:	b2c4      	uxtb	r4, r0
    if (((value >> 28)) < 0xA)
 8008e4c:	f3c2 2003 	ubfx	r0, r2, #8, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 8008e50:	bf94      	ite	ls
 8008e52:	3430      	addls	r4, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e54:	3437      	addhi	r4, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008e56:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e58:	f883 402e 	strb.w	r4, [r3, #46]	; 0x2e
    pbuf[2 * idx + 1] = 0;
 8008e5c:	f04f 0400 	mov.w	r4, #0
 8008e60:	f883 402f 	strb.w	r4, [r3, #47]	; 0x2f
 8008e64:	b2c4      	uxtb	r4, r0
    if (((value >> 28)) < 0xA)
 8008e66:	f3c2 1003 	ubfx	r0, r2, #4, #4
 8008e6a:	f002 020f 	and.w	r2, r2, #15
      pbuf[2 * idx] = (value >> 28) + '0';
 8008e6e:	bf94      	ite	ls
 8008e70:	3430      	addls	r4, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e72:	3437      	addhi	r4, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008e74:	2809      	cmp	r0, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e76:	f883 4030 	strb.w	r4, [r3, #48]	; 0x30
    pbuf[2 * idx + 1] = 0;
 8008e7a:	f04f 0400 	mov.w	r4, #0
 8008e7e:	f883 4031 	strb.w	r4, [r3, #49]	; 0x31
 8008e82:	b2c4      	uxtb	r4, r0
 8008e84:	b2d0      	uxtb	r0, r2
      pbuf[2 * idx] = (value >> 28) + '0';
 8008e86:	bf94      	ite	ls
 8008e88:	3430      	addls	r4, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e8a:	3437      	addhi	r4, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008e8c:	2a09      	cmp	r2, #9
 8008e8e:	ea4f 7211 	mov.w	r2, r1, lsr #28
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e92:	f883 4032 	strb.w	r4, [r3, #50]	; 0x32
    pbuf[2 * idx + 1] = 0;
 8008e96:	f04f 0400 	mov.w	r4, #0
      pbuf[2 * idx] = (value >> 28) + '0';
 8008e9a:	bf94      	ite	ls
 8008e9c:	3030      	addls	r0, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008e9e:	3037      	addhi	r0, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008ea0:	2a09      	cmp	r2, #9
    pbuf[2 * idx + 1] = 0;
 8008ea2:	f883 4033 	strb.w	r4, [r3, #51]	; 0x33
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008ea6:	f883 0034 	strb.w	r0, [r3, #52]	; 0x34
    pbuf[2 * idx + 1] = 0;
 8008eaa:	f04f 0000 	mov.w	r0, #0
 8008eae:	f883 0035 	strb.w	r0, [r3, #53]	; 0x35
 8008eb2:	b2d0      	uxtb	r0, r2
    if (((value >> 28)) < 0xA)
 8008eb4:	f3c1 6203 	ubfx	r2, r1, #24, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 8008eb8:	bf94      	ite	ls
 8008eba:	3030      	addls	r0, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008ebc:	3037      	addhi	r0, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008ebe:	2a09      	cmp	r2, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008ec0:	f883 0036 	strb.w	r0, [r3, #54]	; 0x36
    pbuf[2 * idx + 1] = 0;
 8008ec4:	f04f 0000 	mov.w	r0, #0
 8008ec8:	f883 0037 	strb.w	r0, [r3, #55]	; 0x37
 8008ecc:	b2d0      	uxtb	r0, r2
    if (((value >> 28)) < 0xA)
 8008ece:	f3c1 5203 	ubfx	r2, r1, #20, #4
 8008ed2:	f3c1 4103 	ubfx	r1, r1, #16, #4
      pbuf[2 * idx] = (value >> 28) + '0';
 8008ed6:	bf94      	ite	ls
 8008ed8:	3030      	addls	r0, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008eda:	3037      	addhi	r0, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008edc:	2a09      	cmp	r2, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008ede:	f883 0038 	strb.w	r0, [r3, #56]	; 0x38
    pbuf[2 * idx + 1] = 0;
 8008ee2:	f04f 0000 	mov.w	r0, #0
 8008ee6:	f883 0039 	strb.w	r0, [r3, #57]	; 0x39
 8008eea:	b2d0      	uxtb	r0, r2
 8008eec:	b2ca      	uxtb	r2, r1
      pbuf[2 * idx] = (value >> 28) + '0';
 8008eee:	bf94      	ite	ls
 8008ef0:	3030      	addls	r0, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008ef2:	3037      	addhi	r0, #55	; 0x37
    if (((value >> 28)) < 0xA)
 8008ef4:	2909      	cmp	r1, #9
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008ef6:	f883 003a 	strb.w	r0, [r3, #58]	; 0x3a
    pbuf[2 * idx + 1] = 0;
 8008efa:	f04f 0000 	mov.w	r0, #0
      pbuf[2 * idx] = (value >> 28) + '0';
 8008efe:	bf94      	ite	ls
 8008f00:	3230      	addls	r2, #48	; 0x30
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008f02:	3237      	addhi	r2, #55	; 0x37
    pbuf[2 * idx + 1] = 0;
 8008f04:	f883 003b 	strb.w	r0, [r3, #59]	; 0x3b
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 8008f08:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    pbuf[2 * idx + 1] = 0;
 8008f0c:	2200      	movs	r2, #0
}
 8008f0e:	4805      	ldr	r0, [pc, #20]	; (8008f24 <USBD_FS_SerialStrDescriptor+0x160>)
    pbuf[2 * idx + 1] = 0;
 8008f10:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
}
 8008f14:	f85d 4b04 	ldr.w	r4, [sp], #4
 8008f18:	4770      	bx	lr
 8008f1a:	bf00      	nop
 8008f1c:	1ff0f420 	.word	0x1ff0f420
 8008f20:	1ff0f428 	.word	0x1ff0f428
 8008f24:	200001ac 	.word	0x200001ac
 8008f28:	1ff0f424 	.word	0x1ff0f424
 8008f2c:	20000188 	.word	0x20000188

08008f30 <MIDI_DeInit_FS>:
static int8_t MIDI_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */ 
  return (USBD_OK);
  /* USER CODE END 4 */ 
}
 8008f30:	2000      	movs	r0, #0
 8008f32:	4770      	bx	lr

08008f34 <MIDI_Control_FS>:
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 8008f34:	2000      	movs	r0, #0
 8008f36:	4770      	bx	lr

08008f38 <MIDI_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t MIDI_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
 8008f38:	b570      	push	{r4, r5, r6, lr}
 8008f3a:	4605      	mov	r5, r0
	int i;
	volatile uint32_t rxLen = Len[0];
 8008f3c:	680b      	ldr	r3, [r1, #0]
{
 8008f3e:	b082      	sub	sp, #8
  /* USER CODE BEGIN 6 */
  USBD_MIDI_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 8008f40:	480b      	ldr	r0, [pc, #44]	; (8008f70 <MIDI_Receive_FS+0x38>)
 8008f42:	4629      	mov	r1, r5
	volatile uint32_t rxLen = Len[0];
 8008f44:	9301      	str	r3, [sp, #4]
  USBD_MIDI_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 8008f46:	f7fb fb3f 	bl	80045c8 <USBD_MIDI_SetRxBuffer>
  USBD_MIDI_ReceivePacket(&hUsbDeviceFS);
 8008f4a:	4809      	ldr	r0, [pc, #36]	; (8008f70 <MIDI_Receive_FS+0x38>)
 8008f4c:	f7fb fb5a 	bl	8004604 <USBD_MIDI_ReceivePacket>
  for(i = 0; i < rxLen; i=i+4)
 8008f50:	9b01      	ldr	r3, [sp, #4]
 8008f52:	b14b      	cbz	r3, 8008f68 <MIDI_Receive_FS+0x30>
 8008f54:	2400      	movs	r4, #0
  {
	  push(&fifo,(midiData_t*)&Buf[i]);
 8008f56:	4e07      	ldr	r6, [pc, #28]	; (8008f74 <MIDI_Receive_FS+0x3c>)
 8008f58:	1929      	adds	r1, r5, r4
 8008f5a:	4630      	mov	r0, r6
 8008f5c:	f7fc f836 	bl	8004fcc <push>
  for(i = 0; i < rxLen; i=i+4)
 8008f60:	3404      	adds	r4, #4
 8008f62:	9b01      	ldr	r3, [sp, #4]
 8008f64:	429c      	cmp	r4, r3
 8008f66:	d3f7      	bcc.n	8008f58 <MIDI_Receive_FS+0x20>
  }
  return (USBD_OK);
  /* USER CODE END 6 */ 
}
 8008f68:	2000      	movs	r0, #0
 8008f6a:	b002      	add	sp, #8
 8008f6c:	bd70      	pop	{r4, r5, r6, pc}
 8008f6e:	bf00      	nop
 8008f70:	200012fc 	.word	0x200012fc
 8008f74:	20000828 	.word	0x20000828

08008f78 <MIDI_Init_FS>:
{ 
 8008f78:	b510      	push	{r4, lr}
  USBD_MIDI_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 8008f7a:	4c06      	ldr	r4, [pc, #24]	; (8008f94 <MIDI_Init_FS+0x1c>)
 8008f7c:	2200      	movs	r2, #0
 8008f7e:	4906      	ldr	r1, [pc, #24]	; (8008f98 <MIDI_Init_FS+0x20>)
 8008f80:	4620      	mov	r0, r4
 8008f82:	f7fb fb19 	bl	80045b8 <USBD_MIDI_SetTxBuffer>
  USBD_MIDI_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 8008f86:	4620      	mov	r0, r4
 8008f88:	4904      	ldr	r1, [pc, #16]	; (8008f9c <MIDI_Init_FS+0x24>)
 8008f8a:	f7fb fb1d 	bl	80045c8 <USBD_MIDI_SetRxBuffer>
}
 8008f8e:	2000      	movs	r0, #0
 8008f90:	bd10      	pop	{r4, pc}
 8008f92:	bf00      	nop
 8008f94:	200012fc 	.word	0x200012fc
 8008f98:	2000239c 	.word	0x2000239c
 8008f9c:	20001b9c 	.word	0x20001b9c

08008fa0 <MIDI_Transmit_FS>:
  * @param  Buf: Buffer of data to be send
  * @param  Len: Number of data to be send (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t MIDI_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 8008fa0:	b510      	push	{r4, lr}
  uint8_t result = USBD_OK;
  /* USER CODE BEGIN 7 */ 
  USBD_MIDI_HandleTypeDef *hmidi = (USBD_MIDI_HandleTypeDef*)hUsbDeviceFS.pClassData;
 8008fa2:	4c09      	ldr	r4, [pc, #36]	; (8008fc8 <MIDI_Transmit_FS+0x28>)
 8008fa4:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
  if (hmidi->TxState != 0){
 8008fa8:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
 8008fac:	b10b      	cbz	r3, 8008fb2 <MIDI_Transmit_FS+0x12>
  }
  USBD_MIDI_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
  result = USBD_MIDI_TransmitPacket(&hUsbDeviceFS);
  /* USER CODE END 7 */ 
  return result;
}
 8008fae:	2001      	movs	r0, #1
 8008fb0:	bd10      	pop	{r4, pc}
 8008fb2:	460a      	mov	r2, r1
 8008fb4:	4601      	mov	r1, r0
  USBD_MIDI_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 8008fb6:	4620      	mov	r0, r4
 8008fb8:	f7fb fafe 	bl	80045b8 <USBD_MIDI_SetTxBuffer>
  result = USBD_MIDI_TransmitPacket(&hUsbDeviceFS);
 8008fbc:	4620      	mov	r0, r4
}
 8008fbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  result = USBD_MIDI_TransmitPacket(&hUsbDeviceFS);
 8008fc2:	f7fb bb07 	b.w	80045d4 <USBD_MIDI_TransmitPacket>
 8008fc6:	bf00      	nop
 8008fc8:	200012fc 	.word	0x200012fc

08008fcc <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8008fcc:	f8df d034 	ldr.w	sp, [pc, #52]	; 8009004 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8008fd0:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8008fd2:	e003      	b.n	8008fdc <LoopCopyDataInit>

08008fd4 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8008fd4:	4b0c      	ldr	r3, [pc, #48]	; (8009008 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8008fd6:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8008fd8:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8008fda:	3104      	adds	r1, #4

08008fdc <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8008fdc:	480b      	ldr	r0, [pc, #44]	; (800900c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8008fde:	4b0c      	ldr	r3, [pc, #48]	; (8009010 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8008fe0:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8008fe2:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8008fe4:	d3f6      	bcc.n	8008fd4 <CopyDataInit>
  ldr  r2, =_sbss
 8008fe6:	4a0b      	ldr	r2, [pc, #44]	; (8009014 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8008fe8:	e002      	b.n	8008ff0 <LoopFillZerobss>

08008fea <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8008fea:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8008fec:	f842 3b04 	str.w	r3, [r2], #4

08008ff0 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8008ff0:	4b09      	ldr	r3, [pc, #36]	; (8009018 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8008ff2:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8008ff4:	d3f9      	bcc.n	8008fea <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8008ff6:	f7fd fdff 	bl	8006bf8 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8008ffa:	f000 f817 	bl	800902c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8008ffe:	f7fd f8f3 	bl	80061e8 <main>
  bx  lr    
 8009002:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8009004:	20050000 	.word	0x20050000
  ldr  r3, =_sidata
 8009008:	080092b8 	.word	0x080092b8
  ldr  r0, =_sdata
 800900c:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8009010:	2000025c 	.word	0x2000025c
  ldr  r2, =_sbss
 8009014:	2000025c 	.word	0x2000025c
  ldr  r3, = _ebss
 8009018:	20002ba0 	.word	0x20002ba0

0800901c <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800901c:	e7fe      	b.n	800901c <ADC_IRQHandler>
	...

08009020 <__errno>:
 8009020:	4b01      	ldr	r3, [pc, #4]	; (8009028 <__errno+0x8>)
 8009022:	6818      	ldr	r0, [r3, #0]
 8009024:	4770      	bx	lr
 8009026:	bf00      	nop
 8009028:	200001f8 	.word	0x200001f8

0800902c <__libc_init_array>:
 800902c:	b570      	push	{r4, r5, r6, lr}
 800902e:	4e0d      	ldr	r6, [pc, #52]	; (8009064 <__libc_init_array+0x38>)
 8009030:	4c0d      	ldr	r4, [pc, #52]	; (8009068 <__libc_init_array+0x3c>)
 8009032:	1ba4      	subs	r4, r4, r6
 8009034:	10a4      	asrs	r4, r4, #2
 8009036:	2500      	movs	r5, #0
 8009038:	42a5      	cmp	r5, r4
 800903a:	d109      	bne.n	8009050 <__libc_init_array+0x24>
 800903c:	4e0b      	ldr	r6, [pc, #44]	; (800906c <__libc_init_array+0x40>)
 800903e:	4c0c      	ldr	r4, [pc, #48]	; (8009070 <__libc_init_array+0x44>)
 8009040:	f000 f8ea 	bl	8009218 <_init>
 8009044:	1ba4      	subs	r4, r4, r6
 8009046:	10a4      	asrs	r4, r4, #2
 8009048:	2500      	movs	r5, #0
 800904a:	42a5      	cmp	r5, r4
 800904c:	d105      	bne.n	800905a <__libc_init_array+0x2e>
 800904e:	bd70      	pop	{r4, r5, r6, pc}
 8009050:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8009054:	4798      	blx	r3
 8009056:	3501      	adds	r5, #1
 8009058:	e7ee      	b.n	8009038 <__libc_init_array+0xc>
 800905a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800905e:	4798      	blx	r3
 8009060:	3501      	adds	r5, #1
 8009062:	e7f2      	b.n	800904a <__libc_init_array+0x1e>
 8009064:	080092b0 	.word	0x080092b0
 8009068:	080092b0 	.word	0x080092b0
 800906c:	080092b0 	.word	0x080092b0
 8009070:	080092b4 	.word	0x080092b4

08009074 <malloc>:
 8009074:	4b02      	ldr	r3, [pc, #8]	; (8009080 <malloc+0xc>)
 8009076:	4601      	mov	r1, r0
 8009078:	6818      	ldr	r0, [r3, #0]
 800907a:	f000 b861 	b.w	8009140 <_malloc_r>
 800907e:	bf00      	nop
 8009080:	200001f8 	.word	0x200001f8

08009084 <free>:
 8009084:	4b02      	ldr	r3, [pc, #8]	; (8009090 <free+0xc>)
 8009086:	4601      	mov	r1, r0
 8009088:	6818      	ldr	r0, [r3, #0]
 800908a:	f000 b80b 	b.w	80090a4 <_free_r>
 800908e:	bf00      	nop
 8009090:	200001f8 	.word	0x200001f8

08009094 <memset>:
 8009094:	4402      	add	r2, r0
 8009096:	4603      	mov	r3, r0
 8009098:	4293      	cmp	r3, r2
 800909a:	d100      	bne.n	800909e <memset+0xa>
 800909c:	4770      	bx	lr
 800909e:	f803 1b01 	strb.w	r1, [r3], #1
 80090a2:	e7f9      	b.n	8009098 <memset+0x4>

080090a4 <_free_r>:
 80090a4:	b538      	push	{r3, r4, r5, lr}
 80090a6:	4605      	mov	r5, r0
 80090a8:	2900      	cmp	r1, #0
 80090aa:	d045      	beq.n	8009138 <_free_r+0x94>
 80090ac:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80090b0:	1f0c      	subs	r4, r1, #4
 80090b2:	2b00      	cmp	r3, #0
 80090b4:	bfb8      	it	lt
 80090b6:	18e4      	addlt	r4, r4, r3
 80090b8:	f000 f8ac 	bl	8009214 <__malloc_lock>
 80090bc:	4a1f      	ldr	r2, [pc, #124]	; (800913c <_free_r+0x98>)
 80090be:	6813      	ldr	r3, [r2, #0]
 80090c0:	4610      	mov	r0, r2
 80090c2:	b933      	cbnz	r3, 80090d2 <_free_r+0x2e>
 80090c4:	6063      	str	r3, [r4, #4]
 80090c6:	6014      	str	r4, [r2, #0]
 80090c8:	4628      	mov	r0, r5
 80090ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80090ce:	f000 b8a2 	b.w	8009216 <__malloc_unlock>
 80090d2:	42a3      	cmp	r3, r4
 80090d4:	d90c      	bls.n	80090f0 <_free_r+0x4c>
 80090d6:	6821      	ldr	r1, [r4, #0]
 80090d8:	1862      	adds	r2, r4, r1
 80090da:	4293      	cmp	r3, r2
 80090dc:	bf04      	itt	eq
 80090de:	681a      	ldreq	r2, [r3, #0]
 80090e0:	685b      	ldreq	r3, [r3, #4]
 80090e2:	6063      	str	r3, [r4, #4]
 80090e4:	bf04      	itt	eq
 80090e6:	1852      	addeq	r2, r2, r1
 80090e8:	6022      	streq	r2, [r4, #0]
 80090ea:	6004      	str	r4, [r0, #0]
 80090ec:	e7ec      	b.n	80090c8 <_free_r+0x24>
 80090ee:	4613      	mov	r3, r2
 80090f0:	685a      	ldr	r2, [r3, #4]
 80090f2:	b10a      	cbz	r2, 80090f8 <_free_r+0x54>
 80090f4:	42a2      	cmp	r2, r4
 80090f6:	d9fa      	bls.n	80090ee <_free_r+0x4a>
 80090f8:	6819      	ldr	r1, [r3, #0]
 80090fa:	1858      	adds	r0, r3, r1
 80090fc:	42a0      	cmp	r0, r4
 80090fe:	d10b      	bne.n	8009118 <_free_r+0x74>
 8009100:	6820      	ldr	r0, [r4, #0]
 8009102:	4401      	add	r1, r0
 8009104:	1858      	adds	r0, r3, r1
 8009106:	4282      	cmp	r2, r0
 8009108:	6019      	str	r1, [r3, #0]
 800910a:	d1dd      	bne.n	80090c8 <_free_r+0x24>
 800910c:	6810      	ldr	r0, [r2, #0]
 800910e:	6852      	ldr	r2, [r2, #4]
 8009110:	605a      	str	r2, [r3, #4]
 8009112:	4401      	add	r1, r0
 8009114:	6019      	str	r1, [r3, #0]
 8009116:	e7d7      	b.n	80090c8 <_free_r+0x24>
 8009118:	d902      	bls.n	8009120 <_free_r+0x7c>
 800911a:	230c      	movs	r3, #12
 800911c:	602b      	str	r3, [r5, #0]
 800911e:	e7d3      	b.n	80090c8 <_free_r+0x24>
 8009120:	6820      	ldr	r0, [r4, #0]
 8009122:	1821      	adds	r1, r4, r0
 8009124:	428a      	cmp	r2, r1
 8009126:	bf04      	itt	eq
 8009128:	6811      	ldreq	r1, [r2, #0]
 800912a:	6852      	ldreq	r2, [r2, #4]
 800912c:	6062      	str	r2, [r4, #4]
 800912e:	bf04      	itt	eq
 8009130:	1809      	addeq	r1, r1, r0
 8009132:	6021      	streq	r1, [r4, #0]
 8009134:	605c      	str	r4, [r3, #4]
 8009136:	e7c7      	b.n	80090c8 <_free_r+0x24>
 8009138:	bd38      	pop	{r3, r4, r5, pc}
 800913a:	bf00      	nop
 800913c:	20000290 	.word	0x20000290

08009140 <_malloc_r>:
 8009140:	b570      	push	{r4, r5, r6, lr}
 8009142:	1ccd      	adds	r5, r1, #3
 8009144:	f025 0503 	bic.w	r5, r5, #3
 8009148:	3508      	adds	r5, #8
 800914a:	2d0c      	cmp	r5, #12
 800914c:	bf38      	it	cc
 800914e:	250c      	movcc	r5, #12
 8009150:	2d00      	cmp	r5, #0
 8009152:	4606      	mov	r6, r0
 8009154:	db01      	blt.n	800915a <_malloc_r+0x1a>
 8009156:	42a9      	cmp	r1, r5
 8009158:	d903      	bls.n	8009162 <_malloc_r+0x22>
 800915a:	230c      	movs	r3, #12
 800915c:	6033      	str	r3, [r6, #0]
 800915e:	2000      	movs	r0, #0
 8009160:	bd70      	pop	{r4, r5, r6, pc}
 8009162:	f000 f857 	bl	8009214 <__malloc_lock>
 8009166:	4a21      	ldr	r2, [pc, #132]	; (80091ec <_malloc_r+0xac>)
 8009168:	6814      	ldr	r4, [r2, #0]
 800916a:	4621      	mov	r1, r4
 800916c:	b991      	cbnz	r1, 8009194 <_malloc_r+0x54>
 800916e:	4c20      	ldr	r4, [pc, #128]	; (80091f0 <_malloc_r+0xb0>)
 8009170:	6823      	ldr	r3, [r4, #0]
 8009172:	b91b      	cbnz	r3, 800917c <_malloc_r+0x3c>
 8009174:	4630      	mov	r0, r6
 8009176:	f000 f83d 	bl	80091f4 <_sbrk_r>
 800917a:	6020      	str	r0, [r4, #0]
 800917c:	4629      	mov	r1, r5
 800917e:	4630      	mov	r0, r6
 8009180:	f000 f838 	bl	80091f4 <_sbrk_r>
 8009184:	1c43      	adds	r3, r0, #1
 8009186:	d124      	bne.n	80091d2 <_malloc_r+0x92>
 8009188:	230c      	movs	r3, #12
 800918a:	6033      	str	r3, [r6, #0]
 800918c:	4630      	mov	r0, r6
 800918e:	f000 f842 	bl	8009216 <__malloc_unlock>
 8009192:	e7e4      	b.n	800915e <_malloc_r+0x1e>
 8009194:	680b      	ldr	r3, [r1, #0]
 8009196:	1b5b      	subs	r3, r3, r5
 8009198:	d418      	bmi.n	80091cc <_malloc_r+0x8c>
 800919a:	2b0b      	cmp	r3, #11
 800919c:	d90f      	bls.n	80091be <_malloc_r+0x7e>
 800919e:	600b      	str	r3, [r1, #0]
 80091a0:	50cd      	str	r5, [r1, r3]
 80091a2:	18cc      	adds	r4, r1, r3
 80091a4:	4630      	mov	r0, r6
 80091a6:	f000 f836 	bl	8009216 <__malloc_unlock>
 80091aa:	f104 000b 	add.w	r0, r4, #11
 80091ae:	1d23      	adds	r3, r4, #4
 80091b0:	f020 0007 	bic.w	r0, r0, #7
 80091b4:	1ac3      	subs	r3, r0, r3
 80091b6:	d0d3      	beq.n	8009160 <_malloc_r+0x20>
 80091b8:	425a      	negs	r2, r3
 80091ba:	50e2      	str	r2, [r4, r3]
 80091bc:	e7d0      	b.n	8009160 <_malloc_r+0x20>
 80091be:	428c      	cmp	r4, r1
 80091c0:	684b      	ldr	r3, [r1, #4]
 80091c2:	bf16      	itet	ne
 80091c4:	6063      	strne	r3, [r4, #4]
 80091c6:	6013      	streq	r3, [r2, #0]
 80091c8:	460c      	movne	r4, r1
 80091ca:	e7eb      	b.n	80091a4 <_malloc_r+0x64>
 80091cc:	460c      	mov	r4, r1
 80091ce:	6849      	ldr	r1, [r1, #4]
 80091d0:	e7cc      	b.n	800916c <_malloc_r+0x2c>
 80091d2:	1cc4      	adds	r4, r0, #3
 80091d4:	f024 0403 	bic.w	r4, r4, #3
 80091d8:	42a0      	cmp	r0, r4
 80091da:	d005      	beq.n	80091e8 <_malloc_r+0xa8>
 80091dc:	1a21      	subs	r1, r4, r0
 80091de:	4630      	mov	r0, r6
 80091e0:	f000 f808 	bl	80091f4 <_sbrk_r>
 80091e4:	3001      	adds	r0, #1
 80091e6:	d0cf      	beq.n	8009188 <_malloc_r+0x48>
 80091e8:	6025      	str	r5, [r4, #0]
 80091ea:	e7db      	b.n	80091a4 <_malloc_r+0x64>
 80091ec:	20000290 	.word	0x20000290
 80091f0:	20000294 	.word	0x20000294

080091f4 <_sbrk_r>:
 80091f4:	b538      	push	{r3, r4, r5, lr}
 80091f6:	4c06      	ldr	r4, [pc, #24]	; (8009210 <_sbrk_r+0x1c>)
 80091f8:	2300      	movs	r3, #0
 80091fa:	4605      	mov	r5, r0
 80091fc:	4608      	mov	r0, r1
 80091fe:	6023      	str	r3, [r4, #0]
 8009200:	f7fd fcdc 	bl	8006bbc <_sbrk>
 8009204:	1c43      	adds	r3, r0, #1
 8009206:	d102      	bne.n	800920e <_sbrk_r+0x1a>
 8009208:	6823      	ldr	r3, [r4, #0]
 800920a:	b103      	cbz	r3, 800920e <_sbrk_r+0x1a>
 800920c:	602b      	str	r3, [r5, #0]
 800920e:	bd38      	pop	{r3, r4, r5, pc}
 8009210:	20002b9c 	.word	0x20002b9c

08009214 <__malloc_lock>:
 8009214:	4770      	bx	lr

08009216 <__malloc_unlock>:
 8009216:	4770      	bx	lr

08009218 <_init>:
 8009218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800921a:	bf00      	nop
 800921c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800921e:	bc08      	pop	{r3}
 8009220:	469e      	mov	lr, r3
 8009222:	4770      	bx	lr

08009224 <_fini>:
 8009224:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009226:	bf00      	nop
 8009228:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800922a:	bc08      	pop	{r3}
 800922c:	469e      	mov	lr, r3
 800922e:	4770      	bx	lr
